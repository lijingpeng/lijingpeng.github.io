<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Frank]]></title>
  <subtitle><![CDATA[Li Jingpeng's site]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-09-03T02:54:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Li Jingpeng]]></name>
    <email><![CDATA[me@lijingpeng.org]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Monument Vallay Pictures]]></title>
    <link href="http://yoursite.com/2014/11/14/other/monumentvallay/"/>
    <id>http://yoursite.com/2014/11/14/other/monumentvallay/</id>
    <published>2014-11-13T16:00:00.000Z</published>
    <updated>2015-09-03T02:54:12.000Z</updated>
    <content type="html"><![CDATA[<p>纪念碑谷（Monument Vallay）游戏截图</p>
<p><img src="/images/mm/mm1.jpg" alt="mm"><br><img src="/images/mm/mm2.jpg" alt="mm"><br><img src="/images/mm/mm3.jpg" alt="mm"><br><img src="/images/mm/mm4.jpg" alt="mm"><br><img src="/images/mm/mm5.jpg" alt="mm"><br><img src="/images/mm/mm6.jpg" alt="mm"><br><img src="/images/mm/mm7.jpg" alt="mm"><br><img src="/images/mm/mm8.jpg" alt="mm"><br><img src="/images/mm/mm9.jpg" alt="mm"><br><img src="/images/mm/mm10.jpg" alt="mm"><br><img src="/images/mm/mm11.jpg" alt="mm"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>纪念碑谷（Monument Vallay）游戏截图</p>
<p><img src="/images/mm/mm1.jpg" alt="mm"><br><img src="/images/mm/mm2.jpg" alt="mm"><br><img src="/images/]]>
    </summary>
    
      <category term="Monument Vallay" scheme="http://yoursite.com/tags/Monument-Vallay/"/>
    
      <category term="other" scheme="http://yoursite.com/categories/other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Zabbix]]></title>
    <link href="http://yoursite.com/2014/06/15/opensource/zabbix/"/>
    <id>http://yoursite.com/2014/06/15/opensource/zabbix/</id>
    <published>2014-06-14T16:00:00.000Z</published>
    <updated>2015-09-03T02:43:50.000Z</updated>
    <content type="html"><![CDATA[<p>　　zabbix(音同 zæbix)是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位和解决存在的各种问题。zabbix由2部分构成，zabbix server与可选组件zabbix agent. zabbix server可以通过SNMP，zabbix agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux, Solaris, HP-UX, AIX, Free BSD, Open BSD, OS X等平台上。</p>
<p>　　zabbix agent需要安装在被监视的目标服务器上，它主要完成对硬件信息或与操作系统有关的内存，CPU等信息的收集。zabbix agent可以运行在Linux,Solaris,HP-UX,AIX,Free BSD,Open BSD, OS X, Tru64/OSF1, Windows NT4.0, Windows (2000/2003/XP/Vista)等系统之上。 zabbix server可以单独监视远程服务器的服务状态；同时也可以与zabbix agent配合，可以轮询zabbix agent主动接收监视数据（agent方式），同时还可被动接收zabbix agent发送的数据（trapping方式）。 另外zabbix server还支持SNMP (v1,v2)，可以与SNMP软件(例如：net-snmp)等配合使用.</p>
<p><img src="/images/zabbix.png" alt="zabbix"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　zabbix(音同 zæbix)是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位和解决存在的各种问题。zabbix由2部分构成，zabbi]]>
    </summary>
    
      <category term="监控，zabbix" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7%EF%BC%8Czabbix/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[图解各种开源许可证]]></title>
    <link href="http://yoursite.com/2014/06/09/opensource/license/"/>
    <id>http://yoursite.com/2014/06/09/opensource/license/</id>
    <published>2014-06-08T16:00:00.000Z</published>
    <updated>2015-09-03T02:29:05.000Z</updated>
    <content type="html"><![CDATA[<p>一张图读懂开源许可证<br><img src="/images/license.png" alt="Open source license"></p>
<h2 id=""><br></h2><p>图片来自网络</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一张图读懂开源许可证<br><img src="/images/license.png" alt="Open source license"></p>
<h2 id=""><br></h2><p>图片来自网络</p>
]]>
    </summary>
    
      <category term="开源，许可" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%EF%BC%8C%E8%AE%B8%E5%8F%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift and LLVM]]></title>
    <link href="http://yoursite.com/2014/06/08/opensource/Swiftandllvm/"/>
    <id>http://yoursite.com/2014/06/08/opensource/Swiftandllvm/</id>
    <published>2014-06-07T16:00:00.000Z</published>
    <updated>2015-09-03T02:36:25.000Z</updated>
    <content type="html"><![CDATA[<p>2014年6月2号，苹果在一年一度的WWDC上发布了新的编程语言Swift，根据苹果的官方介绍，Swift从开始研发到最终发布用了仅不足4年的时间，这应该算是一个比较短的时间周期了，另外WWDC上苹果还介绍了Swift的一些关键特性，例如：</p>
<ul>
<li>Swift从一些脚本语言如Python、Ruby、Javascript上吸取了一些好的特性</li>
<li>提供实时预览Playgrounds</li>
<li>性能比Objective-C 提升了大约40%～50%  </li>
</ul>
<p>当然还有一些其他的特性，在这里就不列举了，不过从性能指标上来看，这个提升度是相当惊人的，这背后“必有蹊跷”，看看Swift的研发团队——苹果开发者工具部门总监克里斯·拉特纳（Chris Lattner）及其所带领的团队，我们可能恍然大悟，Lattner时LLVM项目的发起人，也是主要作者，在此，我们也简要介绍一下LLVM项目</p>
<blockquote>
<p>LVM，命名最早源自于底层虚拟机（Low Level Virtual Machine）的缩写。它是一个编译器的基础建设，以C++写成。它是为了任意一种编程语言写成的程序，利用虚拟技术，创造出编译时期，链结时期，运行时期以及“闲置时期”的优化。它最早是以C/C++为实现对象，目前它支持了包括ActionScript、Ada、D语言、Fortran、GLSL、Haskell、Java bytecode、Objective-C、Swift、Python、Ruby、Rust、Scala以及C♯。[1]<br>LLVM项目起源于2000年伊利诺伊大学厄巴纳-香槟分校维克拉姆·艾夫（Vikram Adve）与克里斯·拉特纳（Chris Lattner）的研究发展而成，他们想要为所有静态及动态语言创造出动态的编译技术。LLVM是以BSD授权来发展的开源码软件。在2005年，苹果计算机雇用了克里斯·拉特纳及他的团队，为了苹果计算机开发应用程序系统，LLVM为现今Mac OS X及iOS开发工具的一部分。[1]<br>LLVM的起名为Low Level Virtual Machine的首字字母缩写，由于这个项目的范围并不局限于创建一个虚拟机，所以这个缩写导致了广泛的疑惑。之后，LLVM开始成长，他成为众多编译工具及低级工具技术的统称，这使得这个名字变得更不贴切，所以这个项目放弃了这个缩写的意涵，现今LLVM已经单纯成为一个品牌，适用于LLVM底下的所有项目，包含LLVM中介码（LLVM IR）、LLVM除错工具、LLVM C++标准库…等。[1]</p>
<p>运行时期的性能，平均GCC比LLVM高出10%的性能。2013年的测试结果，LLVM可以编译出接近与GCC接近相同性能的运行码。[1]</p>
<p>LLVM引发一些人来为许多语言开发新的编译器，其中一个最引发注意的就是Clang，它是一个新的编译器，同时支持C、Objective-C以及C++。Clang本身性能优异，其生成的AST所耗用掉的内存仅仅是GCC的20%左右。FreeBSD 10预计使用Clang取代GCC。[2]</p>
</blockquote>
<p>由于GCC下面的Objective-C项目很早之前就已经停止了，所以苹果公司有意识的考虑GCC的替代品来作为自家Mac和IOS的开发工具，因此如上文所言，苹果雇佣了Lattner和他的团队，LLVM也取代了GCC作为开发者的编译工具，与此同时，经过4年多的发展，开发工具团队在LLVM的基础上，总结现有的Objective-C的优点和劣势，并结合其他语言的长处，在WWDC上推出了新的Swift语言，虽然官方说的新特性尤其是性能指标还有待检验，但是新语言的发布对众多苹果开发者来说无疑是一大福音，他们再也无需面对OC那些晦涩的语法了，新语言的简洁性也将会吸引更多的开发者来做开发。</p>
<p>可见拥有一个大牛的团队是何等的重要啊，因LLVM对产业的贡献，计算机协会于2012年授与Adve、Lattner及Evan ChengACM软件系统奖。[1]</p>
<p><br></p>
<h4 id="参考文献">参考文献</h4><hr>
<ol>
<li><a href="http://zh.wikipedia.org/wiki/LLVM" target="_blank" rel="external">http://zh.wikipedia.org/wiki/LLVM</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Clang" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Clang</a></li>
</ol>
<p>上文引用均来自维基百科，在此向所有的维基人表示感谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2014年6月2号，苹果在一年一度的WWDC上发布了新的编程语言Swift，根据苹果的官方介绍，Swift从开始研发到最终发布用了仅不足4年的时间，这应该算是一个比较短的时间周期了，另外WWDC上苹果还介绍了Swift的一些关键特性，例如：</p>
<ul>
<li>Swi]]>
    </summary>
    
      <category term="swift, llvm" scheme="http://yoursite.com/tags/swift-llvm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ldd 命令的介绍和使用方法]]></title>
    <link href="http://yoursite.com/2014/06/06/system/ldd_usage/"/>
    <id>http://yoursite.com/2014/06/06/system/ldd_usage/</id>
    <published>2014-06-05T16:00:00.000Z</published>
    <updated>2015-09-03T02:47:08.000Z</updated>
    <content type="html"><![CDATA[<p>ldd 能够显示可执行模块的dependency，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_OBJECTS环境变量不为空时，任何可执行程序在运行时，它都会只显示模块的dependency，而程序并不真正执行。</p>
<p>它的执行原理就是通过ld-linux.so（elf动态库的装载器）来实现的。我们知道，ld-linux.so模块会先于executable模块程序工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。<br>例如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frank@linux:~/dev$ ldd a.out</span><br><span class="line">	linux-vdso.so.<span class="number">1</span> =&gt;  (<span class="number">0</span>x00007fff3bffe000)</span><br><span class="line">	libstdc++.so.<span class="number">6</span> =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.<span class="number">6</span> (<span class="number">0</span>x00007f1faa400000)</span><br><span class="line">	libc.so.<span class="number">6</span> =&gt; /lib/x86_64-linux-gnu/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007f1faa03a000)</span><br><span class="line">	libm.so.<span class="number">6</span> =&gt; /lib/x86_64-linux-gnu/libm.so.<span class="number">6</span> (<span class="number">0</span>x00007f1fa9d33000)</span><br><span class="line">	/lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span> (<span class="number">0</span>x00007f1faa72b000)</span><br><span class="line">	libgcc_s.so.<span class="number">1</span> =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.<span class="number">1</span> (<span class="number">0</span>x00007f1fa9b1d000)</span><br></pre></td></tr></table></figure></p>
<p>实际上可以直接执行ld-linux.so模块，如：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/lib/ld-linux.so.<span class="number">2</span> --list program</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ldd 能够显示可执行模块的dependency，其原理是通过设置一系列的环境变量，如下：LD_TRACE_LOADED_OBJECTS、LD_WARN、LD_BIND_NOW、LD_LIBRARY_VERSION、LD_VERBOSE等。当LD_TRACE_LOADED_]]>
    </summary>
    
      <category term="linux, ldd, 依赖关系" scheme="http://yoursite.com/tags/linux-ldd-%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github pages 搭建个人博客并绑定域名]]></title>
    <link href="http://yoursite.com/2014/06/05/config/gitpages/"/>
    <id>http://yoursite.com/2014/06/05/config/gitpages/</id>
    <published>2014-06-04T16:00:00.000Z</published>
    <updated>2015-09-03T01:54:20.000Z</updated>
    <content type="html"><![CDATA[<p>目前，github下pelican搭建的极简主义的博客越来越受到大家的欢迎，本文介绍在github中一个仓库同时保存Markdown博客主内容和HTML网页，并绑定域名。 我们将markdown文件保存在仓库的master分支中，将HTML网页保存在gh-pages分支中，并将域名绑定到gh-pages分支，下面是操作步骤：</p>
<h4 id="1-_首先在github创建仓库">1. 首先在github创建仓库</h4><p>并不局限于username.github.com这种的顶级域名仓库，如果想创建类似blog.example.com的博客，直接创建一个名字为blog的仓库即可。</p>
<h4 id="2-_克隆到本地：">2. 克隆到本地：</h4><pre><code>git clone git@github<span class="class">.com</span>:yourusername/blog<span class="class">.git</span> 
</code></pre><h4 id="3-_在克隆后的blog目录中初始化pelican工作目录">3. 在克隆后的blog目录中初始化pelican工作目录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog  </span><br><span class="line">pelican-quickstart</span><br></pre></td></tr></table></figure>
<p>这样，本地blog目录将会有以下目录结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">content  </span><br><span class="line">develop_server.sh*  </span><br><span class="line">fabfile.py  </span><br><span class="line">Makefile  </span><br><span class="line">output  </span><br><span class="line">pelicanconf.py  </span><br><span class="line">pelicanconf.pyc   </span><br><span class="line">publishconf.py  </span><br><span class="line">.git</span><br></pre></td></tr></table></figure></p>
<p>其中.git表示本目录被git所管理，因为我们知道markdown所写的内容必须放到content下，<strong>因此我们可以将.git目录拷贝到content目录</strong></p>
<pre><code>cp -r <span class="class">.git</span> <span class="attribute">content</span>/
</code></pre><p>这样就确保我们的md文件将会被同步到github仓库的master分支</p>
<h4 id="4-_创建分支">4. 创建分支</h4><p>进入content目录，并创建gh-pages分支（必须是这个分支名字）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b gh-pages  </span><br><span class="line">git push -u origin gh-pages  </span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure></p>
<p><strong>在这一步骤中，只要我们自己创建gh-pages分支并同步到远端的时候，github会自动为我们建立一个可以访问的URL地址，格式是：<a href="http://username.github.io/blog" target="_blank" rel="external">http://username.github.io/blog</a></strong></p>
<h4 id="5-_同步静态网站到分支">5. 同步静态网站到分支</h4><p>pelican处理markdown生成的html文件将会放到output目录中，因此我们将gh-pages的checkout到该目录，以后html更新后，只需要在该目录下push即可。</p>
<p>克隆分支，在blog目录下：</p>
<pre><code>git clone -<span class="tag">b</span> gh-pages git@github<span class="class">.com</span>:username/blog<span class="class">.git</span> output
</code></pre><h4 id="6-_测试">6. 测试</h4><ul>
<li>在content目录下随便写一篇文章，例如example.md<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add example.md</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这将会把该md文件同步到远端主分支，起到一定的备份作用</p>
<ul>
<li>退出到blog目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>生成HTML文件到output目录</p>
<ul>
<li>到output目录下<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git add .</span><br><span class="line">git push origin gh-pages</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就将网页同步到gh-pages分支了，打开浏览器，访问<br><a href="http://username.github.io/blog" target="_blank" rel="external">http://username.github.io/blog</a><br>看看是不是能访问了</p>
<h4 id="7-_绑定域名">7. 绑定域名</h4><ul>
<li>在DNS解析商那设置二级域名，例如本例中的blog，添加CNAME，指向username.github.io.</li>
<li>在output目录下创建CNAME文件，内容为要指向的域名，例如：blog.example.com，push到远端gh-pages分支即可。</li>
</ul>
<h4 id="8-_Notice">8. Notice</h4><ul>
<li>域名解析需要一定的时间才能在全球生效，设置完域名解析之后请稍后哦</li>
<li>文中的username和example需要替换成你自己的项目和域名</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>目前，github下pelican搭建的极简主义的博客越来越受到大家的欢迎，本文介绍在github中一个仓库同时保存Markdown博客主内容和HTML网页，并绑定域名。 我们将markdown文件保存在仓库的master分支中，将HTML网页保存在gh-pages分支中，]]>
    </summary>
    
      <category term="github, pages, blog, 域名" scheme="http://yoursite.com/tags/github-pages-blog-%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yoursite.com/2014/01/01/Hello-World/"/>
    <id>http://yoursite.com/2014/01/01/Hello-World/</id>
    <published>2014-01-01T05:51:28.000Z</published>
    <updated>2015-09-03T02:00:23.000Z</updated>
    <content type="html"><![CDATA[<p>从现在开始, 多写点东西吧!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从现在开始, 多写点东西吧!</p>
]]>
    </summary>
    
      <category term="开始" scheme="http://yoursite.com/tags/%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
</feed>
