<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Frank]]></title>
  <subtitle><![CDATA[Li Jingpeng's site]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.notehub.cn/"/>
  <updated>2015-11-18T06:01:26.000Z</updated>
  <id>http://www.notehub.cn/</id>
  
  <author>
    <name><![CDATA[Li Jingpeng]]></name>
    <email><![CDATA[me@lijingpeng.org]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于前端]]></title>
    <link href="http://www.notehub.cn/2015/11/18/dev/web/ui_base/"/>
    <id>http://www.notehub.cn/2015/11/18/dev/web/ui_base/</id>
    <published>2015-11-18T05:20:56.000Z</published>
    <updated>2015-11-18T06:01:26.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li>Autocomplete<br><a href="http://jqueryui.com/autocomplete" target="_blank" rel="external">http://jqueryui.com/autocomplete</a> 支持中文有问题</li>
<li>jsTree<br><a href="https://www.jstree.com/plugins/" target="_blank" rel="external">https://www.jstree.com/plugins/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li>Autocomplete<br><a href="http://jqueryui.com/autocomplete" target="_blank" rel="external">http://jqueryui.com/autocomplete</a> 支持中文]]>
    </summary>
    
      <category term="前端" scheme="http://www.notehub.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web" scheme="http://www.notehub.cn/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python CGI-BIN]]></title>
    <link href="http://www.notehub.cn/2015/11/18/dev/web/python_cgi_bin/"/>
    <id>http://www.notehub.cn/2015/11/18/dev/web/python_cgi_bin/</id>
    <published>2015-11-18T05:19:56.000Z</published>
    <updated>2015-11-18T06:06:30.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseHTTPServer</span><br><span class="line"><span class="keyword">import</span> CGIHTTPServer</span><br><span class="line"><span class="keyword">import</span> cgitb; cgitb.enable()  <span class="comment">## This line enables CGI error reporting</span></span><br><span class="line"></span><br><span class="line">server = BaseHTTPServer.HTTPServer</span><br><span class="line">handler = CGIHTTPServer.CGIHTTPRequestHandler</span><br><span class="line">server_address = (<span class="string">"0.0.0.0"</span>, <span class="number">8082</span>)</span><br><span class="line">handler.cgi_directories = [<span class="string">"/cgi-bin"</span>]</span><br><span class="line"></span><br><span class="line">httpd = server(server_address, handler)</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>CGI-BIN下的py文件要有执行权限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">form = cgi.FieldStorage()</span><br><span class="line"></span><br><span class="line">query_str = form.getvalue(<span class="string">'query'</span>)</span><br><span class="line">query = <span class="string">"http://0.0.0.0:9999/query?query=%s"</span> % query_str</span><br><span class="line"></span><br><span class="line">exec_query = urllib.urlopen(query)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Status: 200 OK"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Content-Type: application/json"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">""</span></span><br><span class="line"><span class="keyword">print</span> exec_query.read()</span><br></pre></td></tr></table></figure>
<p>HTML:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"content-type"</span> <span class="attribute">content</span>=<span class="value">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"></span><br><span class="line">            $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">            </span>&#123;</span><br><span class="line">                $(<span class="string">'#clickme'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    alert(<span class="string">'Im going to start processing'</span>);</span><br><span class="line"></span><br><span class="line">                    $.ajax(&#123;</span><br><span class="line">                        url: <span class="string">"/scripts/ajaxpost.py"</span>,</span><br><span class="line">                        type: <span class="string">"post"</span>,</span><br><span class="line">                        datatype:<span class="string">"json"</span>,</span><br><span class="line">                        data: &#123;<span class="string">'key'</span>:<span class="string">'value'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;,</span><br><span class="line">                        success: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                            alert(response.message);</span><br><span class="line">                            alert(response.keys);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">button</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span> click me <span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>参考： </p>
<ul>
<li><a href="https://pointlessprogramming.wordpress.com/2011/02/13/python-cgi-tutorial-2/" target="_blank" rel="external">https://pointlessprogramming.wordpress.com/2011/02/13/python-cgi-tutorial-2/</a></li>
<li><a href="http://www.runoob.com/python/python-cgi.html" target="_blank" rel="external">http://www.runoob.com/python/python-cgi.html</a></li>
<li><a href="http://stackoverflow.com/questions/10721244/ajax-posting-to-python-cgi" target="_blank" rel="external">http://stackoverflow.com/questions/10721244/ajax-posting-to-python-cgi</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span clas]]>
    </summary>
    
      <category term="python" scheme="http://www.notehub.cn/tags/python/"/>
    
      <category term="web" scheme="http://www.notehub.cn/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python HTTP server]]></title>
    <link href="http://www.notehub.cn/2015/11/18/dev/web/python_http_server/"/>
    <id>http://www.notehub.cn/2015/11/18/dev/web/python_http_server/</id>
    <published>2015-11-18T05:19:56.000Z</published>
    <updated>2015-11-18T06:04:19.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>HTTP GET</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        parsed_path = urlparse.urlparse(self.path)</span><br><span class="line">        message_parts = [</span><br><span class="line">                <span class="string">'CLIENT VALUES:'</span>,</span><br><span class="line">                <span class="string">'client_address=%s (%s)'</span> % (self.client_address,</span><br><span class="line">                                            self.address_string()),</span><br><span class="line">                <span class="string">'command=%s'</span> % self.command,</span><br><span class="line">                <span class="string">'path=%s'</span> % self.path,</span><br><span class="line">                <span class="string">'real path=%s'</span> % parsed_path.path,</span><br><span class="line">                <span class="string">'query=%s'</span> % parsed_path.query,</span><br><span class="line">                <span class="string">'request_version=%s'</span> % self.request_version,</span><br><span class="line">                <span class="string">''</span>,</span><br><span class="line">                <span class="string">'SERVER VALUES:'</span>,</span><br><span class="line">                <span class="string">'server_version=%s'</span> % self.server_version,</span><br><span class="line">                <span class="string">'sys_version=%s'</span> % self.sys_version,</span><br><span class="line">                <span class="string">'protocol_version=%s'</span> % self.protocol_version,</span><br><span class="line">                <span class="string">''</span>,</span><br><span class="line">                <span class="string">'HEADERS RECEIVED:'</span>,</span><br><span class="line">                ]</span><br><span class="line">        <span class="keyword">for</span> name, value <span class="keyword">in</span> sorted(self.headers.items()):</span><br><span class="line">            message_parts.append(<span class="string">'%s=%s'</span> % (name, value.rstrip()))</span><br><span class="line">        message_parts.append(<span class="string">''</span>)</span><br><span class="line">        message = <span class="string">'\r\n'</span>.join(message_parts)</span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(message)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer</span><br><span class="line">    server = HTTPServer((<span class="string">'localhost'</span>, <span class="number">8080</span>), GetHandler)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Starting server, use &lt;Ctrl-C&gt; to stop'</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP POST</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Parse the form data posted</span></span><br><span class="line">        form = cgi.FieldStorage(</span><br><span class="line">            fp=self.rfile, </span><br><span class="line">            headers=self.headers,</span><br><span class="line">            environ=&#123;<span class="string">'REQUEST_METHOD'</span>:<span class="string">'POST'</span>,</span><br><span class="line">                     <span class="string">'CONTENT_TYPE'</span>:self.headers[<span class="string">'Content-Type'</span>],</span><br><span class="line">                     &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Begin the response</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(<span class="string">'Client: %s\n'</span> % str(self.client_address))</span><br><span class="line">        self.wfile.write(<span class="string">'User-agent: %s\n'</span> % str(self.headers[<span class="string">'user-agent'</span>]))</span><br><span class="line">        self.wfile.write(<span class="string">'Path: %s\n'</span> % self.path)</span><br><span class="line">        self.wfile.write(<span class="string">'Form data:\n'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Echo back information about what was posted in the form</span></span><br><span class="line">        <span class="keyword">for</span> field <span class="keyword">in</span> form.keys():</span><br><span class="line">            field_item = form[field]</span><br><span class="line">            <span class="keyword">if</span> field_item.filename:</span><br><span class="line">                <span class="comment"># The field contains an uploaded file</span></span><br><span class="line">                file_data = field_item.file.read()</span><br><span class="line">                file_len = len(file_data)</span><br><span class="line">                <span class="keyword">del</span> file_data</span><br><span class="line">                self.wfile.write(<span class="string">'\tUploaded %s as "%s" (%d bytes)\n'</span> % \</span><br><span class="line">                        (field, field_item.filename, file_len))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Regular form value</span></span><br><span class="line">                self.wfile.write(<span class="string">'\t%s=%s\n'</span> % (field, form[field].value))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer</span><br><span class="line">    server = HTTPServer((<span class="string">'localhost'</span>, <span class="number">8080</span>), PostHandler)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Starting server, use &lt;Ctrl-C&gt; to stop'</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
</li>
<li><p>Threading and Forking</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> BaseHTTPServer <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"><span class="keyword">from</span> SocketServer <span class="keyword">import</span> ThreadingMixIn</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        message =  threading.currentThread().getName()</span><br><span class="line">        self.wfile.write(message)</span><br><span class="line">        self.wfile.write(<span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedHTTPServer</span><span class="params">(ThreadingMixIn, HTTPServer)</span>:</span></span><br><span class="line">    <span class="string">"""Handle requests in a separate thread."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = ThreadedHTTPServer((<span class="string">'localhost'</span>, <span class="number">8080</span>), Handler)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Starting server, use &lt;Ctrl-C&gt; to stop'</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>From: <a href="https://pymotw.com/2/BaseHTTPServer/" target="_blank" rel="external">https://pymotw.com/2/BaseHTTPServer/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>HTTP GET</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="lin]]>
    </summary>
    
      <category term="python" scheme="http://www.notehub.cn/tags/python/"/>
    
      <category term="web" scheme="http://www.notehub.cn/categories/web/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ string实现加减乘除]]></title>
    <link href="http://www.notehub.cn/2015/11/15/dev/CPP/cpp_big_number/"/>
    <id>http://www.notehub.cn/2015/11/15/dev/CPP/cpp_big_number/</id>
    <published>2015-11-15T12:19:56.000Z</published>
    <updated>2015-11-15T14:24:15.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compare比较函数：相等返回0，大于返回1，小于返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str1.length()&gt;str2.length()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str1.length()&lt;str2.length())  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> str1.compare(str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高精度加法</span></span><br><span class="line"><span class="comment">//只能是两个正数相加</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//高精度加法</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len1=str1.length();</span><br><span class="line">    <span class="keyword">int</span> len2=str2.length();</span><br><span class="line">    <span class="comment">//前面补0，弄成长度相同</span></span><br><span class="line">    <span class="keyword">if</span>(len1&lt;len2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len2-len1;i++)</span><br><span class="line">           str1=<span class="string">"0"</span>+str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1-len2;i++)</span><br><span class="line">           str2=<span class="string">"0"</span>+str2;</span><br><span class="line">    &#125;</span><br><span class="line">    len1=str1.length();</span><br><span class="line">    <span class="keyword">int</span> cf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len1-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=str1[i]-<span class="string">'0'</span>+str2[i]-<span class="string">'0'</span>+cf;</span><br><span class="line">        cf=temp/<span class="number">10</span>;</span><br><span class="line">        temp%=<span class="number">10</span>;</span><br><span class="line">        str=<span class="keyword">char</span>(temp+<span class="string">'0'</span>)+str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cf!=<span class="number">0</span>)  str=<span class="keyword">char</span>(cf+<span class="string">'0'</span>)+str;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="comment">//只能是两个正数相减，而且要大减小</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sub</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span><span class="comment">//高精度减法</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> tmp=str1.length()-str2.length();</span><br><span class="line">    <span class="keyword">int</span> cf=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=str2.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[tmp+i]&lt;str2[i]+cf)</span><br><span class="line">        &#123;</span><br><span class="line">            str=<span class="keyword">char</span>(str1[tmp+i]-str2[i]-cf+<span class="string">'0'</span>+<span class="number">10</span>)+str;</span><br><span class="line">            cf=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str=<span class="keyword">char</span>(str1[tmp+i]-str2[i]-cf+<span class="string">'0'</span>)+str;</span><br><span class="line">            cf=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=tmp-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i]-cf&gt;=<span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str=<span class="keyword">char</span>(str1[i]-cf)+str;</span><br><span class="line">            cf=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str=<span class="keyword">char</span>(str1[i]-cf+<span class="number">10</span>)+str;</span><br><span class="line">            cf=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    str.erase(<span class="number">0</span>,str.find_first_not_of(<span class="string">'0'</span>));<span class="comment">//去除结果中多余的前导0</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//高精度乘法</span></span><br><span class="line"><span class="comment">//只能是两个正数相乘</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">mul</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> len1=str1.length();</span><br><span class="line">    <span class="keyword">int</span> len2=str2.length();</span><br><span class="line">    <span class="built_in">string</span> tempstr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len2-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        tempstr=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=str2[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cf=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2-<span class="number">1</span>-i;j++)</span><br><span class="line">              tempstr+=<span class="string">"0"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len1-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                t=(temp*(str1[j]-<span class="string">'0'</span>)+cf)%<span class="number">10</span>;</span><br><span class="line">                cf=(temp*(str1[j]-<span class="string">'0'</span>)+cf)/<span class="number">10</span>;</span><br><span class="line">                tempstr=<span class="keyword">char</span>(t+<span class="string">'0'</span>)+tempstr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cf!=<span class="number">0</span>) tempstr=<span class="keyword">char</span>(cf+<span class="string">'0'</span>)+tempstr;</span><br><span class="line">        &#125;</span><br><span class="line">        str=add(str,tempstr);</span><br><span class="line">    &#125;</span><br><span class="line">    str.erase(<span class="number">0</span>,str.find_first_not_of(<span class="string">'0'</span>));</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度除法</span></span><br><span class="line"><span class="comment">//两个正数相除，商为quotient,余数为residue</span></span><br><span class="line"><span class="comment">//需要高精度减法和乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">div</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2,<span class="built_in">string</span> &amp;quotient,<span class="built_in">string</span> &amp;residue)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    quotient=residue=<span class="string">""</span>;<span class="comment">//清空</span></span><br><span class="line">    <span class="keyword">if</span>(str2==<span class="string">"0"</span>)<span class="comment">//判断除数是否为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        quotient=residue=<span class="string">"ERROR"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str1==<span class="string">"0"</span>)<span class="comment">//判断被除数是否为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        quotient=residue=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=compare(str1,str2);</span><br><span class="line">    <span class="keyword">if</span>(res&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        quotient=<span class="string">"0"</span>;</span><br><span class="line">        residue=str1;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(res==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        quotient=<span class="string">"1"</span>;</span><br><span class="line">        residue=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len1=str1.length();</span><br><span class="line">        <span class="keyword">int</span> len2=str2.length();</span><br><span class="line">        <span class="built_in">string</span> tempstr;</span><br><span class="line">        tempstr.append(str1,<span class="number">0</span>,len2-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len2-<span class="number">1</span>;i&lt;len1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempstr=tempstr+str1[i];</span><br><span class="line">            tempstr.erase(<span class="number">0</span>,tempstr.find_first_not_of(<span class="string">'0'</span>));</span><br><span class="line">            <span class="keyword">if</span>(tempstr.empty())</span><br><span class="line">              tempstr=<span class="string">"0"</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch=<span class="string">'9'</span>;ch&gt;=<span class="string">'0'</span>;ch--)<span class="comment">//试商</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> str,tmp;</span><br><span class="line">                str=str+ch;</span><br><span class="line">                tmp=mul(str2,str);</span><br><span class="line">                <span class="keyword">if</span>(compare(tmp,tempstr)&lt;=<span class="number">0</span>)<span class="comment">//试商成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                    quotient=quotient+ch;</span><br><span class="line">                    tempstr=sub(tempstr,tmp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        residue=tempstr;</span><br><span class="line">    &#125;</span><br><span class="line">    quotient.erase(<span class="number">0</span>,quotient.find_first_not_of(<span class="string">'0'</span>));</span><br><span class="line">    <span class="keyword">if</span>(quotient.empty()) quotient=<span class="string">"0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="built_in">string</span> str1,str2;</span><br><span class="line">     <span class="built_in">string</span> str3,str4;</span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;str1&gt;&gt;str2)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;add(str1,str2)&lt;&lt;endl;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;sub(str1,str2)&lt;&lt;endl;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;mul(str1,str2)&lt;&lt;endl;</span><br><span class="line">         div(str1,str2,str3,str4);</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;str3&lt;&lt;<span class="string">"  "</span>&lt;&lt;str4&lt;&lt;endl;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>From: <a href="http://www.cnblogs.com/kuangbin/archive/2012/08/11/2634044.html" target="_blank" rel="external">http://www.cnblogs.com/kuangbin/archive/2012/08/11/2634044.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跳过视频广告好爽，殊不知被狠狠地「算计」了]]></title>
    <link href="http://www.notehub.cn/2015/10/29/ads/skip_the_ad/"/>
    <id>http://www.notehub.cn/2015/10/29/ads/skip_the_ad/</id>
    <published>2015-10-29T03:36:46.000Z</published>
    <updated>2015-10-29T03:36:46.000Z</updated>
    <content type="html"><![CDATA[<p>YouTube 视频的广告为什么可以跳过？对广告商的负面影响大吗？</p>
<p>许多人都从用户角度讲，Youtube 的这种方式用户体验多么多么好，作为相关从业人员，我觉得你们真是太看得起资本家了。Google 请了这么多这么贵的码农来开发这种产品，广告主愿意用这种方式投放广告，一定都是真心为了钱的……</p>
<p>就从这句话开始说吧。</p>
<p>如果不是一看就特有趣的广告，我都会选择跳过……这无疑是广告商最不愿看到的情景吧。美国的广告行业有一句著名的话是「我在广告上的投资有一半是被浪费了的，但是问题是我不知道是哪一半。」</p>
<p>所以才有了广告测量这个子行业。</p>
<p>从互联网视频这个分支来讲，一般的广告效果追踪主要靠网站播放器的 impression callback。简单说来就是说你在看视频广告的时候，播放器会不断向服务器端汇报你的观看进展的。同时视频网站也是依照这个数据找广告主收钱的，也就是著名的 CPM（千次观看成本）模型。 </p>
<p>问题在于：播放器实际上只能汇报「播放进展」，而不是「观看进展」。</p>
<p>这也是为什么在视频广告行业还有所谓的「First in Pod」的概念的原因，因为广告商也不傻，他们也知道一场足球比赛，中场休息放广告的时候，你们一定去上厕所开啤酒叫烤串儿去了。所以只有进广告后第一个广告可能被更多人看到，因此这种广告往往比中间的卖得要贵得多。</p>
<p>因此 Youtube 的这种可以跳过的广告（ 正式名字叫做 TrueView），其实不是给你一个跳过广告的机会，而是让他们获得一个与你互动的机会。如果说真的是为了用户体验，那么他们就应该在广告的第一秒就直接允许你跳过广告。</p>
<p>因为你知道 5 秒之后就能马上进入视频，所以这 5 秒你一定会盯着屏幕，甚至把鼠标预先挪到那个倒数框里。 </p>
<p>这算是 TrueView 的第一个优点：精准测量，保证你真的在看。</p>
<p>至于能不能吸引你继续看下去，那就是广告制作公司的本事了。</p>
<p>而你说你跳过广告是广告商不愿意看到的事情，其实真不是，广告商乐坏了，因为他们不用付钱向一个对他们的产品不感兴趣的人推销了。这就好比著名的浏览器插件 AdBlock Plus， 广告商对它几乎都是持欢迎态度的，因为会用这个插件的用户，往往都是获取难度较高的客户，你把它们的广告屏蔽了，他们也省得为一个无谓的展示付钱。而且相反，因为给予了观看者跳过的权利，如果这条广告最后居然播完了，那么很大可能是你是对这个广告的内容感兴趣的，换句话说，是广告主的潜在客户。 </p>
<p>所以这是 TrueView 的第二个优点：精准投放。</p>
<p>最后，我们才说到用户体验，如果说良好的用户体验实际上是 TrueView 的副产物的话，那么这个副产物也不是完全没有价值的，因为广告的性质其实大体可以分两类：</p>
<p>一类是 Selling，例如网上小视频里弹出一个广告说，现在来买大众汽车，分期免利息，还有折扣，blabla</p>
<p>一类是 Branding，就好比几年前超级碗决赛上大众汽车做的无厘头的星战系列宣传片，不卖产品，就告诉你我高大上买得起超级碗的广告</p>
<p>越是大公司大品牌，可能在 Branding 上花的钱就越多，但同时他们对于广告投放的体验要求也就更高，因为这个广告创意要传递给你的一定是关于他们品牌的正面印象，所以说这种广告往往是大手笔的投入，例如宝马找 Clive Owen 拍的一系列小电影。这种情况下，如果你的网站用户体验非常差，那么在你这里投放只能是浪费广告商的创意花费了。</p>
<p>因此，TrueView 的第三个优点是：保证了良好的用户体验，因而可以吸引更大的客户来进行投放。</p>
<p>因为有了上述三个优点，以及对大客户友好的特性，TrueView 的广告本身就具有了对于Youtube 盈利来说特别有利的特质：</p>
<ul>
<li>CPM 高， 能吸引更有钱的金主，适应更多不同的广告需求</li>
<li>广告创意自由度更大， 其中第三点我是见过实例的，曾经我看过一个长达十分钟的 TrueView 广告，本身就是一个小电影，因为制作的精良，我不但看完了，而且还特地去搜索单独播放的地址。如果不是 TrueView，一个十分钟的广告简直是不可接受的。</li>
</ul>
<p>综上所述，我觉得 TrueView 是一个非常精妙的设计。基本上在「广告是视频网站盈利的根基」这一前提下，倚靠提供精准的投放和良好的体验，做到了广告主、网站和用户的三赢。 </p>
<p>当然，我认为 Youtube 依托 Google，对于互联网用户的兴趣爱好甚至年龄性别特征都有非常多的了解， 因而能够智能地选取广告内容，一定程度上保证 TrueView 观看率的，才有信心敢推出这类型的产品。</p>
<p>那说回来，为什么国内视频网站为什么不能也这样做？我猜是可以。但是：</p>
<ul>
<li>国内用户被盗版滋养了那么多年，对于免费产品 + 第三方补偿的接受能力比较弱</li>
<li>国内的视频网站在用户追踪和人群分析上做得不够成熟，不能够保证投放出去的广告一定是用户感兴趣的</li>
</ul>
<p>最终导致使用类似的模式不能保证收益，倒不如用垃圾广告直接强奸用户广种薄收了……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>YouTube 视频的广告为什么可以跳过？对广告商的负面影响大吗？</p>
<p>许多人都从用户角度讲，Youtube 的这种方式用户体验多么多么好，作为相关从业人员，我觉得你们真是太看得起资本家了。Google 请了这么多这么贵的码农来开发这种产品，广告主愿意用这种方式投]]>
    </summary>
    
      <category term="ads" scheme="http://www.notehub.cn/categories/ads/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Granger causality]]></title>
    <link href="http://www.notehub.cn/2015/10/28/algo/granger_causality/"/>
    <id>http://www.notehub.cn/2015/10/28/algo/granger_causality/</id>
    <published>2015-10-28T02:23:16.000Z</published>
    <updated>2015-10-28T02:23:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Granger_causality">Granger causality</h3><hr>
<p>如果一个变量X无助于预测另一个变量Y，则说X不是Y的原因；相反，若X是Y的原因，则必须满足两个条件：第一，X应该有助于预测Y，即在Y关于Y的过去值的回归中，添加X的过去值作为独立变量应当显著地增加回归的解释能力；第二，Y不应当有助于预测X，其原因是，如果X有助于预测Y，Y也有助于预测X，则很可能存在一个或几个其他变量，它们既是引起X变化的原因，也是引起Y变化的原因。</p>
<h3 id="Granger因果关系检验">Granger因果关系检验</h3><hr>
<p><img src="/images/gc1.png" alt=""><br><img src="/images/gc2.png" alt=""><br><img src="/images/gc3.png" alt=""></p>
<h3 id="关于鸡生蛋还是蛋生鸡">关于鸡生蛋还是蛋生鸡</h3><hr>
<p>鸡生蛋还是蛋生鸡？对于原因与结果的区分，自古以来是个难题。1926年，挪威经济学家、第一届（1969年）诺贝尔经济学奖得主弗瑞希（R . Frisch）仿照“生物计量学”（Biometrics）一词提出了“计量经济学”或“经济计量学”（Econometrics）之名。有趣的是，两位经济学家Walter N. Thurman和Mark E. Fisher又将计量经济学的方法用于讨论生物学领域的问题（当然也可以算是经济问题，因为研究结果发表杂经济学杂志上），探讨了这个“鸡与蛋”的关系问题。见“Chicken，eggs，and causality，or which came first?”, American Journal of Agricultural Economics, pp237-238, May 1988”。</p>
<p>他们用1930-1983期间美国鸡蛋产量和美国同期鸡产量的时间序列数据，建立滞后回归模型（1-4年），然后做格兰杰因果关系检验。结果能够拒绝鸡蛋不是鸡出现原因的原假设，同时不能拒绝鸡不是鸡蛋出现的原因的原假设（只有在检验出单向因果关系后，检验才是有效的）。也就是是说鸡生蛋的假设被拒绝，而蛋生鸡的假设成立，因此，蛋为因，鸡为果。因此，他们得出先有蛋的结论。他们建议作其他诸如“最后笑者笑得最好”（He who laughs last laughs best）、“骄傲是失败之母”（Pride goeth before destruction, and an haughty spirit before a fall）之类的格兰杰因果检验。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(lmtest) </span><br><span class="line"></span><br><span class="line">data(ChickEgg)</span><br><span class="line">grangertest(egg ~ chicken, order = <span class="number">4</span>, data = ChickEgg)</span><br><span class="line">grangertest(chicken ~ egg, order = <span class="number">4</span>, data = ChickEgg)</span><br></pre></td></tr></table></figure>
<p>结果:<br>Granger causality test<br>Model 1: egg ~ Lags(egg, 1:4) + Lags(chicken, 1:4)<br>Model 2: egg ~ Lags(egg, 1:4)<br>  Res.Df Df      F Pr(&gt;F)<br>1     41<br>2     45 -4 0.3929 0.8125<br>我们的假设是『鸡不是蛋的原因』， egg ~ Lags(egg, 1:4) + Lags(chicken, 1:4)， 拒绝该假设犯错的概率是0.8125， 因此我们不可以拒绝该假设， 也就是『鸡不是蛋的原因』成立</p>
<p>Granger causality test<br>Model 1: chicken ~ Lags(chicken, 1:4) + Lags(egg, 1:4)<br>Model 2: chicken ~ Lags(chicken, 1:4)<br>  Res.Df Df      F   Pr(&gt;F)<br>1     41<br>2     45 -4 4.2568 0.005671 **</p>
<p>我们的假设是『蛋不是鸡的原因』， chicken ~ Lags(chicken, 1:4) + Lags(egg, 1:4)， 拒绝该假设犯错的概率是0.005671， 因此我们可以拒绝该假设， 也就是蛋-&gt;鸡是成立的</p>
<p>他们所使用的分析变量之间的因果的办法，即格兰杰因果关系检验。该检验方法为2003年诺贝尔经济学奖得主克莱夫·格兰杰（Clive W. J. Granger）所开创。从统计的角度，因果关系是通过概率或者分布函数的角度体现出来的：在宇宙中所有其它事件的发生情况固定不变的条件下，如果一个事件A的发生与不发生对于另一个事件B的发生的概率（如果通过事件定义了随机变量那么也可以说分布函数）有影响，并且这两个事件在时间上又先后顺序（A前B后），那么我们便可以说A是B的原因。Granger从预测的角度给出了因果性的一个定义：如果x有助于预测(解释)y，则x是y的Granger原因。将x的信息从信息集中去除不会改变对y的最优预测,则x不是y的granger原因。相反，会改变预测，则x是y的Granger原因，即将过去的x包含在信息集中可提高对y的预测。格兰杰因果检验只是数据上的因果关系不代表实际的因果关系。</p>
<p>格兰杰因果关系检验的基本思路是，在两个变量x和y的系统中，若y的现在值用x和y的过去值预测要好于单独用y预测，那么，称x是y的原因；若用x的现在值和x、y的过去值去预测y比只用x和y去预测要好，那么，称x是y的瞬时原因。反之反是。换言之，如果x的变化引起y的变化，则x的变化应当发生在y的变化之前。特别地，说“x是引起y变化的原因”，则必须满足两个条件：一是x应该有助于预测y，即在y关于y的过去值的回归分析中，添加x的过去值作为独立变量应当显著地增加回归的解释能力；二是y不应当有助于预测x，其原因是如果x有助于预测y，y也有助于预测x，则很可能存在一个或几个其它的变量，它们既是引起x变化的原因，也是引起y变化的原因。</p>
<p>进行格兰杰因果关系检验的一个前提条件是时间序列必须具有平稳性，否则可能会出现虚假回归问题。因此在进行格兰杰因果关系检验之前首先应对各指标时间序列的平稳性进行单位根检验(unit  root  test)。常用增广的迪基—富勒检验(ADF检验)来分别对各指标序列的平稳性进行单位根检验。格兰杰检验的特点决定了它只能适用于时间序列数据模型的因果性检验，无法检验只有横截面数据时变量间的因果性。因此，在使用这种方法时，务必检查前提条件，使其尽量能够满足。</p>
<p>时间序列的稳定性是指时间序列的方差、协方差、均值不受时间t的影响。平稳性就是要求经由样本时间序列所得到的拟合曲线在未来的一段期间内仍能顺着现有的形态“惯性”地延续下去；如果数据非平稳，则说明样本拟合曲线的形态不具有“惯性”延续的特点，也就是基于未来将要获得的样本时间序列所拟合出来的曲线将迥异于当前的样本拟合曲线。</p>
<p>由于格兰杰天才地利用了条件概率来定义因果关系，所以他的方法显得既实用又有效，这是个令许多人甚至哲学家都佩服的思维上的突破。但是格兰杰因果关系检验的结论只是统计意义上的因果性，而不一定是真正的因果关系。虽然可以作为真正的因果关系的一种支持，但不能作为肯定或否定因果关系的最终根据。也许，鸡和蛋之间没有必要讨论谁先谁后的问题，因为在足够长的时间里，不存在单向的因果关系，或者说只是存在互为因果关系。运用统计工具来解释经济变量之间的关系，仍有很多的漏洞，存在很多逻辑上的问题。“鸡生蛋还是蛋生鸡”的命题告诉我们，在许多情况下，探讨因果关系是没有意义的。</p>
<p>真正的因果关系，还是要立足于理论模型的思考。统计方法并非万能的，评判一个对象，往往需要多种角度的观察。正所谓“兼听则明，偏听则暗”。诚然真相永远只有一个，但是也要靠科学的探索方法。当然，我们也不能因噎废食，全盘否定计量统计的意义。即使格兰杰因果关系不等于实际因果关系，也并不妨碍其参考价值。因为统计意义上的因果关系也是有意义的，对于经济预测等仍然能起很大的作用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Granger_causality">Granger causality</h3><hr>
<p>如果一个变量X无助于预测另一个变量Y，则说X不是Y的原因；相反，若X是Y的原因，则必须满足两个条件：第一，X应该有助于预测Y，即在Y关于Y的过去值的回归中，添加X的过]]>
    </summary>
    
      <category term="Granger causality" scheme="http://www.notehub.cn/tags/Granger-causality/"/>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++智能指针(Smart Pointer)]]></title>
    <link href="http://www.notehub.cn/2015/10/27/dev/CPP/cpp_smart_pointer/"/>
    <id>http://www.notehub.cn/2015/10/27/dev/CPP/cpp_smart_pointer/</id>
    <published>2015-10-27T12:47:00.000Z</published>
    <updated>2015-10-27T12:57:13.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_传统指针存在的问题">1. 传统指针存在的问题</h3><hr>
<p>传统指针存在诸多的问题，比如指针所指向的对象的生命周期问题，挂起引用(dangling references)，以及内存泄露(memory leaks). 如下是一个传统指针的使用过程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *iPtr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// manipulate the memory block</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">delete</span>[] iPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码将正常运行且内存将被合理释放，但是使用指针常会发生一些意想不到的事情，比如访问一个非法的内存单元，除0操作，以及根据一些判断条件处理的返回return 语句。</p>
<h3 id="2-_什么是智能指针(Smart_Pointer)">2. 什么是智能指针(Smart Pointer)</h3><hr>
<p>智能指针是RAII（Resource Acquisition is initialization）用来动态的分配内存。它提供了普通指针的所有接口外加少数异常处理。在构造阶段，它将分配内存，而在非其作用域内将自动释放所占有的内存。 </p>
<p>在C++98中，使用 auto_ptr来解决上述问题。</p>
<h4 id="2-1_auto_ptr">2.1 auto_ptr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a = <span class="number">0</span>) : m_a(a) &#123;&#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling destructor"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;Test&gt; p(<span class="keyword">new</span> Test(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;m_a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果： </p>
<p><img src="/images/cpp/sp1.jpg" alt=""></p>
<p>上述代码将智能的释放相关的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a = <span class="number">0</span>) : m_a(a) &#123;&#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling destructor"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">5</span>, c;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">"Invalid divisor"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = b / a;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;Test&gt; p(<span class="keyword">new</span> Test(<span class="number">5</span>));</span><br><span class="line">        Fun();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;m_a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Something has gone wrong"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，即使异常抛出，指针照样被正常释放。这是因为当异常抛出时，栈松绑(stack unwinding)。 当所有属于try block的本地对象被销毁时，指针p不在作用域中而被释放。</p>
<h5 id="问题1-">问题1.</h5><p>至少从目前来说auto_ptr是智能的。但是它有一个非常本质的缺点：auto_ptr会传递它本身的ownership当其被赋值给另一个auto_ptr对象。正如下述程序所示，一个auto_ptr对象传递给函数Fun()中的auto_ptr对象时，其ownership,或者说是smartness将不再返回给原auto_ptr所指向的p。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a = <span class="number">0</span>) : m_a(a) &#123;&#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling destructor"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;Test&gt; p1)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1-&gt;m_a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Fun() end"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;Test&gt; p(<span class="keyword">new</span> Test(<span class="number">5</span>));</span><br><span class="line">    Fun(p);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果： </p>
<p><img src="/images/cpp/sp2.jpg" alt=""></p>
<p>以上程序将crash因为存在野指针auto_ptr。上述代码奔溃的主要原因是，原先的p占有对其自身分配内存的管理权。然而通过Fun()函数将其管理权转给p1，此时因为p1的smartness，在其结束时将释放其所指向的内存块。而此时原先的p将再拥有任何内存，而导致在访问时出现了空指针，野指针的引用问题。</p>
<h5 id="问题2-">问题2.</h5><p>auto_ptr不能使用于数组对象。 这里的意思是不能使用于操作符new[]。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;Test&gt; p(<span class="keyword">new</span> Test[<span class="number">5</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将runtime error。因为对于auto_ptr而言，其调用的是delete而非delete []。</p>
<h5 id="问题3-">问题3.</h5><p>auto_ptr不能使用于一些标准的容器库。比如vector，list，map等等。</p>
<p>C++11提出了新型的智能指针，并且都赋予了其相应的意图。</p>
<h4 id="2-2_shared_ptr">2.2 shared_ptr</h4><p>creation :<br>shared_ptr设计的目的很简单：多个共享指针可以指向同一个对象，而当最后一个共享指针在作用域范围内结束时，内存才会被自动的释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// share_ptr 常规的创建过程</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr1( <span class="keyword">new</span> <span class="keyword">int</span> );</span><br><span class="line">    <span class="comment">// 使用make_shared 来加速创建过程</span></span><br><span class="line">    <span class="comment">// shared_ptr 自动分配内存，并且保证引用计数</span></span><br><span class="line">    <span class="comment">// 而make_shared则是按照这种方法来初始化</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr2 = make_shared&lt;<span class="keyword">int</span>&gt;( <span class="number">100</span> );</span><br><span class="line">    <span class="comment">// 可以通过use_count() 来查看引用计数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sptr2 referenced count: "</span> &lt;&lt; sptr2.use_count() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr3 = sptr2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sptr2 referenced count: "</span> &lt;&lt; sptr2.use_count() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*sptr2 = "</span> &lt;&lt; *sptr2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/cpp/sp3.jpg" alt=""></p>
<p>上述代码创建了一个shared_ptr指针指向了一个装着整型值且值为100的内存块，并且引用计数为1,。当其他共享指针通过sptr1来创建时，引用计数将为2。这种引用称为强引用strong reference。除此之外，还有弱引用weak reference。可以通过</p>
<p>destruction ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a = <span class="number">0</span>) : m_a(a) &#123;&#125;</span><br><span class="line">    ~Test() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling destructor"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果用以下形式，则只会调用delete，则不会调用</span></span><br><span class="line">    <span class="comment">// delete[ ]; 此时只会调用一次析构函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Test&gt; sptr1(<span class="keyword">new</span> Test[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采用以下形式，lambda表达式，显示调用</span></span><br><span class="line">    <span class="comment">// delete[] 来删除所有的对象。</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Test&gt; sptr2(<span class="keyword">new</span> Test[<span class="number">5</span>],</span><br><span class="line">                           [](Test* p) &#123;<span class="keyword">delete</span>[] p;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用户可以显式的调用函数，lambda表达式，函数对象来调用对于shared_ptr为数组对象的析构函数delete[]。</p>
<h5 id="Interface（接口）">Interface（接口）</h5><p>shared_ptr提供解引用*， 以及-&gt;来普通指针的相关操作。同时，还提供了以下的接口:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- get()： To get the resource associated with the <span class="built_in">shared_ptr</span>.</span><br><span class="line">- reset()： To yield the ownership of the associated memory block. If <span class="keyword">this</span> is the last shared_ptrowning the resource, then the resource is released automatically.</span><br><span class="line">- unique: To know whether the resource is managed by only <span class="keyword">this</span> <span class="built_in">shared_ptr</span> instance.</span><br><span class="line">- <span class="keyword">operator</span> <span class="keyword">bool</span>: To check whether the <span class="built_in">shared_ptr</span> owns a memory block or not. Can be used with an <span class="keyword">if</span> condition.</span><br></pre></td></tr></table></figure>
<h4 id="Issue（问题）">Issue（问题）</h4><ul>
<li>当一个内存块与shared_ptr绑定相关，并且属于不同组时，将会发生错误。所有的shared_ptr共享一个组的同一个共享引用。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr1(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr2 = sptr1;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr3;</span><br><span class="line">    sptr3 = sptr2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下表格给出了相应的引用计数 </p>
<p><img src="/images/cpp/sp4.jpg" alt=""></p>
<p>以上代码运行正常。<br>然而当使用以下代码时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr1(p);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr2(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用计数表如下： </p>
<p><img src="/images/cpp/sp5.jpg" alt=""></p>
<p>为了避免这种情况的发生，最好不用从裸指针中建立共享指针。</p>
<ul>
<li><p>另一个问题是，正如上述问题，如果从一个裸指针中创建一个共享指针，只有一个共享指针时，可以正常运行，但是当裸指针被释放时，共享指针也会crash。</p>
</li>
<li><p>循环引用时，如果资源被非恰当释放，也会出现问题。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B;</span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_sptrB(<span class="literal">nullptr</span>) &#123;&#125; ;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A is destroyed"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; m_sptrB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : m_sptrA(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B is destroyed"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; m_sptrA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; sptrB(<span class="keyword">new</span> B);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptrA(<span class="keyword">new</span> A);</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当类A包含了指向B的共享指针，而类B包含了指向A的共享指针时，sptrA和sptrB相关的资源都将不会被释放。结果如下图： </p>
<p><img src="/images/cpp/sp6.jpg" alt=""></p>
<h4 id="2-3_weak_ptr">2.3 weak_ptr</h4><p>一个弱指针，提供的是一种共享语义定义而不是拥有语义定义。这就意味着一个弱指针可以通过shared_ptr共享资源。所以要创建弱指针，必须是已经拥有资源但是是一个共享指针。</p>
<p>一个弱指针并不允许诸如普通指针所提供的*和-&gt;。因为他并不是资源的拥有者。</p>
<h5 id="那么如何利用弱指针呢？">那么如何利用弱指针呢？</h5><p><strong>weak_ptr只能用于跟踪一个共享的资源，但并不实际拥有，也不会阻碍资源的释放。读取共享资源前需要先执行lock，得到shared_ptr后才能进行访问。<br>当两个对象需要互相引用时，我们总希望其中一个对象拥有另一个对象的强引用，而另一个对象拥有自己的弱引用，如果两个对象都是强引用，则容易引起循环引用，导致两个对象都无法正确释放。</strong></p>
<h5 id="用weak_ptr作为一个类似share_ptr但却能悬浮的指针">用weak_ptr作为一个类似share_ptr但却能悬浮的指针</h5><p>有一个矛盾，一个灵巧指针可以像shared_ptr 一样方便，但又不参与管理被指对象的所有权。换句话说，需要一个像shared_ptr但又不影响对象引用计数的指针。这类指针会有一个shared_ptr没有的问题：被指的对象有可能已经被销毁。一个良好的灵巧指针应该能处理这种情况，通过跟踪什么时候指针会悬浮，比如在被指对象不复存在的时候。这正是weak_ptr这类型灵巧指针所能做到的。</p>
<p>weak_ptr一般是通过shared_ptr来构造的。当使用shared_ptr来初始化weak_ptr时，weak_ptr就指向了相同的地方，但是不改变所指对象的引用计数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptr&lt;<span class="keyword">new</span> A&gt;</span><br><span class="line">    weak_ptr&lt;A&gt; wptr(sptr);</span><br><span class="line">    weak_ptr&lt;A&gt; wptr1 = wptr; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>weak_ptr创建引用情况 </p>
<p><img src="/images/cpp/sp7.jpg" alt=""></p>
<p>从上图可以看书，通过将一个weak_ptr赋值给另一个时会增加其弱引用计数。</p>
<p>如果弱引用指针所指向的资源，被其共享指针所释放时，这时候弱指针将会过期。如何检测一个弱指针是否指向一个合法的资源呢？有以下两种途径。</p>
<p>调用use_count()来得到引用计数。注意这里返回的是强引用计数。<br>调用expired()函数，这比调用use_count要快的多。<br>同时，我们可以通过对一个weak_ptr调用函数lock()来得到一个shared_ptr。或者直接对一个weak_ptr进行强制转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptr&lt;<span class="keyword">new</span> A&gt;</span><br><span class="line">    weak_ptr&lt;A&gt; wptr(sptr);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptr2 = wptr.lock(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; sptrB(<span class="keyword">new</span> B);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptrA(<span class="keyword">new</span> A);</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上方法将增加强引用计数。</p>
<p>以下例子将展示如何使用weak_ptr解决循环引用的问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B;</span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_a(<span class="number">5</span>) &#123;&#125; ;</span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A is destroyed"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintSpB</span><span class="params">()</span> </span>;</span><br><span class="line">    weak_ptr&lt;B&gt; m_sptrB;</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() : m_b(<span class="number">10</span>) &#123;&#125; ;</span><br><span class="line">    ~B() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B is destroyed"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    weak_ptr&lt;A&gt; m_sptrA;</span><br><span class="line">    <span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> A::PrintSpB()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( !m_sptrB.expired() )</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m_sptrB.lock()-&gt;m_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; sptrB(<span class="keyword">new</span> B);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; sptrA(<span class="keyword">new</span> A);</span><br><span class="line">    sptrB-&gt;m_sptrA = sptrA;</span><br><span class="line">    sptrA-&gt;m_sptrB = sptrB;</span><br><span class="line">    sptrA-&gt;PrintSpB();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4_unique_ptr">2.4 unique_ptr</h4><p>unique_ptr几乎是易出错的auto_ptr的另一种形式。unique_ptr遵循专用所有权语义。在任何时刻，资源只被唯一的一个unique_ptr所占有。当auto_ptr不在作用域范围内时，资源就会被释放。当一个资源被其他资源重写时，如果先前的资源已经被释放，这保证了相关的资源也会被释放。</p>
<p>creation（创建）</p>
<p>unique_ptr创建的过程和shared_ptr创建的过程大同小异，所不同的是创建的数组形式的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>&gt; uptr(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>unique_ptr提供了专用创建数组对象的析构调用delete[]而不是delete当其不在作用域范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="keyword">int</span>[]&gt; uptr1(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>
<p>对于资源的拥有权(ownership)可以从一个unique_ptr通过另一个进行赋值来传递。</p>
<p>需要记住的是：unique_ptr并不提供复制机制copy semantics（包括复制赋值copy assignment以及复制构造函数copy construction）而是一种移动机制。</p>
<p>Interface（接口）</p>
<p>unique_ptr提供的接口与普通常规指针的接口非常相似，但是并不提供指针运算。<br>unique_ptr提供release()函数来进行yield the ownership。release()和reset()函数的区别在于，reset()会对资源进行销毁。</p>
<p>参考文献：</p>
<p><a href="http://blog.csdn.net/coolmeme/article/details/43266319" target="_blank" rel="external">http://blog.csdn.net/coolmeme/article/details/43266319</a><br><a href="http://www.codeproject.com/Articles/541067/Cplusplus-Smart-Pointers" target="_blank" rel="external">http://www.codeproject.com/Articles/541067/Cplusplus-Smart-Pointers</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_传统指针存在的问题">1. 传统指针存在的问题</h3><hr>
<p>传统指针存在诸多的问题，比如指针所指向的对象的生命周期问题，挂起引用(dangling references)，以及内存泄露(memory leaks). 如下是一个传统指针的使用过程<]]>
    </summary>
    
      <category term="dev" scheme="http://www.notehub.cn/categories/dev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发者都应该使用的10个C++11特性]]></title>
    <link href="http://www.notehub.cn/2015/10/26/dev/CPP/cpp11/"/>
    <id>http://www.notehub.cn/2015/10/26/dev/CPP/cpp11/</id>
    <published>2015-10-26T12:19:56.000Z</published>
    <updated>2015-10-26T11:21:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="auto">auto</h3><hr>
<p>在C++11之前，auto关键字用来指定存储期。在新标准中，它的功能变为类型推断。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。各种作用域内声明变量都可以用到它。例如，名空间中，程序块中，或是for循环的初始化语句中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;        <span class="comment">// i is an int</span></span><br><span class="line"><span class="keyword">auto</span> l = <span class="number">42L</span>L;      <span class="comment">// l is an long long</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> foo(); <span class="comment">// p is a foo*</span></span><br></pre></td></tr></table></figure></p>
<p>使用auto通常意味着更短的代码（除非你所用类型是int，它会比auto少一个字母）。试想一下当你遍历STL容器时需要声明的那些迭代器（iterator）。现在不需要去声明那些typedef就可以得到简洁的代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = begin(<span class="built_in">map</span>); it != end(<span class="built_in">map</span>); ++it) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，auto不能用来声明函数的返回值。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(T1 t1, T2 t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> v = compose(<span class="number">2</span>, <span class="number">3.14</span>); <span class="comment">// v's type is double</span></span><br></pre></td></tr></table></figure></p>
<h3 id="nullptr">nullptr</h3><hr>
<p>以前都是用0来表示空指针的，但由于0可以被隐式类型转换为整形，这就会存在一些问题。关键字nullptr是std::nullptr_t类型的值，用来指代空指针。nullptr和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="literal">nullptr</span>;   </span><br><span class="line"><span class="keyword">if</span>(p1 == p2) &#123;&#125;</span><br><span class="line">foo(<span class="literal">nullptr</span>);</span><br><span class="line">bar(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="literal">nullptr</span>; <span class="comment">// error: A native nullptr can only be converted to bool or, using reinterpret_cast, to an integral type</span></span><br></pre></td></tr></table></figure></p>
<p>为了向前兼容，0仍然是个合法的空指针值。</p>
<h3 id="Range-based_for_loops_（基于范围的for循环）">Range-based for loops （基于范围的for循环）</h3><hr>
<p>为了在遍历容器时支持”foreach”用法，C++11扩展了for语句的语法。用这个新的写法，可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型。如果你只是想对集合或数组的每个元素做一些操作，而不关心下标、迭代器位置或者元素个数，那么这种foreach的for循环将会非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"one"</span>] = v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kvp : <span class="built_in">map</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; kvp.first &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : kvp.second)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr) </span><br><span class="line">&#123;</span><br><span class="line">  e = e*e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="override和final">override和final</h3><hr>
<p>我总觉得 C++中虚函数的设计很差劲，因为时至今日仍然没有一个强制的机制来标识虚函数会在派生类里被改写。vitual关键字是可选的，这使得阅读代码变得很费劲。因为可能需要追溯到继承体系的源头才能确定某个方法是否是虚函数。为了增加可读性，我总是在派生类里也写上virtual关键字，并且也鼓励大家都这么做。即使这样，仍然会产生一些微妙的错误。看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>B::f 按理应当重写 A::f。然而二者的声明是不同的，一个参数是short，另一个是int。因此B::f只是拥有同样名字的另一个函数（重载）而不是重写。当你通过A类型的指针调用f()可能会期望打印出B::f，但实际上则会打出 f(int)而不是f(short) 。另一个很微妙的错误情况：参数相同，但是基类的函数是const的，派生类的函数却不是。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f "</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，这两个函数是重载而不是重写。幸运的是，现在有一种方式能描述你的意图。新标准加入了两个新的标识符（不是关键字）</p>
<p>override，表示函数必须重写基类中的虚函数，如果派生类没有重写到将编译报错。</p>
<p>final，表示派生类不应当重写这个虚函数，如果派生类重写了基类的虚函数将编译报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span> final </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::g"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span>  override  </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">    <span class="comment">//virtual void g(int) &#123; std::cout &lt;&lt; "A::g" &lt;&lt; std::endl; &#125; // error C3248: “main::A::g”:  声明为“final”的函数无法被“main::B::g”重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::g"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125; <span class="comment">// 重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Strongly-typed_enums_强类型枚举">Strongly-typed enums 强类型枚举</h3><hr>
<p>传统的C++枚举类型存在一些缺陷：它们会将枚举常量暴露在外层作用域中（这可能导致名字冲突，如果同一个作用域中存在两个不同的枚举类型，但是具有相同的枚举常量就会冲突），而且它们会被隐式转换为整形，无法拥有特定的用户定义类型。</p>
<p>在C++11中通过引入了一个称为强类型枚举的新类型，修正了这种情况。强类型枚举由关键字enum class标识。它不会将枚举常量暴露到外层作用域中，也不会隐式转换为整形，并且拥有用户指定的特定类型（传统枚举也增加了这个性质）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Options &#123;None, One, All&#125;;</span><br><span class="line">Options o = Options::All;</span><br></pre></td></tr></table></figure>
<h3 id="Smart_Pointers_智能指针">Smart Pointers 智能指针</h3><hr>
<p>已经有成千上万的文章讨论这个问题了，所以我只想说：现在能使用的，带引用计数，并且能自动释放内存的智能指针包括以下几种：</p>
<p>unique_ptr: 如果内存资源的所有权不需要共享，就应当使用这个（它没有拷贝构造函数），但是它可以转让给另一个unique_ptr（存在move构造函数）。</p>
<p>shared_ptr:  如果内存资源需要共享，那么使用这个（所以叫这个名字）。</p>
<p>weak_ptr: 持有被shared_ptr所管理对象的引用，但是不会改变引用计数值。它被用来打破依赖循环（想象在一个tree结构中，父节点通过一个共享所有权的引用(chared_ptr)引用子节点，同时子节点又必须持有父节点的引用。如果这第二个引用也共享所有权，就会导致一个循环，最终两个节点内存都无法释放）。</p>
<p>另一方面，auto_ptr已经被废弃，不会再使用了。</p>
<p>什么时候使用unique_ptr，什么时候使用shared_ptr取决于对所有权的需求，我建议阅读以下的讨论：<a href="http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members" target="_blank" rel="external">http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::unique_ptr&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br><span class="line"><span class="built_in">std</span>::unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// 移交unique指针</span></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = wp.lock(); <span class="comment">// 提升shared_ptr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line">sp.reset();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (wp.expired())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expired"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>如果你试图锁定(lock)一个过期（指被弱引用对象已经被释放）的weak_ptr，那你将获得一个空的shared_ptr.</p>
<h3 id="Lambdas">Lambdas</h3><hr>
<p>匿名函数（也叫lambda）已经加入到C++中，并很快异军突起。这个从函数式编程中借来的强大特性，使很多其他特性以及类库得以实现。你可以在任何使用函数对象或者函子(functor)或std::function的地方使用lambda。你可以从这里（<a href="http://msdn.microsoft.com/en-us/library/dd293603.aspx）找到语法说明。" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/dd293603.aspx）找到语法说明。</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::begin(v), <span class="built_in">std</span>::end(v), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(<span class="built_in">std</span>::begin(v), <span class="built_in">std</span>::end(v), is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != <span class="built_in">std</span>::end(v))</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>更复杂的是递归lambda。考虑一个实现Fibonacci函数的lambda。如果你试图用auto来声明，就会得到一个编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [&amp;fib](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);&#125;;</span><br></pre></td></tr></table></figure>
<p>error C3533: ‘auto &amp;’: a parameter cannot have a type that contains ‘auto’<br>error C3531: ‘fib’: a symbol whose type contains ‘auto’ must have an initializer<br>error C3536: ‘fib’: cannot be used before it is initialized<br>error C2064: term does not evaluate to a function taking 1 arguments<br>问题出在auto意味着对象类型由初始表达式决定，然而初始表达式又包含了对其自身的引用，因此要求先知道它的类型，这就导致了无穷递归。解决问题的关键就是打破这种循环依赖，用std::function显式的指定函数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; lfib = [&amp;lfib](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : lfib(n-<span class="number">1</span>) + lfib(n-<span class="number">2</span>);&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非成员begin()和end()">非成员begin()和end()</h3><hr>
<p>也许你注意到了，我在前面的例子中已经用到了非成员begin()和end()函数。他们是新加入标准库的，除了能提高了代码一致性，还有助于更多地使用泛型编程。它们和所有的STL容器兼容。更重要的是，他们是可重载的。所以它们可以被扩展到支持任何类型。对C类型数组的重载已经包含在标准库中了。我们还用上一个例子中的代码来说明，在这个例子中我打印了一个数组然后查找它的第一个偶数元素。如果std::vector被替换成C类型数组。代码可能看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>]+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> begin = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">auto</span> end = &amp;arr[<span class="number">0</span>]+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(begin, end, is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != end)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>如果使用非成员的begin()和end()来实现，就会是以下这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr), is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != <span class="built_in">std</span>::end(arr))</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>这基本上和使用std::vecto的代码是完全一样的。这就意味着我们可以写一个泛型函数处理所有支持begin()和end()的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(Iterator begin, Iterator end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::for_each(begin, end, [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(begin, end, is_odd);</span><br><span class="line">    <span class="keyword">if</span>(pos != end)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(C c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    bar(<span class="built_in">std</span>::begin(c), <span class="built_in">std</span>::end(c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T(&amp;arr)</span>[N])</span><br><span class="line"></span>&#123;</span><br><span class="line">    bar(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">foo(arr);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">foo(v);</span><br></pre></td></tr></table></figure>
<h3 id="static_assert和_type_traits">static_assert和 type traits</h3><hr>
<p>static_assert提供一个编译时的断言检查。如果断言为真，什么也不会发生。如果断言为假，编译器会打印一个特殊的错误信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> Vector</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">static_assert</span>(Size &lt; <span class="number">3</span>, <span class="string">"Size is too small"</span>);</span><br><span class="line">   T _points[Size];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Vector&lt;<span class="keyword">int</span>, <span class="number">16</span>&gt; a1;</span><br><span class="line">   Vector&lt;<span class="keyword">double</span>, <span class="number">2</span>&gt; a2;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>error C2338: Size is too small<br>see reference to class template instantiation ‘Vector<t,size>‘ being compiled<br>   with<br>   [<br>      T=double,<br>      Size=2<br>   ]<br>static_assert和type traits一起使用能发挥更大的威力。type traits是一些class，在编译时提供关于类型的信息。在头文件<type_traits>中可以找到它们。这个头文件中有好几种class: helper class，用来产生编译时常量。type traits class，用来在编译时获取类型信息，还有就是type transformation class，他们可以将已存在的类型变换为新的类型。</type_traits></t,size></p>
<p>下面这段代码原本期望只做用于整数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 t1, T2 t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果有人写出如下代码，编译器并不会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"one"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>程序会打印出4.14和”e”。但是如果我们加上编译时断言，那么以上两行将产生编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 t1, T2 t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral&lt;T1&gt;::value, <span class="string">"Type T1 must be integral"</span>);</span><br><span class="line">   <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral&lt;T2&gt;::value, <span class="string">"Type T2 must be integral"</span>);</span><br><span class="line">   <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>error C2338: Type T2 must be integral<br>see reference to function template instantiation ‘T2 add<int,double>(T1,T2)’ being compiled<br>   with<br>   [<br>      T2=double,<br>      T1=int<br>   ]<br>error C2338: Type T1 must be integral<br>see reference to function template instantiation ‘T1 add<const char*,int="">(T1,T2)’ being compiled<br>   with<br>   [<br>      T1=const char *,<br>      T2=int<br>   ]</const></int,double></p>
<h3 id="Move_semantics_（Move语义）">Move semantics （Move语义）</h3><hr>
<p>这是C++11中所涵盖的另一个重要话题。就这个话题可以写出一系列文章，仅用一个段落来说明显然是不够的。因此在这里我不会过多的深入细节，如果你还不是很熟悉这个话题，我鼓励你去阅读更多地资料。C++11加入了右值引用(value reference)的概念（用&amp;&amp;标识），用来区分对左值和右值的引用。左值就是一个有名字的对象，而右值则是一个无名对象（临时对象）。move语义允许修改右值（以前右值被看作是不可修改的，等同于const T&amp;类型）。C++的class或者struct以前都有一些隐含的成员函数：默认构造函数（仅当没有显示定义任何其他构造函数时才存在），拷贝构造函数，析构函数还有拷贝赋值操作符。拷贝构造函数和拷贝赋值操作符提供bit-wise的拷贝（浅拷贝），也就是逐个bit拷贝对象。也就是说，如果你有一个类包含指向其他对象的指针，拷贝时只会拷贝指针的值而不会管指向的对象。在某些情况下这种做法是没问题的，但在很多情况下，实际上你需要的是深拷贝，也就是说你希望拷贝指针所指向的对象。而不是拷贝指针的值。这种情况下，你需要显示地提供拷贝构造函数与拷贝赋值操作符来进行深拷贝。如果你用来初始化或拷贝的源对象是个右值（临时对象）会怎么样呢？你仍然需要拷贝它的值，但随后很快右值就会被释放。这意味着产生了额外的操作开销，包括原本并不需要的空间分配以及内存拷贝。现在说说move constructor和move assignment operator。这两个函数接收T&amp;&amp;类型的参数，也就是一个右值。在这种情况下，它们可以修改右值对象，例如“偷走”它们内部指针所指向的对象。举个例子，一个容器的实现（例如vector或者queue）可能包含一个指向元素数组的指针。当用一个临时对象初始化一个对象时，我们不需要分配另一个数组，从临时对象中把值复制过来，然后在临时对象析构时释放它的内存。我们只需要将指向数组内存的指针值复制过来，由此节约了一次内存分配，一次元数组的复制以及后来的内存释放。以下代码实现了一个简易的buffer。这个buffer有一个成员记录buffer名称（为了便于以下的说明），一个指针（封装在unique_ptr中）指向元素为T类型的数组，还有一个记录数组长度的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// default constructor</span></span><br><span class="line">   Buffer():</span><br><span class="line">      _size(<span class="number">16</span>),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[<span class="number">16</span>])</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">size_t</span> size):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[size])</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[copy._size])</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Buffer&amp; copy)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> != ©)</span><br><span class="line">      &#123;</span><br><span class="line">         _name = copy._name;</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span>(_size != copy._size)</span><br><span class="line">         &#123;</span><br><span class="line">            _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">            _size = copy._size;</span><br><span class="line">            _buffer = _size &gt; <span class="number">0</span> &gt; <span class="keyword">new</span> T[_size] : <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         T* source = copy._buffer.get();</span><br><span class="line">         T* dest = _buffer.get();</span><br><span class="line">         <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):</span><br><span class="line">      _name(<span class="built_in">std</span>::move(temp._name)),</span><br><span class="line">      _size(temp._size),</span><br><span class="line">      _buffer(<span class="built_in">std</span>::move(temp._buffer))</span><br><span class="line">   &#123;</span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; temp)</span><br><span class="line">   &#123;</span><br><span class="line">      assert(<span class="keyword">this</span> != &amp;temp); <span class="comment">// assert if this is not a temporary</span></span><br><span class="line">  </span><br><span class="line">      _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      _size = temp._size;</span><br><span class="line">      _buffer = <span class="built_in">std</span>::move(temp._buffer);</span><br><span class="line">  </span><br><span class="line">      _name = <span class="built_in">std</span>::move(temp._name);</span><br><span class="line">  </span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Buffer&lt;T&gt; getBuffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) </span><br><span class="line">&#123;</span><br><span class="line">   Buffer&lt;T&gt; b(name, <span class="number">128</span>);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b1;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b2(<span class="string">"buf2"</span>, <span class="number">64</span>);</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b3 = b2;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b4 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf4"</span>);</span><br><span class="line">   b1 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf5"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的copy constructor以及copy assignment operator大家应该很熟悉了。C++11中新增的是move constructor以及move assignment operator，这两个函数根据上文所描述的move语义实现。如果你运行这段代码，你就会发现b4构造时，move constructor会被调用。同样，对b1赋值时，move assignment operator会被调用。原因就在于getBuffer()的返回值是一个临时对象——也就是右值。你也许注意到了，move constuctor中当我们初始化变量name和指向buffer的指针时，我们使用了std::move。name实际上是一个string，std::string实现了move语义。std::unique_ptr也一样。但是如果我们写_name(temp._name)，那么copy constructor将会被调用。不过对于_buffer来说不能这么写，因为std::unique_ptr没有copy constructor。但为什么std::string的move constructor此时没有被调到呢？这是因为虽然我们使用一个右值调用了Buffer的move constructor，但在这个构造函数内，它实际上是个左值。为什么？因为它是有名字的——“temp”。一个有名字的对象就是左值。为了再把它变为右值（以便调用move constructor)必须使用std::move。这个函数仅仅是把一个左值引用变为一个右值引用。更新：虽然这个例子是为了说明如何实现move constructor以及move assignment operator，但具体的实现方式并不是唯一的。某同学提供了另一种可能的实现。为了方便查看，我把它也列在下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = <span class="string">""</span>, <span class="keyword">size_t</span> size = <span class="number">16</span>):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(size? <span class="keyword">new</span> T[size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(copy._size? <span class="keyword">new</span> T[copy._size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer copy)</span><br><span class="line">   &#123;</span><br><span class="line">       swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):Buffer()</span><br><span class="line">   &#123;</span><br><span class="line">      swap(*<span class="keyword">this</span>, temp);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; first, Buffer&amp; second)</span> <span class="keyword">noexcept</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">       swap(first._name  , second._name);</span><br><span class="line">       swap(first._size  , second._size);</span><br><span class="line">       swap(first._buffer, second._buffer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="auto">auto</h3><hr>
<p>在C++11之前，auto关键字用来指定存储期。在新标准中，它的功能变为类型推断。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。各种作用域内声明变量都可以用到它。例如，名空间中，]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个故事讲清楚 NIO]]></title>
    <link href="http://www.notehub.cn/2015/10/26/dev/about_nio/"/>
    <id>http://www.notehub.cn/2015/10/26/dev/about_nio/</id>
    <published>2015-10-26T08:19:56.000Z</published>
    <updated>2015-10-26T08:56:33.000Z</updated>
    <content type="html"><![CDATA[<p>假设某银行只有10个职员, 该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；<br>2） 职员审核（1分钟）；<br>3） 职员叫保安去金库取钱（3分钟）；<br>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。<br>我们看看银行不同的工作方式对其工作效率到底有何影响。</p>
<h3 id="1_BIO方式">1 BIO方式</h3><p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>
<p>我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>
<p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>
<p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>
<h3 id="2_NIO方式">2 NIO方式</h3><p>如何提高银行的吞吐量呢？</p>
<p>思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。</p>
<p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>
<p>我们计算下这种工作方式下银行一个小时到底能处理多少顾客？</p>
<p>假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。</p>
<p>可见工作方式的转变能带来效率的极大提升。</p>
<p>这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图，mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。</p>
<p>可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>
<h3 id="3_异步方式">3 异步方式</h3><p>第二种工作方式有没有什么可以提高的地方呢？</p>
<p>仔细查看可发现第3步骤这3分钟柜台职员是在等待中度过的，那怎么能让柜台职员保持满负荷呢？</p>
<p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。当职员B拿到钱之后，他会怎么办呢？他会通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p>
<p>我们可以算算通过这种方法，银行的吞吐量能提高到多少。</p>
<p>假设职员B的工作非常饱和，柜台一个职员现在2分钟能处理完一个顾客，一个小时8名职员能处理：8*（60/2）=240。</p>
<p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p>
<p>jetty Continuations 就实现了上述异步方式，有兴趣的同学可以去尝试下（<a href="http://wiki.eclipse.org/Jetty/Feature/Continuations）。" target="_blank" rel="external">http://wiki.eclipse.org/Jetty/Feature/Continuations）。</a></p>
<p>NIO+异步的方式能让少量的线程（资源）做大量的事情，这适用于很多应用场景，比如代理服务、api服务、长连接服务等等，这些应用如果用同步方式将耗费大量机器资源。尽管NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p>
<h3 id="4_小结">4 小结</h3><p>总结就一句：“分而治之，将任务拆分开来，由专门的人负责专门的任务”，这不仅在计算机领域生效，在整个社会领域都生效。</p>
<p>src: <a href="http://blog.jobbole.com/88984/" target="_blank" rel="external">http://blog.jobbole.com/88984/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设某银行只有10个职员, 该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；<br>2） 职员审核（1分钟）；<br>3） 职员叫保安去金库取钱（3分钟）；<br>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。<br>我们看看银行不同]]>
    </summary>
    
      <category term="nio" scheme="http://www.notehub.cn/tags/nio/"/>
    
      <category term="dev" scheme="http://www.notehub.cn/categories/dev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[标准C++中的string类的用法总结]]></title>
    <link href="http://www.notehub.cn/2015/10/23/dev/CPP/cpp_string/"/>
    <id>http://www.notehub.cn/2015/10/23/dev/CPP/cpp_string/</id>
    <published>2015-10-23T12:19:56.000Z</published>
    <updated>2015-10-23T05:45:21.000Z</updated>
    <content type="html"><![CDATA[<p>#include <string>// 注意是<string>，不是<string.h>，带.h的是C语言中的头文件<br>using  std::string;<br>using  std::wstring;<br>using namespace std;</string.h></string></string></p>
<p>下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。<br>string和wstring的用法是一样的，以下只用string作介绍：</p>
<p>string类的构造函数：</p>
<p>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p>
<p>string类的字符操作：<br>const char &amp;operator<a href="int n"></a>const;<br>const char &amp;at(int n)const;<br>char &amp;operator<a href="int n"></a>;<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char <em>data()const;//返回一个非null终止的c字符数组<br>const char </em>c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p>
<p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p>
<p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p>
<p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char <em>s);//用c类型字符串s赋值<br>string &amp;assign(const char </em>s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p>
<p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char <em>s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char </em>s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p>
<p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中<br>//pos2开始的n2个字符组成的字符串的大小<br>int compare(const char <em>s) const;<br>int compare(int pos, int n,const char </em>s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p>
<p>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p>
<p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p>
<p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char <em>s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char </em>s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char <em>s, int pos = npos) const;<br>int rfind(const char </em>s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char <em>s, int pos = 0) const;<br>int find_first_of(const char </em>s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char <em>s, int pos = 0) const;<br>int find_first_not_of(const char </em>s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char <em>s, int pos = npos) const;<br>int find_last_of(const char </em>s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char <em>s, int pos = npos) const;<br>int find_last_not_of(const char </em>s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p>
<p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char <em>s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char </em>s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char <em>s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char </em>s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p>
<p>string类的插入函数：<br>string &amp;insert(int p0, const char <em>s);<br>string &amp;insert(int p0, const char </em>s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p>
<p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p>
<p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。<br>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p>
<p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，#include <sstream>头文件中<br>例如：<br>    string input(“hello,this is a test”);<br>    istringstream is(input);<br>    string s1,s2,s3,s4;<br>    is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>    ostringstream os;<br>    os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>    cout&lt;&lt;os.str();</sstream></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#include <string>// 注意是<string>，不是<string.h>，带.h的是C语言中的头文件<br>using  std::string;<br>using  std::wstring;<br>using namespace std;</string]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Blade用户手册]]></title>
    <link href="http://www.notehub.cn/2015/10/23/dev/blade/"/>
    <id>http://www.notehub.cn/2015/10/23/dev/blade/</id>
    <published>2015-10-23T06:19:56.000Z</published>
    <updated>2015-10-23T06:08:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Blade是什么">Blade是什么</h2><p>软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。</p>
<p>很多人还在手工编写 Makefile，又没有去写正确的依赖，导致每次不得不先 make clean 才放心，Make的意义大打折扣。这在几个文件的小项目下是没什么问题的，对于大的项目就很不方便了。</p>
<p>Autotools 号称auto，但是还是需要人工写很多东西，运行一系列命令，用起来还是比较复杂，开发人员的学习和使用的门槛很高。</p>
<p>Blade 就是针对这些问题，为腾讯公司基础架构部的[<a href="http://storage.it168.com/a2011/1203/1283/000001283196.shtml" target="_blank" rel="external">http://storage.it168.com/a2011/1203/1283/000001283196.shtml</a> “台风”云计算平台]项目而开发的新一代构建工具，希望能成为开发者手中的“瑞士军刀”。我们现在把它开源出来，希望能让更多的人得到方便。</p>
<h2 id="Blade_解决的问题">Blade 解决的问题</h2><ul>
<li>源文件更新导致需要重新构建。这个 gnu make 都能解决得很好。</li>
<li>头文件更新，所以以来这个头文件的源文件都需要重新构建。这个 gnu make 不直接支持，需要搭配 gcc 来生成和更新依赖。</li>
<li>库文件更新，所依赖的库文件更新后，程序应该重新连接，GNU Make 可以做到。</li>
<li>即使我只构建自己的目标，如果库的源代码变了，库应该重新生成，GNU Make 用递归 Make 无法做到。</li>
<li>库文件之间的依赖自动传递，一个库依赖另一个库，库的最终用户不需要关心。</li>
<li>构建过程中的警告和错误应该醒目地显示出来。</li>
<li>能自动支持台风系统大量使用的 proto buffer，以及方便扩充以支持外来可能引入的新工具。</li>
<li>应该能集成自动测试，代码检查等开发常用的功能。</li>
</ul>
<h2 id="Blade运行条件">Blade运行条件</h2><p>Blade 运行时需要以下条件：</p>
<ul>
<li>SCons v2.0 or later   (required)</li>
<li>Python v2.6 or later  (required)</li>
<li>ccache v3.1 or later  (optional)</li>
</ul>
<p>Blade 编译项目时可能需要到：</p>
<ul>
<li>swig   v2.0 or later  (required for swig_library)</li>
<li>flex v2.5 or later    (required for lex_yacc)</li>
<li>bison v2.1 or later   (required for lex_yacc)</li>
</ul>
<h2 id="源代码树的组织">源代码树的组织</h2><p>Blade要求项目源代码有一个明确的根目录，C++ 中的 #include 的路径也需要从这个目录开始写起，这样有几点好处：</p>
<ul>
<li>有效地避免头文件重名造成的问题。</li>
<li>有效地避免库文件的重名。</li>
<li>更容易找到需要的文件。</li>
<li>提高构建速度。</li>
</ul>
<p>Blade并不从某个配置文件或者环境变量读取这个信息，因为开发人员往往需要同时有多个目录树并存。Blade获取源代码根的方法是，无论当前从哪一级子目录运行，都从当前目录开始向上查找BLADE_ROOT文件，有这个文件的目录即为源代码树的根。</p>
<p>目前源代码目录需要自己拉取，将来我们会集成到 Blade 中。BLADE_ROOT 文件也需要用户自己创建。方法：<br> $ touch BLADE_ROOT</p>
<p>一个源代码树的根目录看起来的样子如下：<br> BLADE_ROOT<br> common<br> thirdparty<br> xfs<br> xcube<br> torca<br> your_project<br> …</p>
<h2 id="BUILD文件">BUILD文件</h2><p>Blade 通过一系列的名字为 “BUILD” 的文件（文件名全大写），这些文件需要开发者去编写。每个 BUILD文件通过一组目标描述函数描述了一个目标的源文件，所依赖的其他目标，以及其他一些属性。</p>
<h3 id="BUILD文件的示例">BUILD文件的示例</h3><p>构建脚本很简单：</p>
<p>范例：common/base/string/BUILD<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">'string'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'algorithm.cpp'</span>,</span><br><span class="line">        <span class="string">'string_number.cpp'</span>,</span><br><span class="line">        <span class="string">'string_piece.cpp'</span>,</span><br><span class="line">        <span class="string">'format.cpp'</span>,</span><br><span class="line">        <span class="string">'concat.cpp'</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [<span class="string">'//common/base:int'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>也是说明式的，只需要列出目标名，源文件名和依赖名（可以没有）即可。</p>
<h2 id="风格建议">风格建议</h2><ul>
<li>四空格缩进，不要用tab字符</li>
<li>总是用单引号</li>
<li>目标名用小写</li>
<li>src 里的文件名按字母顺序排列</li>
<li>deps 里先写本目录内的依赖（:target），后写其他目录内的（//dir:name），分别按字母顺序排列。</li>
<li>不同目标之间空一行，前面可以加注释</li>
<li>注释的 # 后面空一格，比如 # This is a comment</li>
</ul>
<h3 id="描述目标">描述目标</h3><p>Blade用一组target函数来定义目标，这些target的通用属性有：</p>
<ul>
<li>name: 字符串，和路径一起成为target的唯一标识，也决定了构建的输出命名</li>
<li>srcs: 列表或字符串，构建该对象需要的源文件，一般在当前目录，或相对于当前目录的子目录中</li>
<li>deps: 列表或字符串，该对象所依赖的其它targets</li>
</ul>
<p>deps的允许的格式：</p>
<ul>
<li>“//path/to/dir/:name” 其他目录下的target，path为从BLADE_ROOT出发的路径，name为被依赖的目标名。看见就知道在哪里。</li>
<li>“:name” 当前目录下的target， path可以省略。</li>
<li>“#pthread” 系统库。直接写#跟名字即可。</li>
</ul>
<p>cc_<code>*</code> 目标<br>包括 cc_test, cc_binary, cc_library，CC 目标均支持的参数为：</p>
<ul>
<li>srcs 源文件列表</li>
<li>deps 依赖列表</li>
<li>incs 头文件路径列表</li>
<li>defs 宏定义列表</li>
<li>warning 警告设置</li>
<li>optimize 优化设置</li>
</ul>
<ul>
<li>注：thirdparty是我们代码库里的一个特殊目录，里面的代码都是一些第三方库，按照台风系统的代码规范，只允许对这里的代码用incs, defs和warnings，自己开发的代码要按照规范组织。Blade会对这个目录之外的代码使用这些参数发出警告。</li>
</ul>
<p>|| <em>字段</em> || <em>解释</em> || <em>举例</em> || <em>备注</em> ||<br>|| warning || 是否屏蔽warning  || warning=’no’ || 默认不屏蔽 warning=’yes’ , 默认不用写，已开启 ||<br>|| defs || 用户定义的宏加入编译中 || defs=[‘_MT’] || 如果用户定义C++关键字，报warning ||<br>|| incs || 用户定义的include || incs=[‘poppy/myinc’] || 用户通常不要使用 ||<br>|| optimize || 用户定义的optimize flags || optimize=[‘O3’] || 适用于 cc_library cc_binary cc_test proto_library swig_library  cc_plugin resource_library ||</p>
<h4 id="cc_library">cc_library</h4><p>用于描述C++库目标。<br>cc_library同时用于构建静态和动态库，默认只构建静态库，只有被dynamic_link=1的cc_binary依赖时或者命令行指定<br>–generate-dynamic 才生成动态链接库。</p>
<p>举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name=<span class="string">'lowercase'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/lower/plowercase.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>],</span><br><span class="line">    link_all_symbols=<span class="keyword">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>link_all_symbols=True<br>库在被静态链接时，确保库里所有的符号都被链接，以保证依赖全局对象构造函数，比如自动注册器的代码能够正常工作。<br>需要全部链接的部分最好单独拆分出来做成全部链接的库，而不是整个库全都全部链接，否则会无端增大可执行文件的大小。 需要注意的是，link_all_symbols是库自身的属性，不是使用库时的属性。Blade是为大型项目设计的，基于以下因素，我们提倡任何模块都应该有自己的 cc_library，用户程序都应该在deps里写全直接依赖，不提倡创建像boost那样的全头文件的库。<ul>
<li>编译速度</li>
<li>将来未知的改变，比如某库一开始只需要头文件就能使用，不依赖标准库之外的任何库，但是后来依赖了MD5，所有使用这个库的代码都要加上新产生的依赖，这与我们设计Blade的初衷是违背的。</li>
</ul>
</li>
</ul>
<p>要强制用户这样使用，可以在编写代码时，总是编写 .h 对应的 .cpp 文件，并把一部分必然要用到的符号（函数，静态变量）的实现写在里面，即使对于模板库，可以引入一个非模板的基类，或者把非模板部分的实现放到 .cpp 里。</p>
<ul>
<li><p>always_optimize<br>True: 不论debug版本还是release版本总是被优化。<br>False: debug版本不作优化。<br>默认为False。目前只对cc_library有效。</p>
</li>
<li><p>prebuilt=True<br>主要应用在thirdparty中从rpm包解来的库，使用这个参数表示不从源码构建。对应的二进制文件必须存在 lib{32,64}_{release,debug} 这样的子目录中。不区分debug/release时可以只有两个实际的目录。</p>
</li>
</ul>
<p>####cc_binary<br>定义C++可执行文件目标<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name=<span class="string">'prstr'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/mystr_main/mystring.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>,<span class="string">':lowercase'</span>,<span class="string">':uppercase'</span>,<span class="string">'#dl'</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>dynamic_link=True<br>目前我们的binary默认为全静态编译以适应云计算平台使用。<br>如果有应用需要动态编译方式，可以使用此参数指定，此时被此target依赖的所有库都会自动生成对应的动态库供链接。<br>需要注意的是，dynamic_link只适用于可执行文件，不适用于库。</p>
</li>
<li><p>export_dynamic=True<br>常规情况下，so中只引用所依赖的so中的符号，但是对于应用特殊的场合，需要在so中引用宿主可执行文件中的符号，就需要这个选项。<br>这个选项告诉连接器在可执行文件的动态符号表中加入所有的符号，而不只是用到的其他动态库中的符号。这样就使得在dlopen方式加载的so中可以调用可执行文件中的这些符号。<br>详情请参考 man ld(1) 中查找 –export-dynamic 的说明。</p>
</li>
</ul>
<p>####cc_test<br>相当于cc_binary，再加上自动链接gtest和gtest_main<br>还支持testdata参数， 列表或字符串，文件会被链接到输出所在目录name.runfiles子目录下，比如：testdata/a.txt =&gt;name.runfiles/testdata/a.txt<br>用blade test子命令，会在成功构建后到name.runfiles目录下自动运行，并输出总结信息。</p>
<ul>
<li><p>testdata=[]<br>在name.runfiles里建立symbolic link指向工程目录的文件，目前支持<br>以下几种形式</p>
<ul>
<li>‘file’<br>在测试程序中使用这个名字本身的形式来访问</li>
<li>‘//your_proj/path/file’<br>在测试程序中用”your_proj/path/file”来访问。</li>
<li>(‘//your_proj/path/file’, “new_name”)<br>在测试程序中用”new_name”来访问</li>
</ul>
</li>
</ul>
<p>可以根据需要自行选择，这些路径都也可以是目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'textfile_test'</span>,</span><br><span class="line">    srcs = <span class="string">'textfile_test.cpp'</span>,</span><br><span class="line">    deps = <span class="string">':io'</span>,</span><br><span class="line">    testdata = [</span><br><span class="line">        <span class="string">'test_dos.txt'</span>,</span><br><span class="line">        <span class="string">'//your_proj/path/file'</span>,</span><br><span class="line">        (<span class="string">'//your_proj/path/file'</span>, <span class="string">'new_name'</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="proto_library">proto_library</h4><p>用于定义protobuf目标<br>deps 为import所涉及的其他proto_library<br>自动依赖protobuf，使用者不需要再显式指定。<br>构建时自动调用protoc生成cc和h，并且编译成对应的cc_library<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proto_library(</span><br><span class="line">    name = <span class="string">'rpc_meta_info_proto'</span>,</span><br><span class="line">    srcs = <span class="string">'rpc_meta_info.proto'</span>,</span><br><span class="line">    deps = <span class="string">':rpc_option_proto'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Blade支持proto_library，使得在项目中使用protobuf十分方便。</p>
<p>要引用某 proto 文件生成的头文件，需要从 BLADE_ROOT 的目录开始，只是把 proto 扩展名改为 pb.h 扩展名。<br>比如 //common/base/string_test.proto 生成的头文件，路径为 “common/base/string_test.pb.h”。</p>
<h4 id="thrift_library">thrift_library</h4><p>用于定义thrift库目标<br>deps 为import所涉及的其他thrift_library<br>自动依赖thrift，使用者不需要再显式指定。<br>构建时自动调用thrift命令生成cpp和h，并且编译成对应的cc_library</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thrift_library(</span><br><span class="line">    name = <span class="string">'shared_thrift'</span>,</span><br><span class="line">    srcs = <span class="string">'shared.thrift'</span>,</span><br><span class="line">)</span><br><span class="line">thrift_library(</span><br><span class="line">    name = <span class="string">'tutorial_thrift'</span>,</span><br><span class="line">    srcs = <span class="string">'tutorial.thrift'</span>,</span><br><span class="line">    deps = <span class="string">':shared_thrift'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>C++中使用生成的头文件时，规则类似proto，需要带上相对BLADE_ROOT的目录前缀。</p>
<ul>
<li>thrift 0.9版（之前版本未测）有个[<a href="https://issues.apache.org/jira/browse/THRIFT-1859" target="_blank" rel="external">https://issues.apache.org/jira/browse/THRIFT-1859</a> bug]，需要修正才能使用，此bug已经在开发版本中[<a href="https://builds.apache.org/job/Thrift/633/changes#detail13" target="_blank" rel="external">https://builds.apache.org/job/Thrift/633/changes#detail13</a> 修正]</li>
</ul>
<h4 id="lex_yacc_library">lex_yacc_library</h4><p>srcs 必须为二元列表，后缀分别为ll和yy<br>构建时自动调用flex和bison, 并且编译成对应的cc_library</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lex_yacc_library(</span><br><span class="line">     name = <span class="string">'parser'</span>,</span><br><span class="line">     srcs = [</span><br><span class="line">         <span class="string">'line_parser.ll'</span>,</span><br><span class="line">         <span class="string">'line_parser.yy'</span></span><br><span class="line">     ],</span><br><span class="line">     deps = [</span><br><span class="line">         <span class="string">":xcubetools"</span>,</span><br><span class="line">     ],</span><br><span class="line">     recursive = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>recursive=True<br>生成可重入的C scanner.</li>
</ul>
<h4 id="gen_rule">gen_rule</h4><p>用于定制自己的目标<br>outs = []，表示输出的文件列表，需要填写这个域gen_rule才会被执行<br>cmd, 字符串，表示被调用的命令行<br>cmd中可含有如下变量，运行时会被替换成srcs和outs中的对应值<br>$SRCS<br>$OUTS<br>$FIRST_SRC<br>$FIRST_OUT<br>$BUILD<em>DIR – 可被替换为 build[64,32]</em>[release,debug] 输出目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen_rule(</span><br><span class="line">    name=<span class="string">'test_gen_target'</span>,</span><br><span class="line">    cmd=<span class="string">'echo what_a_nice_day;touch test2.c'</span>,</span><br><span class="line">    deps=[<span class="string">':test_gen'</span>],                         <span class="comment"># 可以有deps , 也可以被别的target依赖</span></span><br><span class="line">    outs=[<span class="string">'test2.c'</span>]</span><br><span class="line">)</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>很多用户使用gen_rule动态生成代码文件然后和某个cc_library或者cc_binary一起编译，<br>需要注意应该尽量在输出目录生成代码文件,如build64_debug下，并且文件的路径名要写对，<br>如 outs = [‘websearch2/project_example/module_1/file_2.cc’], 这样使用<br>gen_rule生成的文件和库一起编译时就不会发生找不到动态生成的代码文件问题了。</p>
<p>####swig_library</p>
<p>根据.i文件生成相应的python, java 和php cxx模块代码，并且生成对应语言的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">swig_library(</span><br><span class="line">    name = <span class="string">'poppy_client'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'poppy_client.i'</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">':poppy_swig_wrap'</span></span><br><span class="line">    ],</span><br><span class="line">    warning=<span class="string">'yes'</span>,</span><br><span class="line">    java_package=<span class="string">'com.soso.poppy.swig'</span>,   <span class="comment"># 生成的java文件的所在package名称</span></span><br><span class="line">    java_lib_packed=<span class="number">1</span>, <span class="comment"># 表示把生成的libpoppy_client_java.so打包到依赖者的jar包里，如java_jar依赖这个swig_library</span></span><br><span class="line">    optimize=[<span class="string">'O3'</span>]    <span class="comment"># 编译优化选项</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>warning<br>这里的warning仅仅指swig编译参数cpperraswarn是否被指定了，swig_library默认使用非标准编译告警级别（没有那么严格）。</li>
</ul>
<h4 id="cc_plugin">cc_plugin</h4><p>支持生成target所依赖的库都是静态库.a的so库，即plugin。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_plugin(</span><br><span class="line">    name=<span class="string">'mystring'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/mystr/mystring.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>,<span class="string">':lowercase'</span>,<span class="string">':uppercase'</span>,<span class="string">'#dl'</span>],</span><br><span class="line">    warning=<span class="string">'no'</span>,</span><br><span class="line">    defs=[<span class="string">'_MT'</span>],</span><br><span class="line">    optimize=[<span class="string">'O3'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>cc_plugin 是为 JNI，python 扩展等需要动态库的场合设计的，不应该用于其他目的。</p>
<h4 id="resource_library">resource_library</h4><p>编译静态资源。</p>
<p>大家都遇到过部署一个可执行程序，还要附带一堆辅助文件才能运行起来的情况吧？<br>blade通过resource_library，支持把程序运行所需要的数据文件也打包到可执行文件里，<br>比如poppy下的BUILD文件里用的静态资源：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resource_library(</span><br><span class="line">    name = <span class="string">'static_resource'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'static/favicon.ico'</span>,</span><br><span class="line">        <span class="string">'static/forms.html'</span>,</span><br><span class="line">        <span class="string">'static/forms.js'</span>,</span><br><span class="line">        <span class="string">'static/jquery-1.4.2.min.js'</span>,</span><br><span class="line">        <span class="string">'static/jquery.json-2.2.min.js'</span>,</span><br><span class="line">        <span class="string">'static/methods.html'</span>,</span><br><span class="line">        <span class="string">'static/poppy.html'</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>生成  和 libstatic_resource.a 或者 libstatic_resource.so。<br>就像一样protobuf那样，编译后后生成一个库libstatic_resource.a，和一个相应的头文件static_resource.h，带路径包含进来即可使用。</p>
<p>在程序中需要包含static_resource.h（带上相对于BLADE_ROOT的路径）和”common/base/static_resource.hpp”，<br>用 STATIC_RESOURCE 宏来引用数据：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringPiece data = STATIC_RESOURCE(poppy_static_favicon_ico);</span><br></pre></td></tr></table></figure></p>
<p>STATIC_RESOURCE 的参数是从BLADE<em>ROOT目录开始的数据文件的文件名，把所有非字母数字和下划线的字符都替换为</em>。</p>
<p>得到的 data 在程序运行期间一直存在，只可读取，不可写入。</p>
<p>用 static resource 在某些情况下也有一点不方便：就是不能在运行期间更新，因此是否使用，需要根据具体场景自己权衡。</p>
<h4 id="java_jar">java_jar</h4><p>编译java源代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java_jar(</span><br><span class="line">    name = <span class="string">'poppy_java_client'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'src/com/soso/poppy'</span>                 <span class="comment"># 这里只需要指定java文件所在目录，不要写上具体java文件列表</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">'//poppy:rpc_meta_info_proto'</span>,       <span class="comment"># 可以依赖proto_library生成的java文件一起编译打包</span></span><br><span class="line">        <span class="string">'//poppy:rpc_option_proto'</span>,</span><br><span class="line">        <span class="string">'//poppy:rpc_message_proto'</span>,</span><br><span class="line">        <span class="string">'//poppy:poppy_client'</span>,              <span class="comment"># 可以依赖swig_library生成的java文件一起编译打包</span></span><br><span class="line">        <span class="string">'./lib:protobuf-java'</span>,               <span class="comment"># 可以依赖别的jar包</span></span><br><span class="line">        <span class="string">'./lib:junit'</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>prebuilt=True<br>主要应用在已经编译打包好的java jar 包。</li>
</ul>
<h2 id="Blade的输出">Blade的输出</h2><p>构建过程是彩色高亮的<br>出错信息是彩色的，方便定位错误。</p>
<p>默认生成 native arch 的可执行文件，指定生成 32/64 位结果也很简单，加上 -m32/64即可。<br>默认生成 release 版本的结果，如果生成 debug 版的，加上 -p debug 即可。<br>默认构建当前目录，如果当前目录依赖的外面的模块需要重新构建，也会被连带构建起来（Make很难做到）。如果要从当前目录构建所有子目录的目标，也很简单：blade … 即可。</p>
<p>不同构建选项的结果放在不同的目录下，生成的文件一律按层次也放在这个目录里，不会污染源代码目录。</p>
<p>要清除构建结果（一般不需要），blade clean 即可。</p>
<h2 id="Blade_Cache">Blade Cache</h2><p>blade 支持 cache，可以大幅度加快构建速度。<br>blade 支持两种cache</p>
<ul>
<li>ccache , cache配置使用ccache的配置, 如通过配置 CCACHE_DIR 环境变量指定ccache目录。</li>
<li>ccache 没有安装，则使用scons cache, 配置细节如下</li>
</ul>
<p>scons cache需要一个目录，依次按以下顺序检测：</p>
<ul>
<li>命令行参数–cache-dir</li>
<li>环境变量BLADE_CACHE_DIR</li>
<li>如果均未配置，则不启用cache。</li>
<li>空的BLADE_CACHE_DIR变量或者不带参数值的–cache-dir=, 则会禁止cache。</li>
</ul>
<p>–cache-size 如不指定，则默认为2G，如指定，则使用用户指定的以Gigabyte为单位的大小的cache。<br>如 –cache-dir=’~/user_cache’ –cache-size=16 (16 G)大小cache。<br>用户可以根据需要配置大小，超出大小blade会执行清理工作，限制cache大小在用户指定的cache大小，<br>请谨慎设置这个大小，因为涉及到构建速度和机器磁盘空间的占用。</p>
<h2 id="测试支持">测试支持</h2><p>Blade test支持增量测试 ，可以加快tests的执行。<br>已经Pass 的tests 在下一次构建和测试时不需要再跑，除非：</p>
<ul>
<li>tests 的任何依赖变化导致其重新生成。</li>
<li>tests 依赖的测试数据改变，这种依赖为显式依赖，用户需要使用BUILD文件指定，如testdata。</li>
<li>tests 所在环境变量发生改变。</li>
<li>test arguments 改变。</li>
<li>Fail 的test cases ，每次都重跑。</li>
</ul>
<p>如果需要使用全量测试，使用–full-test option, 如 blade test common/… –full-test ， 全部测试都需要跑。<br>另外，cc_test 支持了 always_run 属性，用于在增量测试时，不管上次的执行结果，每次总是要跑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'zookeeper_test'</span>,</span><br><span class="line">    srcs = <span class="string">'zookeeper_test.cc'</span>,</span><br><span class="line">    always_run = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Blade test支持并行测试，并行测试把这一次构建后需要跑的test cases并发地run。<br>blade test [targets] –test-jobs N<br>-t, –test-jobs N 设置并发测试的并发数，Blade会让N个测试进程并行执行</p>
<p>对于某些因为可能相互干扰而不能并行跑的测试，可以加上 exclusive 属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'zookeeper_test'</span>,</span><br><span class="line">    srcs = <span class="string">'zookeeper_test.cc'</span>,</span><br><span class="line">    exclusive = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="命令行参考">命令行参考</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blade `[`action`]` `[`options`]` `[`targets`]`</span><br></pre></td></tr></table></figure>
<p>action是一个动作，目前有</p>
<ul>
<li>build 表示构建项目</li>
<li>test  表示构建并且跑单元测试</li>
<li>clean 表示清除目标的构建结果</li>
<li>query 查询目标的依赖项与被依赖项</li>
<li>run   构建并run一个单一目标</li>
</ul>
<p>targets是一个列表，支持的格式：</p>
<ul>
<li>path:name 表示path中的某个target</li>
<li>path表示path中所有targets</li>
<li>path/… 表示path中所有targets，并递归包括所有子目录</li>
<li>:name表示当前目录下的某个target<br>默认表示当前目录</li>
</ul>
<p>参数列表：</p>
<ul>
<li>-m32,-m64            指定构建目标位数，默认为自动检测</li>
<li>-p PROFILE           指定debug/release，默认release</li>
<li>-k, –keep-going     构建过程中遇到错误继续执行（如果是致命错误不能继续）</li>
<li>-j N,–jobs=N        N路并行编译，多CPU机器上适用</li>
<li>-t N,–test-jobs=N   N路并行测试，多CPU机器上适用</li>
<li>–cache-dir=DIR      指定一个cache目录</li>
<li>–cache-size=SZ      指定cache大小，以G为单位</li>
<li>–verbose            完整输出所运行的每条命令行</li>
<li>–h, –help           显示帮助</li>
<li>–color=yes/no/auto  是否开启彩色</li>
<li>–generate-dynamic   强制生成动态库</li>
<li>–generate-java      为proto_library 和 swig_library 生成java文件</li>
<li>–generate-php       为proto_library 和 swig_library 生成php文件</li>
<li>–gprof              支持 GNU gprof</li>
<li>–gcov               支持 GNU gcov 做覆盖率测试</li>
</ul>
<h2 id="配置">配置</h2><p>Blade 支持三个配置文件</p>
<ul>
<li>blade.zip 同一个目录下的 blade.conf，这是全局配置。</li>
<li>~/.bladerc 用户 HOME 目录下的 .bladerc 文件，这是用户级的配置。</li>
<li>BLADE_ROOT 其实也是个配置文件，写在这里的是项目级配置。</li>
</ul>
<p>后面描述的所有多个参数的配置的每个配置参数都有默认值，并不需要全部写出，也没有顺序要求。</p>
<h3 id="cc_config">cc_config</h3><p>所有c/c++目标的公共配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc_config(</span><br><span class="line">    extra_incs = [<span class="string">'thirdparty'</span>],  <span class="comment"># 额外的 -I，比如 thirdparty</span></span><br><span class="line">    warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C/C++公用警告</span></span><br><span class="line">    c_warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C专用警告</span></span><br><span class="line">    cxx_warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C++专用警告</span></span><br><span class="line">    optimize = <span class="string">'-O2'</span>, <span class="comment"># 优化级别</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有选项均为可选，如果不存在，则保持先前值。发布带的blade.conf中的警告选项均经过精心挑选，建议保持。</p>
<h3 id="cc_test_config">cc_test_config</h3><p>构建和运行测试所需的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_test_config(</span><br><span class="line">    dynamic_link=<span class="keyword">True</span>,   <span class="comment"># 测试程序是否默认动态链接，可以减少磁盘开销，默认为 False</span></span><br><span class="line">    heap_check=<span class="string">'strict'</span>, <span class="comment"># 开启 gperftools 的 HEAPCHECK，具体取值请参考 gperftools 的文档</span></span><br><span class="line">    gperftools_libs=<span class="string">'//thirdparty/perftools:tcmalloc'</span>,  <span class="comment"># tcmclloc 库，blade deps 格式</span></span><br><span class="line">    gperftools_debug_libs=<span class="string">'//thirdparty/perftools:tcmalloc_debug'</span>, <span class="comment"># tcmalloc_debug 库，blade deps 格式</span></span><br><span class="line">    gtest_libs=<span class="string">'//thirdparty/gtest:gtest'</span>,  <span class="comment"># gtest 的库，blade deps 格式</span></span><br><span class="line">    gtest_main_libs=<span class="string">'//thirdparty/gtest:gtest_main'</span> <span class="comment"># gtest_main 的库路径，blade deps 格式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有的 config 的列表类型的选项均支持追加模式，用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_config(</span><br><span class="line">    append = config_items(</span><br><span class="line">        warnings = [...]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>gtest 1.6开始，去掉了 make install，但是可以绕过[<a href="http://blog.csdn.net/chengwenyao18/article/details/7181514" target="_blank" rel="external">http://blog.csdn.net/chengwenyao18/article/details/7181514</a> gtest1.6.0安装方法]。</li>
<li>gtest 库还依赖 pthread，因此gtest_libs需要写成 [‘#gtest’, ‘#pthread’]</li>
<li>或者把源码纳入你的源码树，比如thirdparty下，就可以写成gtest_libs=’//thirdparty/gtest:gtest’。</li>
</ul>
<h3 id="proto_library_config">proto_library_config</h3><p>编译protobuf需要的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto_library_config(</span><br><span class="line">    protoc=<span class="string">'protoc'</span>,  <span class="comment"># protoc编译器的路径</span></span><br><span class="line">    protobuf_libs=<span class="string">'//thirdparty/protobuf:protobuf'</span>, <span class="comment"># protobuf库的路径，Blade deps 格式</span></span><br><span class="line">    protobuf_path=<span class="string">'thirdparty'</span>, <span class="comment"># import 时的 proto 搜索路径，相对于 BLADE_ROOT</span></span><br><span class="line">    protobuf_include_path = <span class="string">'thirdparty'</span>,  <span class="comment"># 编译 pb.cc 时额外的 -I 路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="thrift_library_config">thrift_library_config</h3><p>编译thrift需要的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thrift_library_config(</span><br><span class="line">    thrift=<span class="string">'thrift'</span>,  <span class="comment"># protoc编译器的路径</span></span><br><span class="line">    thrift_libs=<span class="string">'//thirdparty/thrift:thrift'</span>, <span class="comment"># thrift库的路径，Blade deps 格式</span></span><br><span class="line">    thrift_path=<span class="string">'thirdparty'</span>, <span class="comment"># thrift中include时的thrift文件的搜索路径，相对于 BLADE_ROOT</span></span><br><span class="line">    thrift_incs = <span class="string">'thirdparty'</span>,  <span class="comment"># 编译 thrift生成的.cpp 时额外的 -I 路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有这些配置项都有默认值，如果不需要覆盖就无需列入相应的参数。默认值都是假设安装到系统目录下，如果你的项目中把这些库放进进了自己的代码中（比如我们内部），请修改相应的配置。</p>
<h2 id="环境变量">环境变量</h2><p>Blade还支持以下环境变量：</p>
<ul>
<li>TOOLCHAIN_DIR，默认为空</li>
<li>CPP，默认为cpp</li>
<li>CXX，默认为c++</li>
<li>CC，默认为gcc</li>
<li>LD，默认为c++</li>
</ul>
<p>TOOLCHAIN_DIR和CPP等组合起来，构成调用工具的完整路径，例如：</p>
<p>调用/usr/bin下的gcc（开发机上的原版gcc）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOOLCHAIN_DIR=/usr/bin blade</span><br></pre></td></tr></table></figure></p>
<p>使用clang<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPP=<span class="string">'clang -E'</span> CC=clang CXX=clang++ ld=clang++ blade</span><br></pre></td></tr></table></figure></p>
<p>如同所有的环境变量设置规则，放在命令行前的环境变量，只对这一次调用起作用，如果要后续起作用，用 export，要持久生效，放入 ~/.profile 中。</p>
<p>环境变量的支持将来考虑淘汰，改为配置编译器版本的方式，因此建议暂时不要使用。</p>
<h2 id="辅助命令">辅助命令</h2><h3 id="install">install</h3><p>blade命令的符号链接会被安装下面的命令到~/bin 下。</p>
<h3 id="lsrc">lsrc</h3><p>列出当前目录下指定的源文件，以blade的srcs列表格式输出。</p>
<h3 id="genlibbuild">genlibbuild</h3><p>自动生成以目录名为库名的cc_library，以测试文件的名为名的cc_test，proto的BUILD文件，并假设这些测试都依赖这个库</p>
<h3 id="vim集成">vim集成</h3><p>我们编写了vim的blade语法文件，高亮显示blade关键字，install后就会自动生效。</p>
<p>我们编写了 Blade 命令，使得可以在 vim 中直接执行 blade，并快速跳转到出错行（得益于 vim 的 <a href="ttp://easwy.com/blog/archives/advanced-vim-skills-quickfix-mode/" target="_blank" rel="external">hquickfix</a> 特性）。</p>
<p>使用时直接在 vim 的 : 模式输入（可带参数）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Blade</span><br></pre></td></tr></table></figure>
<p>即可构建。</p>
<p>这个命令的源代码在 tools/.vimrc 中。</p>
<h3 id="alt">alt</h3><p>在源代码目录和构建目标目录之间跳转</p>
<h2 id="安装">安装</h2><p>执行install脚本即可安装到~/bin下，目前因还在开发阶段，变化还比较快，以软链方式安装，install后不能删除checkout出来的原始目录。<br>目前blade生成scons脚本，因此还需要安装scons 2.0以上版本。<br>Blade 需要支持 Python 2.4-2.7.x，不支持 python3。</p>
<p>install使得可以在任何目录下直接执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blade</span><br></pre></td></tr></table></figure>
<p>命令。<br>如果不行，确保~/bin在你的PATH环境变量里，否则修改 ~/.profile，加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后重新登录即可。</p>
<p>From: <a href="https://github.com/chen3feng/typhoon-blade/blob/master/doc/user_manual_zh_CN.md" target="_blank" rel="external">https://github.com/chen3feng/typhoon-blade/blob/master/doc/user_manual_zh_CN.md</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Blade是什么">Blade是什么</h2><p>软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。</p>
<p>很多人还在手工编写 Makefile，又没有去写正确的依]]>
    </summary>
    
      <category term="blade" scheme="http://www.notehub.cn/tags/blade/"/>
    
      <category term="dev" scheme="http://www.notehub.cn/categories/dev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ 编程环境]]></title>
    <link href="http://www.notehub.cn/2015/10/21/dev/CPP/cpp_dev/"/>
    <id>http://www.notehub.cn/2015/10/21/dev/CPP/cpp_dev/</id>
    <published>2015-10-21T12:19:56.000Z</published>
    <updated>2015-10-26T07:09:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="C++_code_with_Google_style">C++ code with Google style</h3><p><a href="http://google.github.io/styleguide/cppguide.html" target="_blank" rel="external">http://google.github.io/styleguide/cppguide.html</a></p>
<h3 id="Use_cpplint_to_check_your_style">Use cpplint to check your style</h3><h3 id="Protocol_Buffers">Protocol Buffers</h3><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">https://developers.google.com/protocol-buffers/</a><br>(proto2): <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto</a><br>C++ related: <a href="https://developers.google.com/protocol-buffers/docs/cpptutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/cpptutorial</a>,<br>Style guide: <a href="https://developers.google.com/protocol-buffers/docs/style" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/style</a></p>
<h3 id="Compile_code:_Blade">Compile code: Blade</h3><p><a href="https://github.com/chen3feng/typhoon-blade" target="_blank" rel="external">https://github.com/chen3feng/typhoon-blade</a></p>
<h3 id="Unit_test_your_code:_gtest">Unit test your code: gtest</h3><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/Documentation.md" target="_blank" rel="external">https://github.com/google/googletest/blob/master/googletest/docs/Documentation.md</a><br>Run unit tests with BLADE<br>Every public method should be covered</p>
<h3 id="Post_your_code_review:_ReviewBoard">Post your code review: ReviewBoard</h3><h3 id="gflags">gflags</h3><p>gflags支持方便的解析和获取命令行参数<br><a href="https://github.com/gflags/gflags" target="_blank" rel="external">https://github.com/gflags/gflags</a></p>
<h3 id="glog">glog</h3><p><a href="https://github.com/google/glog" target="_blank" rel="external">https://github.com/google/glog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="C++_code_with_Google_style">C++ code with Google style</h3><p><a href="http://google.github.io/styleguide/cppguide.html" target="_bl]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maven 依赖包打包]]></title>
    <link href="http://www.notehub.cn/2015/10/12/dev/maven_assembly/"/>
    <id>http://www.notehub.cn/2015/10/12/dev/maven_assembly/</id>
    <published>2015-10-12T12:19:56.000Z</published>
    <updated>2015-10-12T12:25:43.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.travelsky.tdp.pkgstock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>stock-assembly-descriptor<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 绑定到maven的package命令 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ignoreMissingDescriptor</span>&gt;</span>true<span class="tag">&lt;/<span class="title">ignoreMissingDescriptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipAll<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipFilterConf<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipJsCssOnly<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipPicOnly<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="]]>
    </summary>
    
      <category term="java" scheme="http://www.notehub.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Math StatExample]]></title>
    <link href="http://www.notehub.cn/2015/10/12/dev/java_math_stat/"/>
    <id>http://www.notehub.cn/2015/10/12/dev/java_math_stat/</id>
    <published>2015-10-12T04:57:56.000Z</published>
    <updated>2015-10-12T11:27:09.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.StatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.GeometricMean;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Kurtosis;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Mean;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Skewness;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.StandardDeviation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Variance;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Max;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Min;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Percentile;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.summary.Product;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.summary.Sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[] &#123; <span class="number">2.3</span>, <span class="number">5.4</span>, <span class="number">6.2</span>, <span class="number">7.3</span>, <span class="number">23.3</span> &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"min: "</span> + StatUtils.min( values ) );</span><br><span class="line">        System.out.println( <span class="string">"max: "</span> + StatUtils.max( values ) );</span><br><span class="line">        System.out.println( <span class="string">"mean: "</span> + StatUtils.mean( values ) );</span><br><span class="line">        System.out.println( <span class="string">"product: "</span> + StatUtils.product( values ) );</span><br><span class="line">        System.out.println( <span class="string">"sum: "</span> + StatUtils.sum( values ) );</span><br><span class="line">        System.out.println( <span class="string">"variance: "</span> + StatUtils.variance( values ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Measures from previous example</span></span><br><span class="line">        Min min = <span class="keyword">new</span> Min();</span><br><span class="line">        System.out.println( <span class="string">"min: "</span> + min.evaluate( values ) );</span><br><span class="line">        Max max = <span class="keyword">new</span> Max();</span><br><span class="line">        System.out.println( <span class="string">"max: "</span> + max.evaluate( values ) );</span><br><span class="line">        Mean mean = <span class="keyword">new</span> Mean();</span><br><span class="line">        System.out.println( <span class="string">"mean: "</span> + mean.evaluate( values ) );</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        System.out.println( <span class="string">"product: "</span> + product.evaluate( values ) );</span><br><span class="line">        Sum sum = <span class="keyword">new</span> Sum();</span><br><span class="line">        System.out.println( <span class="string">"sum: "</span> + sum.evaluate( values ) );</span><br><span class="line">        Variance variance = <span class="keyword">new</span> Variance();</span><br><span class="line">        System.out.println( <span class="string">"variance: "</span> + variance.evaluate( values ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// New measures</span></span><br><span class="line">        Percentile percentile = <span class="keyword">new</span> Percentile();</span><br><span class="line">        System.out.println( <span class="string">"80 percentile value: "</span> + percentile.evaluate( values, <span class="number">80.0</span> ) );</span><br><span class="line">        GeometricMean geoMean = <span class="keyword">new</span> GeometricMean();</span><br><span class="line">        System.out.println( <span class="string">"geometric mean: "</span> + geoMean.evaluate( values ) );</span><br><span class="line">        StandardDeviation stdDev = <span class="keyword">new</span> StandardDeviation();</span><br><span class="line">        System.out.println( <span class="string">"standard dev: "</span> + stdDev.evaluate( values ) );</span><br><span class="line">        Skewness skewness = <span class="keyword">new</span> Skewness();</span><br><span class="line">        System.out.println( <span class="string">"skewness: "</span> + skewness.evaluate( values ) );</span><br><span class="line">        Kurtosis kurtosis = <span class="keyword">new</span> Kurtosis();</span><br><span class="line">        System.out.println( <span class="string">"kurtosis: "</span> + kurtosis.evaluate( values ) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class=]]>
    </summary>
    
      <category term="java" scheme="http://www.notehub.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Cookie]]></title>
    <link href="http://www.notehub.cn/2015/10/10/internet/ad/cookie/"/>
    <id>http://www.notehub.cn/2015/10/10/internet/ad/cookie/</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-10T06:35:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="关于Cookie">关于Cookie</h2><hr>
<p><img src="/images/other/cookie.jpg" alt=""></p>
<h3 id="Cookie的传递流程">Cookie的传递流程</h3><p>Cookie利用网页代码中癿HTTP头信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。例如：当你在浏览器地址栏中键入了Amazon的URL，浏览器会向Amazon发送一个读取网页请求，并将结果在显示器上显示。在发送前，该网页在你的电脑上寻找Amazon网站设置的Cookie文件，如果找到，浏览器会把Cookie文件中的数据连同前面输入的URL一同发送到Amazon服务器。服务器收到Cookie数据，就会在他的数据库中检索你的ID，你的购物记彔、个人喜好等信息，并记录下新的内容，增加到数据库和Cookie文件中去。如果没有检测到Cookie或者你的Cookie信息不数据库中的信息不符合，则说明你是第一次浏览该网站，服务器的CGI程序将为你创建新的ID信息，幵保存到数据库中。</p>
<h3 id="关于Cookie的一些知识点">关于Cookie的一些知识点</h3><ol>
<li>Cookie是基二浏览器的，因此当电脑上安装多个浏览器时，服务器会生成多个Cookie。虽然是同一个人，但服务器是识删为多个用户。 </li>
<li>Cookie是基二浏览器的，因此当同一台电脑有多个人使用时，服务器也叧会生成一个Cookie。虽然是多个人，但服务器会讣为是一个用户。补充：在多个人均登彔账户时，服务器可以以账户为匙分，为每个账户生成单独癿cookie，比如多人用同一台电脑登彔新浪微博。（感谢数据挖掘_PHP癿指正） </li>
<li>Cookie是无法跨设备设置的。比如我们在单位和家里分别使用两台电脑，即使我们使用同一种同一版本的浏览器，我们迓是生成了两个Cookie，服务器会认为是两个用户。（PS：现在有些浏览器可以同步数据，比如Chrome、Friefox，可以避免这种问题） </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="关于Cookie">关于Cookie</h2><hr>
<p><img src="/images/other/cookie.jpg" alt=""></p>
<h3 id="Cookie的传递流程">Cookie的传递流程</h3><p>Cookie利用网页代码中]]>
    </summary>
    
      <category term="广告" scheme="http://www.notehub.cn/tags/%E5%B9%BF%E5%91%8A/"/>
    
      <category term="internet" scheme="http://www.notehub.cn/categories/internet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在线广告作弊手段一览]]></title>
    <link href="http://www.notehub.cn/2015/10/10/internet/ad/ad_cheating/"/>
    <id>http://www.notehub.cn/2015/10/10/internet/ad/ad_cheating/</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-10T06:21:42.000Z</updated>
    <content type="html"><![CDATA[<p>这里提到的在线广告作弊是指媒体为了刷广告流量而进行的作弊。他们的作弊手段很多， 这里介绍常见的几种。</p>
<p>iframe是广告作弊最常用的技巧，就是在自己的网页上嵌入iframe, 大小为0x0或1×1，也就是用户不可见。通过iframe打开其他页面，在用户看不见的情况下刷流量。别看iframe简单，里面花样很多。</p>
<h3 id="页面内嵌入本站页面的iframe">页面内嵌入本站页面的iframe</h3><p>iframe打开和当前页一样的页面地址，或本站的其他页面。 这样用户的一个浏览行为，很轻松就从1个pv翻倍变成2个pv。如果嵌入iframe多点， 就能翻3倍，4倍…。但使用这个方法很容易被发现，广告投放方，通过分析UV，独立IP等很容易就发现异常。 这是很老的方法，不过还是有些网站乐此不疲。</p>
<h3 id="两个站点间互相嵌入对方站点页面的iframe">两个站点间互相嵌入对方站点页面的iframe</h3><p>这是比较巧妙的作弊技巧，UV，独立IP等分析方法是不能发现异常的。</p>
<h3 id="双层iframe">双层iframe</h3><p>作弊的iframe为了不让人看见，大小只有0x0或1×1，但有些在线广告在显示时会判断浏览窗口大小，如果太小可能就不能显示。这时有些网站就采用了双层iframe技术来刷广告流量。 第一层1×1大小的iframe中又嵌入一个iframe，这个第二层iframe是正常浏览窗口大小，广告代码很难发现异常。</p>
<p>这种作弊方式使用巧妙的，会让主页面和两个iframe使用三个不同的域名，这样因为跨域的问题， 里面的js不可能得到最外层真正的页面地址， 想抓证据都抓不到。</p>
<h3 id="IP屏蔽">IP屏蔽</h3><p>有些站点在进行作弊时，会屏蔽北京，上海等大城市的访问，你从这些地区访问时，看不到他们的作弊代码，一切正常。等换用其他地方的代理访问时，你在他们页面里就能看到作弊用iframe代码。 这是因为很多IT，在线广告公司都在这些大城市，这种屏蔽让他们的作弊手段很难被同业发现。</p>
<h3 id="购买垃圾流量">购买垃圾流量</h3><p>现在来自iframe，木马的垃圾流量都是明码标价在卖的，可以用这些流量来刷页面，刷广告。这种也比较难以发现。网站去刷流量目的往往比较复杂，一是刷广告流量，赚广告商和广告主的钱，二是为了alexa之类的排名，也有是为了给投资人看所谓的“业绩”。 </p>
<p>上面谈的基本都是CPM广告方式的作弊，下面说说其他的。 </p>
<h3 id="CPC作弊">CPC作弊</h3><p>CPC作弊其实是很简单的，只要用iframe打开点击链接即可。</p>
<h3 id="CPA作弊">CPA作弊</h3><p>有些网站广告按CPA结算，比如注册人数等。 这种情况下，有的公司会做专门的自动注册机，保证你的注册人数疯狂上涨。</p>
<h3 id="CPS作弊">CPS作弊</h3><p>很多人感觉CPS方式是不可能作弊的，其实这也是可以的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里提到的在线广告作弊是指媒体为了刷广告流量而进行的作弊。他们的作弊手段很多， 这里介绍常见的几种。</p>
<p>iframe是广告作弊最常用的技巧，就是在自己的网页上嵌入iframe, 大小为0x0或1×1，也就是用户不可见。通过iframe打开其他页面，在用户看不见的]]>
    </summary>
    
      <category term="广告" scheme="http://www.notehub.cn/tags/%E5%B9%BF%E5%91%8A/"/>
    
      <category term="internet" scheme="http://www.notehub.cn/categories/internet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[合福高铁-国庆游]]></title>
    <link href="http://www.notehub.cn/2015/10/07/travel/hefu_travel/"/>
    <id>http://www.notehub.cn/2015/10/07/travel/hefu_travel/</id>
    <published>2015-10-06T16:00:00.000Z</published>
    <updated>2015-10-10T06:11:10.000Z</updated>
    <content type="html"><![CDATA[<p>国庆本来自己没什么计划，后来同学一起计划沿着合福高铁沿线的景点游一圈，合福高铁将黄山、三清山、武夷山、福州、厦门等联系在了一起，横跨三个省份，当真是中国最美的高铁线路。由于人在杭州，因此打算从杭州出发，六天的行程计划去三清山、武夷山、福州和厦门。正所谓计划赶不上变化，再加上国庆人比较多导致早已经买好的票都改签了，预约的酒店很多也没有住成。</p>
<h3 id="首站：杭州-武夷山东">首站：杭州-武夷山东</h3><hr>
<p>晚上6:30发车，9:00就到武夷山东站了，武夷山东站是刚刚开通的车站，周围的交通配套设施都很不完善，另外武夷山东站虽然名字中带着『武夷山』，但是离武夷山景区的距离实在是太长了，坐大巴车要两个小时。</p>
<p>到了景区后住了一个青年旅店，六人间，遇到了两个福州来的漂亮妹子，住的地方很潮湿，可能是因为刚刚来台风的原因，一晚上没有怎么睡好，青年旅店的环境还是挺好的，老板非常文艺，微信发的状态都是繁体字的。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4006.jpg" alt=""><br><img src="/images/hefu_train/IMG_4010.jpg" alt=""></p>
<p>第二天吃了点早饭，为了逃票，直接找了个当地人把我们带到景区去爬大王峰了，大王峰不算是最知名的武夷山景点，不过丹霞地貌的还是挺美的。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4021.jpg" alt=""><br>我觉得逃票这个决定可能是这次旅行最坏得决定了，大王峰倒是没什么特色，但是下午打算去其他景点的时候就发现再买票有点不划算了，本来定的是10月2号离开武夷山的，结果最后只能提前走了。再附几张武夷山的图。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4048.jpg" alt=""><br><img src="/images/hefu_train/IMG_4115.jpg" alt=""></p>
<h3 id="第二站：三清山">第二站：三清山</h3><hr>
<p>『三清山又名少华山、丫山，位于中国江西省上饶市玉山县与德兴市交界处。因玉京、玉虚、玉华三峰宛如道教玉清、上清、太清三位尊神列坐山巅而得名。其中玉京峰为最高，海拔1819.9米，是江西第五高峰和怀玉山脉的最高峰，也是信江的源头。三清山是道教名山，世界自然遗产地、世界地质公园、国家自然遗产、国家地质公园。』</p>
<p>三清山比较热门的路线是南线索道和东线索道，要想徒步上山的话只能从南部走。我们是从东部的金沙索道上山的，国庆假期索道还要叫号按序上山，上去之后已经是海拔1000米以上了，之后所有的景点都在1000米之上。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4192.jpg" alt=""><br><img src="/images/hefu_train/IMG_4213.jpg" alt=""><br><img src="/images/hefu_train/IMG_4257.jpg" alt=""></p>
<center>云雾缭绕的三清山</center><br><img src="/images/hefu_train/IMG_4265.jpg" alt=""><br><img src="/images/hefu_train/IMG_4269.jpg" alt=""><br><img src="/images/hefu_train/IMG_4276.jpg" alt=""><br><center>猴王观宝</center><br><img src="/images/hefu_train/IMG_4287.jpg" alt=""><br><center>如诗如画</center><br><img src="/images/hefu_train/IMG_4296.jpg" alt=""><br><img src="/images/hefu_train/IMG_4299.jpg" alt=""><br><center>三清山主峰</center>

<h3 id="第三站：福州">第三站：福州</h3><hr>
<p>福州整体没有很深得印象，就去了三坊七巷，还买了原价120一人的票，逛的过程中发现票价非常不值啊，收费的小景点都是一些古宅什么的，作为一个北方人，看过了也就那样了，都是类似的。另外三坊七巷和厦门的曾厝垵和鼓浪屿比也没有什么特色，被完爆的节奏。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4346.jpg" alt=""><br><img src="/images/hefu_train/IMG_4355.jpg" alt=""><br><img src="/images/hefu_train/IMG_4523.jpg" alt=""></p>
<center>非常喜欢林则徐纪念馆的牌子的设计</center>

<h3 id="第四站：厦门">第四站：厦门</h3><hr>
<p>上次去厦门是元旦的时候，那个时候是十几个人一起去的，离现在还不到半年的时间。每次去厦门都是不同的感受，总的来说厦门是一个让人放松的城市，非常的文艺。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4364.jpg" alt=""></p>
<center>『烤酸奶』其实是冷冻的，第一次吃，味道还不错</center><br><img src="/images/hefu_train/IMG_4428.jpg" alt=""><br><br><img src="/images/hefu_train/IMG_4497.jpg" alt=""><br><img src="/images/hefu_train/IMG_4518.jpg" alt=""><br><img src="/images/hefu_train/IMG_4519.jpg" alt=""><br><img src="/images/hefu_train/IMG_4520.jpg" alt=""><br><center>鼓浪屿</center><br>鼓浪屿上面的欧式风格的建筑，文艺的小店，小吃等非常多，龙头路非常热闹。<br><img src="/images/hefu_train/IMG_4541.jpg" alt=""><br><center>最后附上行程的所有火车票</center>
]]></content>
    <summary type="html">
    <![CDATA[<p>国庆本来自己没什么计划，后来同学一起计划沿着合福高铁沿线的景点游一圈，合福高铁将黄山、三清山、武夷山、福州、厦门等联系在了一起，横跨三个省份，当真是中国最美的高铁线路。由于人在杭州，因此打算从杭州出发，六天的行程计划去三清山、武夷山、福州和厦门。正所谓计划赶不上变化，再加上]]>
    </summary>
    
      <category term="合福高铁,三清山,武夷山,福州,三坊七巷,厦门,鼓浪屿" scheme="http://www.notehub.cn/tags/%E5%90%88%E7%A6%8F%E9%AB%98%E9%93%81-%E4%B8%89%E6%B8%85%E5%B1%B1-%E6%AD%A6%E5%A4%B7%E5%B1%B1-%E7%A6%8F%E5%B7%9E-%E4%B8%89%E5%9D%8A%E4%B8%83%E5%B7%B7-%E5%8E%A6%E9%97%A8-%E9%BC%93%E6%B5%AA%E5%B1%BF/"/>
    
      <category term="travel" scheme="http://www.notehub.cn/categories/travel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[特征处理]]></title>
    <link href="http://www.notehub.cn/2015/09/25/algo/ml/Feature%20Processing/"/>
    <id>http://www.notehub.cn/2015/09/25/algo/ml/Feature Processing/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2015-09-25T14:37:04.000Z</updated>
    <content type="html"><![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。单个原始特征（或称为变量）通常属于以下几类之一：</p>
<ul>
<li>连续（continuous）特征；</li>
<li>无序类别（categorical）特征；</li>
<li>有序类别（ordinal）特征。</li>
</ul>
<p>本文中我主要介绍针对单个特征的处理方法，虽然也会附带介绍基础的特征组合方法。同时处理多个特征，以及更复杂的特征处理方法介绍，以后我再另外细说。下面我由浅入深地逐渐说明针对这三类特征的常用处理方法。</p>
<h2 id="初级篇">初级篇</h2><hr>
<h3 id="连续特征">连续特征</h3><p>除了归一化（去中心，方差归一），不用做太多特殊处理，可以直接把连续特征扔到模型里使用。</p>
<h3 id="无序特征">无序特征</h3><p>可以使用One-hot（也叫One-of-k）的方法把每个无序特征转化为一个数值向量。比如一个无序特征color有三种取值：red，green，blue。那么可以用一个长度为3的向量来表示它，向量中的各个值分别对应于red，green，blue。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color取值 向量表示</span><br><span class="line">red     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">green   (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">blue    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>这种方法在NLP里用的很多，就是所谓的词向量模型。变换后的向量长度对于词典长度，每个词对应于向量中的一个元素。</p>
<p>机器学习书籍里在讲这个的时候介绍的处理方法可能跟我上面说的有点差别。上面说的表达方式里有一个维度是可以省略的。既然我们知道color一定是取3个值中的一个，那么我们知道向量的前两个元素值，就能推断第3个值是多少。所以，其实用下面的方式就可以表达到底是哪种颜色：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color取值 向量表示</span><br><span class="line">red     (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">green   (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">blue    (<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这样表达的好处是少用了一个维度，降低了转化后特征之间的相关性。但在实际问题中特征基本都或多或少会有些缺失。使用第一种表达方式就可以用全0的向量来表示值缺失，而第二种表达方式是没法表达缺失的。</p>
<h3 id="有序特征">有序特征</h3><p>有些特征虽然也像无序特征那样只取限定的几个值，但是这些值之间有顺序的含义。例如一个人的状态status有三种取值：bad, normal, good，显然bad &lt; normal &lt; good。</p>
<p>当然，对有序特征最简单的处理方式是忽略其中的顺序关系，把它看成无序的，这样我们就可以使用处理无序特征的方式来处理它。在实际问题中，这种处理方式其实用的很多。</p>
<p>当然有些问题里有序可能会很重要，这时候就不应该把其中的顺序关系丢掉。一般的表达方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status取值    向量表示</span><br><span class="line">bad     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">normal  (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">good    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面这种表达方式很巧妙地利用递进表达了值之间的顺序关系。</p>
<h2 id="中级篇">中级篇</h2><hr>
<p>最容易让人掉以轻心的，往往就是大家觉得最简单的事。在特征处理中，最容易让刚入门同学忽略的，是对连续特征的处理方式。</p>
<p>以线性分类器Linear Regression (LinearReg)为例，它是通过特征的线性加权来预测因变量y：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">y</span>=<span class="string">wTx</span></span><br></pre></td></tr></table></figure></p>
<p>但大部分实际情况下，y与x都不会是这么简单的线性关系，甚至连单调关系都不会有。举个只有一个特征的例子，如果y与x的实际关系如下图：</p>
<p><img src="/images/algo/nonlinear_function1.png" alt=""></p>
<p>那么直接把x扔进LinearReg模型是怎么也得不到好结果的。很多人会想着既然线性分类器搞不定，那就直接找个非线性的好了，比如高斯核的SVM。我们确实可以通过这种简单换算法的方式解决这个简单的问题。但对于很多实际问题（如广告点击率预测），往往特征非常多，这时候时间约束通常不允许我们使用很复杂的非线性分类器。这也是为什么算法发展这么多年，广告点击率预测最常用的方法还是Logistic Regression (LogisticReg)。</p>
<p>对于上面这个问题，有没有什么办法使得LinearReg也能处理得不错？当然是有，就是对原始特征x做转化，把原来的非线性关系转化为线性关系。</p>
<h3 id="方法一：离散化">方法一：离散化</h3><p>最常用的转化方式是对x做离散化(discretization)，也就是把原来的值分段，转化成一个取值为0或1的向量。原始值落在某个段里，向量中此段对应的元素就为1，否则为0。</p>
<p>离散化的目标是y与转化后向量里的每个元素都保持比较好的线性关系。<br>比如取离散点{0.5,1.5,2.5}，通过判断x属于(−∞,0.5)，[0.5,1.5)，[1.5,2.5)，[2.5,+∞)中哪段来把它离散化为4维的向量。下面是一些例子的离散结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始值x    离散化后的值</span><br><span class="line"><span class="number">0.1</span>     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">1.3</span>     (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">3.2</span>     (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">5.8</span>     (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>离散化方法的关键是怎么确定分段中的离散点。下面是常用的选取离散点的方法：</p>
<p>a. 等距离离散：顾名思义，就是离散点选取等距点。我们上面对x取离散点{0.5,1.5,2.5}就是一种等距离散，见下图。图中垂直的灰线代表离散点。</p>
<p><img src="/images/algo/nonlinear_function2.png" alt=""></p>
<p>b. 等样本点离散：选取的离散点保证落在每段里的样本点数量大致相同，见下图。</p>
<p><img src="/images/algo/nonlinear_function3.png" alt=""></p>
<p>c. 画图观察趋势：以x为横坐标，y为纵坐标，画图，看曲线的趋势和拐点。通过观察下面的图我们发现可以利用3条直线（红色直线）来逐段近似原来的曲线。把离散点设为两条直线相交的各个点，我们就可以把x离散化为长度为3的向量。</p>
<p><img src="/images/algo/nonlinear_function4.png" alt=""></p>
<p>上面介绍的这种离散化为0/1向量的方法有个问题，它在离散时不会考虑到具体的x到离散边界的距离。比如等距离散中取离散点为{0.5,1.5,2.5}，那么1.499，1.501和2.49分别会离散为(0, 1, 0, 0)，(0, 0, 1, 0)和(0, 0, 1, 0)。1.499和1.501很接近，可是就因为这种强制分段的离散导致它们离散的结果差距很大。</p>
<p>针对上面这种硬离散的一种改进就是使用软离散，也就是在离散时考虑到x与附近离散点的距离，离散出来的向量元素值可以是0/1之外的其他值。有兴趣的同学可以去ESL1这本书中找点感觉。</p>
<h3 id="方法二：函数变换">方法二：函数变换</h3><p>函数变换直接把原来的特征通过非线性函数做变换，然后把原来的特征，以及变换后的特征一起加入模型进行训练。常用的变换函数见下表，不过其实你可以尝试任何函数。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用非线性函数f<span class="params">(x)</span> x的取值范围</span><br><span class="line">xα; α∈<span class="params">(−∞,+∞)</span>   <span class="params">(−∞,+∞)</span></span><br><span class="line"><span class="built_in">log</span><span class="params">(x)</span>          <span class="params">(<span class="number">0</span>,+∞)</span></span><br><span class="line"><span class="built_in">log</span><span class="params">(x1−x)</span>       <span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法操作起来很简单，但记得对新加入的特征做归一化。</p>
<p>对于我们前面的问题，只要把x2，x3也作为特征加入即可，因为实际上y就是x的一个三次多项式。</p>
<h2 id="高级篇">高级篇</h2><hr>
<h3 id="笛卡尔乘积">笛卡尔乘积</h3><p>我们可以使用笛卡尔乘积的方式来组合2个或更多个特征。比如有两个类别特征color和light，它们分别可以取值为red，green，blue和on, off。这两个特征各自可以离散化为3维和2维的向量。对它们做笛卡尔乘积转化，就可以组合出长度为6的特征，它们分别对应着原始值对(red, on)，(red, off)，(green, on)，(green, off)，(blue, on)，(blue, off)。下面的矩阵表达方式更清楚地说明了这种组合。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">X</span>       <span class="built_in">on</span>  <span class="built_in">off</span></span><br><span class="line">red      </span><br><span class="line">green        </span><br><span class="line">blue</span><br></pre></td></tr></table></figure></p>
<p>对于3个特征的笛卡尔乘积组合，可以表达为立方的形式。更多特征的组合依次类推。 这个方法也可以直接用于连续特征与类别特征之间的组合，只要把连续特征看成是1维的类别特征就好了，这时候组合后特征对应的值就不是0/1了，而是连续特征的取值。</p>
<h3 id="离散化续篇">离散化续篇</h3><p>在上节中我已经介绍了一些常用的离散化单个连续特征的方法，其中一个是画图观察趋势。画图观察趋势的好处是直观、可解释性强，坏处是很麻烦。当要离散化的特征很多时，这种方法可操作性较差。</p>
<p>机器学习中有个很好解释，速度也不错的模型——决策树模型。大白话说决策树模型就是一大堆的if else。它天生就可以对连续特征分段，所以把它用于离散化连续特征合情合理。我称这种方法为决策树离散化方法。例如Gmail在对信件做重要性排序时就使用了决策树离散化方法2。</p>
<p>决策树离散化方法通常也是每次离散化一个连续特征，做法如下：</p>
<p>单独用此特征和目标值y训练一个决策树模型，然后把训练获得的模型内的特征分割点作为离散化的离散点。<br>这种方法当然也可以同时离散化多个连续特征，但是操作起来就更复杂了，实际用的不多。</p>
<h3 id="核方法">核方法</h3><p>核方法经常作为线性模型的一种推广出现。以线性回归模型为例，它对应的核方法如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fθ(x)=∑θ<span class="function"><span class="title">iK</span><span class="params">(x,xi)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中{xi}=1为训练样本点，K(xi,xj)为核函数，比如常用的高斯核函数为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">K</span><span class="params">(xi,xj)</span></span>=<span class="function"><span class="title">exp</span><span class="params">(−exp(∥xi−xj∥, <span class="number">2</span>)</span></span>/<span class="number">2</span>*<span class="function"><span class="title">exp</span><span class="params">(h,<span class="number">2</span>)</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>如果我们把上面模型里的{K(x,xi)}=1看成特征，而θ看成模型参数的话，上面的模型仍旧是个线性模型。所以可以认为核方法只是特征函数变换的一种方式。</p>
<p>当然，如果把核函数K(xi,xj)看成一种相似度的话，那上面的模型就是kNN模型了，或者叫做加权平均模型也可以。因为核方法在预测时也要用到训练样本点，耗内存且计算量大，所以在数据量较大的实际问题中用的并不多。到此，我已经介绍了不少针对单个特征的处理方法。这些处理方法很难说哪个好哪个不好。有些问题这个好，有些问题那个好，也没什么绝招能直接判断出哪种方法能适合哪些问题。唯一的招就是：</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processin]]>
    </summary>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Feature hashing]]></title>
    <link href="http://www.notehub.cn/2015/09/25/algo/ml/feature_hashing/"/>
    <id>http://www.notehub.cn/2015/09/25/algo/ml/feature_hashing/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2015-09-25T14:43:22.000Z</updated>
    <content type="html"><![CDATA[<p>In machine learning, feature hashing, also known as the hashing trick(by analogy to the kernel trick), is a fast and space-efficient way of vectorizing features, i.e. turning arbitrary features into indices in a vector or matrix. It works by applying a hash function to the features and using their hash values as indices directly, rather than looking the indices up in an associative array.</p>
<h3 id="Motivating_example">Motivating example</h3><p>In a typical document classification task, the input to the machine learning algorithm (both during learning and classification) is free text. From this, a bag of words (BOW) representation is constructed: the individual tokens are extracted and counted, and each distinct token in the training set defines a feature (independent variable) of each of the documents in both the training and test sets.</p>
<p>Machine learning algorithms, however, are typically defined in terms of numerical vectors. Therefore, the bags of words for a set of documents is regarded as a term-document matrix where each row is a single document, and each column is a single feature/word; the entry i, j in such a matrix captures the frequency (or weight) of the j’th term of the vocabulary in document i. (An alternative convention swaps the rows and columns of the matrix, but this difference is immaterial.) Typically, these vectors are extremely sparse.</p>
<p>The common approach is to construct, at learning time or prior to that, a dictionary representation of the vocabulary of the training set, and use that to map words to indices. Hash tables and tries are common candidates for dictionary implementation. E.g., the three documents</p>
<p>John likes to watch movies.<br>Mary likes movies too.<br>John also likes football.<br>can be converted, using the dictionary<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Term    Index</span><br><span class="line">John    <span class="number">1</span></span><br><span class="line">likes   <span class="number">2</span></span><br><span class="line">to      <span class="number">3</span></span><br><span class="line">watch   <span class="number">4</span></span><br><span class="line">movies  <span class="number">5</span></span><br><span class="line">Mary    <span class="number">6</span></span><br><span class="line">too     <span class="number">7</span></span><br><span class="line">also    <span class="number">8</span></span><br><span class="line">football9</span><br></pre></td></tr></table></figure></p>
<p>to the term-document matrix</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>(Punctuation was removed, as is usual in document classification and clustering.)</p>
<p>The problem with this process is that such dictionaries take up a large amount of storage space and grow in size as the training set grows. On the contrary, if the vocabulary is kept fixed and not increased with a growing training set, an adversary may try to invent new words or misspellings that are not in the stored vocabulary so as to circumvent a machine learned filter. This difficulty is why feature hashing has been tried for spam filtering at Yahoo! Research.</p>
<p>Note that the hashing trick isn’t limited to text classification and similar tasks at the document level, but can be applied to any problem that involves large (perhaps unbounded) numbers of features.</p>
<h3 id="Feature_vectorization_using_the_hashing_trick">Feature vectorization using the hashing trick</h3><p>Instead of maintaining a dictionary, a feature vectorizer that uses the hashing trick can build a vector of a pre-defined length by applying a hash function h to the features (e.g., words) in the items under consideration, then using the hash values directly as feature indices and updating the resulting vector at those indices:</p>
<p> function hashing_vectorizer(features : array of string, N : integer):<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">x :</span>= <span class="keyword">new</span> vector[N]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> <span class="string">features:</span></span><br><span class="line">    <span class="string">h :</span>= hash(f)</span><br><span class="line">    x[h mod N] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>It has been suggested that a second, single-bit output hash function ξ be used to determine the sign of the update value, to counter the effect of hash collisions. If such a hash function is used, the algorithm becomes</p>
<p> function hashing_vectorizer(features : array of string, N : integer):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="keyword">new</span> <span class="built_in">vector</span>[N]</span><br><span class="line"><span class="keyword">for</span> f in features:</span><br><span class="line">    h := hash(f)</span><br><span class="line">    idx := h mod N</span><br><span class="line">    <span class="keyword">if</span> ξ(f) == <span class="number">1</span>:</span><br><span class="line">        x[idx] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[idx] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>The above pseudocode actually converts each sample into a vector. An optimized version would instead only generate a stream of (h,ξ) pairs and let the learning and prediction algorithms consume such streams; a linear model can then be implemented as a single hash table representing the coefficient vector.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>In machine learning, feature hashing, also known as the hashing trick(by analogy to the kernel trick), is a fast and space-efficient way ]]>
    </summary>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习资料大汇总]]></title>
    <link href="http://www.notehub.cn/2015/09/23/algo/ml/"/>
    <id>http://www.notehub.cn/2015/09/23/algo/ml/</id>
    <published>2015-09-22T16:00:00.000Z</published>
    <updated>2015-09-23T05:09:18.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/other/ml.jpg" alt=""></p>
<p>注：本页面主要针对想快速上手机器学习而又不想深入研究的同学，对于专门的researcher，建议直接啃PRML，ESL，MLAPP以及你相应方向的书（比如Numerical Optimization，Graphic Model等），另外就是Follow牛会牛paper，如果谁有兴趣也可以一起来整理个专业的汇总页。本页面将持续更新，敬请关注，如有推荐的文章请留言，谢谢！</p>
<h3 id="开源工具">开源工具</h3><hr>
<p><a href="http://www.52ml.net/12043.html" target="_blank" rel="external">机器学习的开源工具</a><br><a href="http://www.52ml.net/13547.html" target="_blank" rel="external">Python机器学习库</a><br><a href="http://www.52ml.net/13002.html" target="_blank" rel="external">C++矩阵运算库推荐</a></p>
<h3 id="公开课">公开课</h3><hr>
<ul>
<li>Machine Learning | Coursera Andrew NG在coursera上的课，难度比公开课略低，适合入门</li>
<li>斯坦福大学公开课 ：机器学习课程 Andrew NG在学校里面的课程，网易公开课有中英文字幕，可以配合笔记来看</li>
<li>CMU机器学习系主任Tom Mitchell院士机器学习课程视频及课件（英文）</li>
<li>机器学习|加州理工，老师是Yaser Abu-Mostafa，会从最基本的理论开始，为你构建机器学习的基础。</li>
<li>机器学习基石 如果想听中文课程，台湾大学的这门就很合适，友情提示，台大的课程基本上都可以加快语速来听，原因你懂的</li>
<li>神经网络|多伦多大学 鼎鼎大名的Geoffrey Hinton ，这门课着实不容错过</li>
<li>凸优化课程|斯坦福 授课老师是凸优化经典教材的作者Stephen Boyd！有难度有挑战！</li>
<li>概率图模型  coursera的另外一个创始人，Daphne Koller的课程，值得一提的是，Koller因提出了Probabilistic Relational Models拿到了2001年的IJCAI Computers and Thought Award</li>
<li>统计学习|斯坦福 授课老师是ESL作者 ，还有同学把视频放在了百度网盘上～ 这个更快一些</li>
</ul>
<h3 id="1-_机器学习入门篇">1. 机器学习入门篇</h3><h4 id="1-1_机器学习介绍">1.1 机器学习介绍</h4><ul>
<li>机器学习-维基百科  Machine Learning-Wikipedia</li>
<li>机器学习简史</li>
<li>规则与机器学习 不建议为了机器学习而机器学习，对于初学者应该是先规则再机器学习，规则直观，可以深入理解领域知识和特征，要记住一个机器学习的专家必须首先是该领域知识的专家。</li>
<li>贝叶斯思想 MLAPP 第5章 Bayesian statistics 第6章 Frequentist statistics 机器学习第6章 贝叶斯学习</li>
<li>监督学习 ESL 第2章 Overview of Supervised Learning</li>
</ul>
<h4 id="1-2_书籍">1.2 书籍</h4><ul>
<li>《统计学习方法》 第1章 统计学习方法概论</li>
<li>《机器学习》（Mitchell） 第1章 引言</li>
<li>PRML 第1章 Introduction</li>
<li>MLAPP 第1章 Introduction 第2章 Probability</li>
<li>ESL 第1章 Introduction</li>
<li>Some Notes on Applied Mathematics for Machine (选修)</li>
<li>Machine Learning Textbook minireviews</li>
<li>List of Cool Machine Learning Books</li>
</ul>
<h4 id="1-3_数学基础">1.3 数学基础</h4><ul>
<li>线性代数：公开课： 线性代数；推荐文章 ： 线性代数的本质，</li>
<li>概率论：公开课： 概率课|台大 叶老师为人风趣幽默，课程也比较简单，容易听进去</li>
<li>书籍：MLAPP第二章</li>
<li>微积分：公开课：单变量微积分|MIT 多变量微积分|MIT</li>
</ul>
<p>——————————————-</p>
<h4 id="1-4_LDA">1.4 LDA</h4><ul>
<li>LDA最佳学习资料汇总</li>
</ul>
<h4 id="1-4_Spectral_Clustering">1.4 Spectral Clustering</h4><ul>
<li>Spectral Clustering最佳学习资料汇总</li>
</ul>
<h4 id="1-5_图像处理">1.5 图像处理</h4><ul>
<li>图像处理和计算机视觉中的经典论文</li>
</ul>
<h4 id="2_线性回归模型">2 线性回归模型</h4><ul>
<li>PRML 第3章 Linear Models for Regression</li>
<li>MLAPP 第7章 Linear Regression 第13章 Sparse Linear Models</li>
<li>ESL 第3章 Linear Method for Regression</li>
</ul>
<h4 id="3_线性分类模型">3 线性分类模型</h4><ul>
<li>PRML 第4章 Linear Models for Classification</li>
<li>MLAPP 第8章 Logistic Regression 第9章 Generalized Linear Models and the exponential family</li>
<li>ESL 第4章 Linear Method for Classification</li>
<li>统计机器学习 第6章 逻辑斯谛回归与最大熵模型</li>
</ul>
<h4 id="4_神经网络">4 神经网络</h4><ul>
<li>PRML 第5章 Neural Networks</li>
<li>ESL 第11章 Neural Networks</li>
<li>统计学习方法 第2章 感知机</li>
<li>机器学习 第4章 人工神经网络</li>
</ul>
<h4 id="5_支持向量机">5 支持向量机</h4><ul>
<li>统计学习方法 第7章 支持向量机 (强烈推荐)</li>
<li>PRML 第6章 Kernel Methods 第7章 Sparse Kernel Machine</li>
<li>ESL 第12章 Support Vector Machines and Flexible Discriminants</li>
<li>MLAPP 第14章 Kernels</li>
</ul>
<h4 id="6_图模型">6 图模型</h4><ul>
<li>PRML 第8章 Graphical Models</li>
<li>MLAPP 第10章 Directed graphical models（Bayes nets） 第19章 Undirected Graphical Models（Marcov random fields）第20章 Exact inference for graphical models 第26章 Graphical model structure learning</li>
<li>统计学习方法 第10章 隐马尔可夫模型 第11章 条件随机场</li>
<li>机器学习 6.11 贝叶斯信念网</li>
<li>ESL 第17章 Undirected Graphical Models</li>
<li>Koller 的书</li>
<li>Jordan 的书</li>
</ul>
<h4 id="7_混合模型和EM">7 混合模型和EM</h4><ul>
<li>PRML 第9章 Mixture Models and EM</li>
<li>MLAPP 第11章 Mixture models and the EM algorithm</li>
<li>ESL 8.5 The EM Algorithm</li>
<li>统计学习方法 第9章 EM算法及其推广</li>
</ul>
<h4 id="8_近似推理">8 近似推理</h4><ul>
<li>PRML 第10章 Approximate Inference</li>
<li>MLAPP 第21章 Variational Inference 第22章 More Variational Inference</li>
</ul>
<h4 id="9_采样方法">9 采样方法</h4><ul>
<li>PRML 第11章 Sampling Methods</li>
<li>MLAPP 第23章 Monte Carlo inference 第24章 Markov Chain Monte Carlo (MCMC) inference</li>
<li>ESL 8.6 MCMC for Sampling from Posterior</li>
</ul>
<h4 id="10_PCA">10 PCA</h4><ul>
<li>PRML 第12章 Continuous Latent Variables</li>
<li>MLAPP 第12章 Latent Linear Models</li>
<li>ESL 14.5 Principal Componens， Curves and Surfaces</li>
</ul>
<h4 id="11_HMM">11 HMM</h4><ul>
<li>PRML 13.1 13.2 Hidden Marcov Models</li>
<li>MLAPP 第17章 Marcov and Hidden Marcov Models</li>
</ul>
<h4 id="12_组合模型">12 组合模型</h4><ul>
<li>(投票，boosting，bagging，树模型，model averaging)</li>
<li>PRML 第14章 Combining Models</li>
<li>统计学习方法 第5章 决策树 第8章 提升方法</li>
<li>MLAPP 第16章 Adaptive basis function models</li>
<li>ESL 第15章 Random Forests 第16章 Ensemble Learning 8.7 Bagging 第9章 Additive Models, Trees, and Related Methods 第10章 Boosting and Additive Trees</li>
<li>机器学习 第3章 决策树学习</li>
</ul>
<h4 id="14_聚类">14 聚类</h4><ul>
<li>ESL 14.3 Cluster Analysis</li>
<li>MLAPP 25章 Clustering</li>
<li>PRML 9.1 K-means Clustering</li>
</ul>
<h4 id="15_近邻">15 近邻</h4><ul>
<li>ELS 第13章 Protype Methods and Nearest-Neighbors</li>
</ul>
<h4 id="16_Deep_Learning">16 Deep Learning</h4><ul>
<li><a href="http://deeplearning.net/" target="_blank" rel="external">http://deeplearning.net/</a></li>
<li>Deep Learning Tutorial</li>
<li>MLAPP 第28章 Deep Learning</li>
</ul>
<h4 id="2-2_Deep_Learning教程">2.2 Deep Learning教程</h4><ul>
<li>UFLDL-斯坦福大学Andrew Ng教授“Deep Learning”教程</li>
</ul>
<h3 id="3-_自然语言处理入门篇">3. 自然语言处理入门篇</h3><h4 id="3-1_斯坦福大学自然语言处理公开课">3.1 斯坦福大学自然语言处理公开课</h4><ul>
<li>NLP | 斯坦福  授课教师是 Dan Jurafsky 以及 Christopher Manning，英文不是很有信心的可以参考《斯坦福大学自然语言处理公开课中文解读》</li>
<li>NLP | 哥伦比亚 授课老师是Michael Collins大神</li>
</ul>
<h4 id="3-2_统计机器翻译">3.2 统计机器翻译</h4><ul>
<li>Statistical Machine Translation</li>
<li>统计机器翻译开源软件汇总</li>
</ul>
<p>转自：<a href="http://www.52ml.net/star?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">http://www.52ml.net/star?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/other/ml.jpg" alt=""></p>
<p>注：本页面主要针对想快速上手机器学习而又不想深入研究的同学，对于专门的researcher，建议直接啃PRML，ESL，MLAPP以及你相应方向的书（比如Numerical Opt]]>
    </summary>
    
      <category term="PPTP, vpn" scheme="http://www.notehub.cn/tags/PPTP-vpn/"/>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
</feed>
