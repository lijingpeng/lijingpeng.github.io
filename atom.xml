<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Frank]]></title>
  <subtitle><![CDATA[Li Jingpeng's site]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.notehub.cn/"/>
  <updated>2015-10-26T11:21:48.000Z</updated>
  <id>http://www.notehub.cn/</id>
  
  <author>
    <name><![CDATA[Li Jingpeng]]></name>
    <email><![CDATA[me@lijingpeng.org]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[开发者都应该使用的10个C++11特性]]></title>
    <link href="http://www.notehub.cn/2015/10/26/dev/CPP/cpp11/"/>
    <id>http://www.notehub.cn/2015/10/26/dev/CPP/cpp11/</id>
    <published>2015-10-26T12:19:56.000Z</published>
    <updated>2015-10-26T11:21:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="auto">auto</h3><hr>
<p>在C++11之前，auto关键字用来指定存储期。在新标准中，它的功能变为类型推断。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。各种作用域内声明变量都可以用到它。例如，名空间中，程序块中，或是for循环的初始化语句中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">42</span>;        <span class="comment">// i is an int</span></span><br><span class="line"><span class="keyword">auto</span> l = <span class="number">42L</span>L;      <span class="comment">// l is an long long</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> foo(); <span class="comment">// p is a foo*</span></span><br></pre></td></tr></table></figure></p>
<p>使用auto通常意味着更短的代码（除非你所用类型是int，它会比auto少一个字母）。试想一下当你遍历STL容器时需要声明的那些迭代器（iterator）。现在不需要去声明那些typedef就可以得到简洁的代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = begin(<span class="built_in">map</span>); it != end(<span class="built_in">map</span>); ++it) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，auto不能用来声明函数的返回值。但如果函数有一个尾随的返回类型时，auto是可以出现在函数声明中返回值位置。这种情况下，auto并不是告诉编译器去推断返回类型，而是指引编译器去函数的末端寻找返回值类型。在下面这个例子中，函数的返回值类型就是operator+操作符作用在T1、T2类型变量上的返回值类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">compose</span><span class="params">(T1 t1, T2 t2)</span> -&gt; <span class="title">decltype</span><span class="params">(t1 + t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> t1+t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> v = compose(<span class="number">2</span>, <span class="number">3.14</span>); <span class="comment">// v's type is double</span></span><br></pre></td></tr></table></figure></p>
<h3 id="nullptr">nullptr</h3><hr>
<p>以前都是用0来表示空指针的，但由于0可以被隐式类型转换为整形，这就会存在一些问题。关键字nullptr是std::nullptr_t类型的值，用来指代空指针。nullptr和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="literal">nullptr</span>;   </span><br><span class="line"><span class="keyword">if</span>(p1 == p2) &#123;&#125;</span><br><span class="line">foo(<span class="literal">nullptr</span>);</span><br><span class="line">bar(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">bool</span> f = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="literal">nullptr</span>; <span class="comment">// error: A native nullptr can only be converted to bool or, using reinterpret_cast, to an integral type</span></span><br></pre></td></tr></table></figure></p>
<p>为了向前兼容，0仍然是个合法的空指针值。</p>
<h3 id="Range-based_for_loops_（基于范围的for循环）">Range-based for loops （基于范围的for循环）</h3><hr>
<p>为了在遍历容器时支持”foreach”用法，C++11扩展了for语句的语法。用这个新的写法，可以遍历C类型的数组、初始化列表以及任何重载了非成员的begin()和end()函数的类型。如果你只是想对集合或数组的每个元素做一些操作，而不关心下标、迭代器位置或者元素个数，那么这种foreach的for循环将会非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">map</span>[<span class="string">"one"</span>] = v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kvp : <span class="built_in">map</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; kvp.first &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> v : kvp.second)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr) </span><br><span class="line">&#123;</span><br><span class="line">  e = e*e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="override和final">override和final</h3><hr>
<p>我总觉得 C++中虚函数的设计很差劲，因为时至今日仍然没有一个强制的机制来标识虚函数会在派生类里被改写。vitual关键字是可选的，这使得阅读代码变得很费劲。因为可能需要追溯到继承体系的源头才能确定某个方法是否是虚函数。为了增加可读性，我总是在派生类里也写上virtual关键字，并且也鼓励大家都这么做。即使这样，仍然会产生一些微妙的错误。看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>B::f 按理应当重写 A::f。然而二者的声明是不同的，一个参数是short，另一个是int。因此B::f只是拥有同样名字的另一个函数（重载）而不是重写。当你通过A类型的指针调用f()可能会期望打印出B::f，但实际上则会打出 f(int)而不是f(short) 。另一个很微妙的错误情况：参数相同，但是基类的函数是const的，派生类的函数却不是。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f "</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，这两个函数是重载而不是重写。幸运的是，现在有一种方式能描述你的意图。新标准加入了两个新的标识符（不是关键字）</p>
<p>override，表示函数必须重写基类中的虚函数，如果派生类没有重写到将编译报错。</p>
<p>final，表示派生类不应当重写这个虚函数，如果派生类重写了基类的虚函数将编译报错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>)</span> final </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::g"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">short</span>)</span>  override  </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125;</span><br><span class="line">    <span class="comment">//virtual void g(int) &#123; std::cout &lt;&lt; "A::g" &lt;&lt; std::endl; &#125; // error C3248: “main::A::g”:  声明为“final”的函数无法被“main::B::g”重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::g"</span> &lt;&lt; <span class="built_in">std</span>::endl; &#125; <span class="comment">// 重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Strongly-typed_enums_强类型枚举">Strongly-typed enums 强类型枚举</h3><hr>
<p>传统的C++枚举类型存在一些缺陷：它们会将枚举常量暴露在外层作用域中（这可能导致名字冲突，如果同一个作用域中存在两个不同的枚举类型，但是具有相同的枚举常量就会冲突），而且它们会被隐式转换为整形，无法拥有特定的用户定义类型。</p>
<p>在C++11中通过引入了一个称为强类型枚举的新类型，修正了这种情况。强类型枚举由关键字enum class标识。它不会将枚举常量暴露到外层作用域中，也不会隐式转换为整形，并且拥有用户指定的特定类型（传统枚举也增加了这个性质）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> Options &#123;None, One, All&#125;;</span><br><span class="line">Options o = Options::All;</span><br></pre></td></tr></table></figure>
<h3 id="Smart_Pointers_智能指针">Smart Pointers 智能指针</h3><hr>
<p>已经有成千上万的文章讨论这个问题了，所以我只想说：现在能使用的，带引用计数，并且能自动释放内存的智能指针包括以下几种：</p>
<p>unique_ptr: 如果内存资源的所有权不需要共享，就应当使用这个（它没有拷贝构造函数），但是它可以转让给另一个unique_ptr（存在move构造函数）。</p>
<p>shared_ptr:  如果内存资源需要共享，那么使用这个（所以叫这个名字）。</p>
<p>weak_ptr: 持有被shared_ptr所管理对象的引用，但是不会改变引用计数值。它被用来打破依赖循环（想象在一个tree结构中，父节点通过一个共享所有权的引用(chared_ptr)引用子节点，同时子节点又必须持有父节点的引用。如果这第二个引用也共享所有权，就会导致一个循环，最终两个节点内存都无法释放）。</p>
<p>另一方面，auto_ptr已经被废弃，不会再使用了。</p>
<p>什么时候使用unique_ptr，什么时候使用shared_ptr取决于对所有权的需求，我建议阅读以下的讨论：<a href="http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members" target="_blank" rel="external">http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::unique_ptr&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>));</span><br><span class="line"><span class="built_in">std</span>::unique_ptr&lt;<span class="keyword">int</span>&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// 移交unique指针</span></span><br><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; wp = sp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sp = wp.lock(); <span class="comment">// 提升shared_ptr</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line">sp.reset();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (wp.expired())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expired"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>如果你试图锁定(lock)一个过期（指被弱引用对象已经被释放）的weak_ptr，那你将获得一个空的shared_ptr.</p>
<h3 id="Lambdas">Lambdas</h3><hr>
<p>匿名函数（也叫lambda）已经加入到C++中，并很快异军突起。这个从函数式编程中借来的强大特性，使很多其他特性以及类库得以实现。你可以在任何使用函数对象或者函子(functor)或std::function的地方使用lambda。你可以从这里（<a href="http://msdn.microsoft.com/en-us/library/dd293603.aspx）找到语法说明。" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/dd293603.aspx）找到语法说明。</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::begin(v), <span class="built_in">std</span>::end(v), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(<span class="built_in">std</span>::begin(v), <span class="built_in">std</span>::end(v), is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != <span class="built_in">std</span>::end(v))</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>更复杂的是递归lambda。考虑一个实现Fibonacci函数的lambda。如果你试图用auto来声明，就会得到一个编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [&amp;fib](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);&#125;;</span><br></pre></td></tr></table></figure>
<p>error C3533: ‘auto &amp;’: a parameter cannot have a type that contains ‘auto’<br>error C3531: ‘fib’: a symbol whose type contains ‘auto’ must have an initializer<br>error C3536: ‘fib’: cannot be used before it is initialized<br>error C2064: term does not evaluate to a function taking 1 arguments<br>问题出在auto意味着对象类型由初始表达式决定，然而初始表达式又包含了对其自身的引用，因此要求先知道它的类型，这就导致了无穷递归。解决问题的关键就是打破这种循环依赖，用std::function显式的指定函数类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; lfib = [&amp;lfib](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : lfib(n-<span class="number">1</span>) + lfib(n-<span class="number">2</span>);&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="非成员begin()和end()">非成员begin()和end()</h3><hr>
<p>也许你注意到了，我在前面的例子中已经用到了非成员begin()和end()函数。他们是新加入标准库的，除了能提高了代码一致性，还有助于更多地使用泛型编程。它们和所有的STL容器兼容。更重要的是，他们是可重载的。所以它们可以被扩展到支持任何类型。对C类型数组的重载已经包含在标准库中了。我们还用上一个例子中的代码来说明，在这个例子中我打印了一个数组然后查找它的第一个偶数元素。如果std::vector被替换成C类型数组。代码可能看起来是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">0</span>]+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> begin = &amp;arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">auto</span> end = &amp;arr[<span class="number">0</span>]+<span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(begin, end, is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != end)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>如果使用非成员的begin()和end()来实现，就会是以下这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr), [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line"><span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr), is_odd);</span><br><span class="line"><span class="keyword">if</span>(pos != <span class="built_in">std</span>::end(arr))</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>这基本上和使用std::vecto的代码是完全一样的。这就意味着我们可以写一个泛型函数处理所有支持begin()和end()的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(Iterator begin, Iterator end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::for_each(begin, end, [](<span class="keyword">int</span> n) &#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::endl;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> is_odd = [](<span class="keyword">int</span> n) &#123;<span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> pos = <span class="built_in">std</span>::find_if(begin, end, is_odd);</span><br><span class="line">    <span class="keyword">if</span>(pos != end)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(C c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    bar(<span class="built_in">std</span>::begin(c), <span class="built_in">std</span>::end(c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T(&amp;arr)</span>[N])</span><br><span class="line"></span>&#123;</span><br><span class="line">    bar(<span class="built_in">std</span>::begin(arr), <span class="built_in">std</span>::end(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">foo(arr);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">foo(v);</span><br></pre></td></tr></table></figure>
<h3 id="static_assert和_type_traits">static_assert和 type traits</h3><hr>
<p>static_assert提供一个编译时的断言检查。如果断言为真，什么也不会发生。如果断言为假，编译器会打印一个特殊的错误信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> Size&gt;</span><br><span class="line"><span class="keyword">class</span> Vector</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">static_assert</span>(Size &lt; <span class="number">3</span>, <span class="string">"Size is too small"</span>);</span><br><span class="line">   T _points[Size];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Vector&lt;<span class="keyword">int</span>, <span class="number">16</span>&gt; a1;</span><br><span class="line">   Vector&lt;<span class="keyword">double</span>, <span class="number">2</span>&gt; a2;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>error C2338: Size is too small<br>see reference to class template instantiation ‘Vector<t,size>‘ being compiled<br>   with<br>   [<br>      T=double,<br>      Size=2<br>   ]<br>static_assert和type traits一起使用能发挥更大的威力。type traits是一些class，在编译时提供关于类型的信息。在头文件<type_traits>中可以找到它们。这个头文件中有好几种class: helper class，用来产生编译时常量。type traits class，用来在编译时获取类型信息，还有就是type transformation class，他们可以将已存在的类型变换为新的类型。</type_traits></t,size></p>
<p>下面这段代码原本期望只做用于整数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 t1, T2 t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果有人写出如下代码，编译器并不会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="string">"one"</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>程序会打印出4.14和”e”。但是如果我们加上编译时断言，那么以上两行将产生编译错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 t1, T2 t2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral&lt;T1&gt;::value, <span class="string">"Type T1 must be integral"</span>);</span><br><span class="line">   <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_integral&lt;T2&gt;::value, <span class="string">"Type T2 must be integral"</span>);</span><br><span class="line">   <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>error C2338: Type T2 must be integral<br>see reference to function template instantiation ‘T2 add<int,double>(T1,T2)’ being compiled<br>   with<br>   [<br>      T2=double,<br>      T1=int<br>   ]<br>error C2338: Type T1 must be integral<br>see reference to function template instantiation ‘T1 add<const char*,int="">(T1,T2)’ being compiled<br>   with<br>   [<br>      T1=const char *,<br>      T2=int<br>   ]</const></int,double></p>
<h3 id="Move_semantics_（Move语义）">Move semantics （Move语义）</h3><hr>
<p>这是C++11中所涵盖的另一个重要话题。就这个话题可以写出一系列文章，仅用一个段落来说明显然是不够的。因此在这里我不会过多的深入细节，如果你还不是很熟悉这个话题，我鼓励你去阅读更多地资料。C++11加入了右值引用(value reference)的概念（用&amp;&amp;标识），用来区分对左值和右值的引用。左值就是一个有名字的对象，而右值则是一个无名对象（临时对象）。move语义允许修改右值（以前右值被看作是不可修改的，等同于const T&amp;类型）。C++的class或者struct以前都有一些隐含的成员函数：默认构造函数（仅当没有显示定义任何其他构造函数时才存在），拷贝构造函数，析构函数还有拷贝赋值操作符。拷贝构造函数和拷贝赋值操作符提供bit-wise的拷贝（浅拷贝），也就是逐个bit拷贝对象。也就是说，如果你有一个类包含指向其他对象的指针，拷贝时只会拷贝指针的值而不会管指向的对象。在某些情况下这种做法是没问题的，但在很多情况下，实际上你需要的是深拷贝，也就是说你希望拷贝指针所指向的对象。而不是拷贝指针的值。这种情况下，你需要显示地提供拷贝构造函数与拷贝赋值操作符来进行深拷贝。如果你用来初始化或拷贝的源对象是个右值（临时对象）会怎么样呢？你仍然需要拷贝它的值，但随后很快右值就会被释放。这意味着产生了额外的操作开销，包括原本并不需要的空间分配以及内存拷贝。现在说说move constructor和move assignment operator。这两个函数接收T&amp;&amp;类型的参数，也就是一个右值。在这种情况下，它们可以修改右值对象，例如“偷走”它们内部指针所指向的对象。举个例子，一个容器的实现（例如vector或者queue）可能包含一个指向元素数组的指针。当用一个临时对象初始化一个对象时，我们不需要分配另一个数组，从临时对象中把值复制过来，然后在临时对象析构时释放它的内存。我们只需要将指向数组内存的指针值复制过来，由此节约了一次内存分配，一次元数组的复制以及后来的内存释放。以下代码实现了一个简易的buffer。这个buffer有一个成员记录buffer名称（为了便于以下的说明），一个指针（封装在unique_ptr中）指向元素为T类型的数组，还有一个记录数组长度的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer </span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// default constructor</span></span><br><span class="line">   Buffer():</span><br><span class="line">      _size(<span class="number">16</span>),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[<span class="number">16</span>])</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">size_t</span> size):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[size])</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(<span class="keyword">new</span> T[copy._size])</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Buffer&amp; copy)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> != ©)</span><br><span class="line">      &#123;</span><br><span class="line">         _name = copy._name;</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span>(_size != copy._size)</span><br><span class="line">         &#123;</span><br><span class="line">            _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">            _size = copy._size;</span><br><span class="line">            _buffer = _size &gt; <span class="number">0</span> &gt; <span class="keyword">new</span> T[_size] : <span class="literal">nullptr</span>;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         T* source = copy._buffer.get();</span><br><span class="line">         T* dest = _buffer.get();</span><br><span class="line">         <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):</span><br><span class="line">      _name(<span class="built_in">std</span>::move(temp._name)),</span><br><span class="line">      _size(temp._size),</span><br><span class="line">      _buffer(<span class="built_in">std</span>::move(temp._buffer))</span><br><span class="line">   &#123;</span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer&amp;&amp; temp)</span><br><span class="line">   &#123;</span><br><span class="line">      assert(<span class="keyword">this</span> != &amp;temp); <span class="comment">// assert if this is not a temporary</span></span><br><span class="line">  </span><br><span class="line">      _buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      _size = temp._size;</span><br><span class="line">      _buffer = <span class="built_in">std</span>::move(temp._buffer);</span><br><span class="line">  </span><br><span class="line">      _name = <span class="built_in">std</span>::move(temp._name);</span><br><span class="line">  </span><br><span class="line">      temp._buffer = <span class="literal">nullptr</span>;</span><br><span class="line">      temp._size = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Buffer&lt;T&gt; getBuffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) </span><br><span class="line">&#123;</span><br><span class="line">   Buffer&lt;T&gt; b(name, <span class="number">128</span>);</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b1;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b2(<span class="string">"buf2"</span>, <span class="number">64</span>);</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b3 = b2;</span><br><span class="line">   Buffer&lt;<span class="keyword">int</span>&gt; b4 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf4"</span>);</span><br><span class="line">   b1 = getBuffer&lt;<span class="keyword">int</span>&gt;(<span class="string">"buf5"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的copy constructor以及copy assignment operator大家应该很熟悉了。C++11中新增的是move constructor以及move assignment operator，这两个函数根据上文所描述的move语义实现。如果你运行这段代码，你就会发现b4构造时，move constructor会被调用。同样，对b1赋值时，move assignment operator会被调用。原因就在于getBuffer()的返回值是一个临时对象——也就是右值。你也许注意到了，move constuctor中当我们初始化变量name和指向buffer的指针时，我们使用了std::move。name实际上是一个string，std::string实现了move语义。std::unique_ptr也一样。但是如果我们写_name(temp._name)，那么copy constructor将会被调用。不过对于_buffer来说不能这么写，因为std::unique_ptr没有copy constructor。但为什么std::string的move constructor此时没有被调到呢？这是因为虽然我们使用一个右值调用了Buffer的move constructor，但在这个构造函数内，它实际上是个左值。为什么？因为它是有名字的——“temp”。一个有名字的对象就是左值。为了再把它变为右值（以便调用move constructor)必须使用std::move。这个函数仅仅是把一个左值引用变为一个右值引用。更新：虽然这个例子是为了说明如何实现move constructor以及move assignment operator，但具体的实现方式并不是唯一的。某同学提供了另一种可能的实现。为了方便查看，我把它也列在下面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> Buffer</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>          _name;</span><br><span class="line">   <span class="keyword">size_t</span>               _size;</span><br><span class="line">   <span class="built_in">std</span>::unique_ptr&lt;T[]&gt; _buffer;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = <span class="string">""</span>, <span class="keyword">size_t</span> size = <span class="number">16</span>):</span><br><span class="line">      _name(name),</span><br><span class="line">      _size(size),</span><br><span class="line">      _buffer(size? <span class="keyword">new</span> T[size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// copy constructor</span></span><br><span class="line">   Buffer(<span class="keyword">const</span> Buffer&amp; copy):</span><br><span class="line">      _name(copy._name),</span><br><span class="line">      _size(copy._size),</span><br><span class="line">      _buffer(copy._size? <span class="keyword">new</span> T[copy._size] : <span class="literal">nullptr</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      T* source = copy._buffer.get();</span><br><span class="line">      T* dest = _buffer.get();</span><br><span class="line">      <span class="built_in">std</span>::copy(source, source + copy._size, dest);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// copy assignment operator</span></span><br><span class="line">   Buffer&amp; <span class="keyword">operator</span>=(Buffer copy)</span><br><span class="line">   &#123;</span><br><span class="line">       swap(*<span class="keyword">this</span>, copy);</span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// move constructor</span></span><br><span class="line">   Buffer(Buffer&amp;&amp; temp):Buffer()</span><br><span class="line">   &#123;</span><br><span class="line">      swap(*<span class="keyword">this</span>, temp);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Buffer&amp; first, Buffer&amp; second)</span> <span class="keyword">noexcept</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">       swap(first._name  , second._name);</span><br><span class="line">       swap(first._size  , second._size);</span><br><span class="line">       swap(first._buffer, second._buffer);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="auto">auto</h3><hr>
<p>在C++11之前，auto关键字用来指定存储期。在新标准中，它的功能变为类型推断。auto现在成了一个类型的占位符，通知编译器去根据初始化代码推断所声明变量的真实类型。各种作用域内声明变量都可以用到它。例如，名空间中，]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个故事讲清楚 NIO]]></title>
    <link href="http://www.notehub.cn/2015/10/26/dev/about_nio/"/>
    <id>http://www.notehub.cn/2015/10/26/dev/about_nio/</id>
    <published>2015-10-26T08:19:56.000Z</published>
    <updated>2015-10-26T08:56:33.000Z</updated>
    <content type="html"><![CDATA[<p>假设某银行只有10个职员, 该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；<br>2） 职员审核（1分钟）；<br>3） 职员叫保安去金库取钱（3分钟）；<br>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。<br>我们看看银行不同的工作方式对其工作效率到底有何影响。</p>
<h3 id="1_BIO方式">1 BIO方式</h3><p>每来一个顾客，马上由一位职员来接待处理，并且这个职员需要负责以上4个完整流程。当超过10个顾客时，剩余的顾客需要排队等候。</p>
<p>我们算算这个银行一个小时到底能处理多少顾客？一个职员处理一个顾客需要10分钟（5+1+3+1）时间，一个小时（60分钟）能处理6个顾客，一共10个职员，那就是只能处理60个顾客。</p>
<p>可以看到银行职员的工作状态并不饱和，比如在第1步，其实是处于等待中。</p>
<p>这种工作其实就是BIO，每次来一个请求（顾客），就分配到线程池中由一个线程（职员）处理，如果超出了线程池的最大上限（10个），就扔到队列等待 。</p>
<h3 id="2_NIO方式">2 NIO方式</h3><p>如何提高银行的吞吐量呢？</p>
<p>思路：分而治之，将任务拆分开来，由专门的人负责专门的任务。</p>
<p>具体来讲，银行专门指派一名职员A，A的工作就是每当有顾客到银行，他就递上表格让顾客填写，每当有顾客填好表后，A就将其随机指派给剩余的9名职员完成后续步骤。</p>
<p>我们计算下这种工作方式下银行一个小时到底能处理多少顾客？</p>
<p>假设顾客非常多，职员A的工作处于饱和中，他不断的将填好表的顾客带到柜台处理，柜台一个职员5分钟能处理完一个顾客，一个小时9名职员能处理：9*（60/5）=108。</p>
<p>可见工作方式的转变能带来效率的极大提升。</p>
<p>这种工作方式其实就NIO的思路。下图是非常经典的NIO说明图，mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，对具体的业务处理功能，其扔给worker线程池完成。</p>
<p>可以看到典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。不同的线程干专业的事情，最终每个线程都没空着，系统的吞吐量自然就上去了。</p>
<h3 id="3_异步方式">3 异步方式</h3><p>第二种工作方式有没有什么可以提高的地方呢？</p>
<p>仔细查看可发现第3步骤这3分钟柜台职员是在等待中度过的，那怎么能让柜台职员保持满负荷呢？</p>
<p>还是分而治之的思路，指派1个职员B来专门负责第3步骤。每当柜台员工完成第2步时，就通知职员B来负责与保安沟通取钱。这时候柜台员工可以继续处理下一个顾客。当职员B拿到钱之后，他会怎么办呢？他会通知顾客钱已经到柜台了，让顾客重新排队处理，当柜台职员再次服务该顾客时，发现该顾客前3步已经完成，直接执行第4步即可。</p>
<p>我们可以算算通过这种方法，银行的吞吐量能提高到多少。</p>
<p>假设职员B的工作非常饱和，柜台一个职员现在2分钟能处理完一个顾客，一个小时8名职员能处理：8*（60/2）=240。</p>
<p>在当今web服务中，经常需要通过RPC或者Http等方式调用第三方服务，这里对应的就是第3步，如果这步耗时较长，通过异步方式将能极大降低资源使用率。</p>
<p>jetty Continuations 就实现了上述异步方式，有兴趣的同学可以去尝试下（<a href="http://wiki.eclipse.org/Jetty/Feature/Continuations）。" target="_blank" rel="external">http://wiki.eclipse.org/Jetty/Feature/Continuations）。</a></p>
<p>NIO+异步的方式能让少量的线程（资源）做大量的事情，这适用于很多应用场景，比如代理服务、api服务、长连接服务等等，这些应用如果用同步方式将耗费大量机器资源。尽管NIO+异步能提高系统吞吐量，但其并不能让一个请求的等待时间下降，相反可能会增加等待时间。</p>
<h3 id="4_小结">4 小结</h3><p>总结就一句：“分而治之，将任务拆分开来，由专门的人负责专门的任务”，这不仅在计算机领域生效，在整个社会领域都生效。</p>
<p>src: <a href="http://blog.jobbole.com/88984/" target="_blank" rel="external">http://blog.jobbole.com/88984/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设某银行只有10个职员, 该银行的业务流程分为以下4个步骤：</p>
<p>1） 顾客填申请表（5分钟）；<br>2） 职员审核（1分钟）；<br>3） 职员叫保安去金库取钱（3分钟）；<br>4） 职员打印票据，并将钱和票据返回给顾客（1分钟）。<br>我们看看银行不同]]>
    </summary>
    
      <category term="nio" scheme="http://www.notehub.cn/tags/nio/"/>
    
      <category term="dev" scheme="http://www.notehub.cn/categories/dev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[标准C++中的string类的用法总结]]></title>
    <link href="http://www.notehub.cn/2015/10/23/dev/CPP/cpp_string/"/>
    <id>http://www.notehub.cn/2015/10/23/dev/CPP/cpp_string/</id>
    <published>2015-10-23T12:19:56.000Z</published>
    <updated>2015-10-23T05:45:21.000Z</updated>
    <content type="html"><![CDATA[<p>#include <string>// 注意是<string>，不是<string.h>，带.h的是C语言中的头文件<br>using  std::string;<br>using  std::wstring;<br>using namespace std;</string.h></string></string></p>
<p>下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。<br>string和wstring的用法是一样的，以下只用string作介绍：</p>
<p>string类的构造函数：</p>
<p>string(const char *s);    //用c字符串s初始化<br>string(int n,char c);     //用n个字符c初始化<br>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p>
<p>string类的字符操作：<br>const char &amp;operator<a href="int n"></a>const;<br>const char &amp;at(int n)const;<br>char &amp;operator<a href="int n"></a>;<br>char &amp;at(int n);<br>operator[]和at()均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。<br>const char <em>data()const;//返回一个非null终止的c字符数组<br>const char </em>c_str()const;//返回一个以null终止的c字符串<br>int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p>
<p>string的特性描述:<br>int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）<br>int max_size()const;    //返回string对象中可存放的最大字符串的长度<br>int size()const;        //返回当前字符串的大小<br>int length()const;       //返回当前字符串的长度<br>bool empty()const;        //当前字符串是否为空<br>void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</p>
<p>string类的输入输出操作:<br>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。<br>函数getline(istream &amp;in,string &amp;s);用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p>
<p>string的赋值：<br>string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(const char <em>s);//用c类型字符串s赋值<br>string &amp;assign(const char </em>s,int n);//用c字符串s开始的n个字符赋值<br>string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串<br>string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串<br>string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串<br>string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</p>
<p>string的连接：<br>string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾<br>string &amp;append(const char <em>s);            //把c类型字符串s连接到当前字符串结尾<br>string &amp;append(const char </em>s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾<br>string &amp;append(const string &amp;s);    //同operator+=()<br>string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾<br>string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c<br>string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</p>
<p>string的比较：<br>bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等<br>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br>int compare(const string &amp;s) const;//比较当前字符串和s的大小<br>int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小<br>int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中<br>//pos2开始的n2个字符组成的字符串的大小<br>int compare(const char <em>s) const;<br>int compare(int pos, int n,const char </em>s) const;<br>int compare(int pos, int n,const char *s, int pos2) const;<br>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p>
<p>string的子串：<br>string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</p>
<p>string的交换：<br>void swap(string &amp;s2);    //交换当前字符串与s2的值</p>
<p>string类的查找函数：<br>int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置<br>int find(const char <em>s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>int find(const char </em>s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置<br>int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置<br>//查找成功时返回所在位置，失败返回string::npos的值<br>int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置<br>int rfind(const char <em>s, int pos = npos) const;<br>int rfind(const char </em>s, int pos, int n = npos) const;<br>int rfind(const string &amp;s,int pos = npos) const;<br>//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值<br>int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置<br>int find_first_of(const char <em>s, int pos = 0) const;<br>int find_first_of(const char </em>s, int pos, int n) const;<br>int find_first_of(const string &amp;s,int pos = 0) const;<br>//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos<br>int find_first_not_of(char c, int pos = 0) const;<br>int find_first_not_of(const char <em>s, int pos = 0) const;<br>int find_first_not_of(const char </em>s, int pos,int n) const;<br>int find_first_not_of(const string &amp;s,int pos = 0) const;<br>//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos<br>int find_last_of(char c, int pos = npos) const;<br>int find_last_of(const char <em>s, int pos = npos) const;<br>int find_last_of(const char </em>s, int pos, int n = npos) const;<br>int find_last_of(const string &amp;s,int pos = npos) const;<br>int find_last_not_of(char c, int pos = npos) const;<br>int find_last_not_of(const char <em>s, int pos = npos) const;<br>int find_last_not_of(const char </em>s, int pos, int n) const;<br>int find_last_not_of(const string &amp;s,int pos = npos) const;<br>//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</p>
<p>string类的替换函数：<br>string &amp;replace(int p0, int n0,const char <em>s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const char </em>s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符<br>string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s<br>string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符<br>string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c<br>string &amp;replace(iterator first0, iterator last0,const char <em>s);//把[first0，last0）之间的部分替换为字符串s<br>string &amp;replace(iterator first0, iterator last0,const char </em>s, int n);//把[first0，last0）之间的部分替换为s的前n个字符<br>string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s<br>string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c<br>string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</p>
<p>string类的插入函数：<br>string &amp;insert(int p0, const char <em>s);<br>string &amp;insert(int p0, const char </em>s, int n);<br>string &amp;insert(int p0,const string &amp;s);<br>string &amp;insert(int p0,const string &amp;s, int pos, int n);<br>//前4个函数在p0位置插入字符串s中pos开始的前n个字符<br>string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c<br>iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置<br>void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符<br>void insert(iterator it, int n, char c);//在it处插入n个字符c</p>
<p>string类的删除函数<br>iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置<br>iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置<br>string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</p>
<p>string类的迭代器处理：<br>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。<br>用string::iterator或string::const_iterator声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br>const_iterator begin()const;<br>iterator begin();                //返回string的起始位置<br>const_iterator end()const;<br>iterator end();                    //返回string的最后一个字符后面的位置<br>const_iterator rbegin()const;<br>iterator rbegin();                //返回string的最后一个字符的位置<br>const_iterator rend()const;<br>iterator rend();                    //返回string第一个字符位置的前面<br>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p>
<p>字符串流处理：<br>通过定义ostringstream和istringstream变量实现，#include <sstream>头文件中<br>例如：<br>    string input(“hello,this is a test”);<br>    istringstream is(input);<br>    string s1,s2,s3,s4;<br>    is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;//s1=”hello,this”,s2=”is”,s3=”a”,s4=”test”<br>    ostringstream os;<br>    os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;<br>    cout&lt;&lt;os.str();</sstream></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#include <string>// 注意是<string>，不是<string.h>，带.h的是C语言中的头文件<br>using  std::string;<br>using  std::wstring;<br>using namespace std;</string]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Blade用户手册]]></title>
    <link href="http://www.notehub.cn/2015/10/23/dev/blade/"/>
    <id>http://www.notehub.cn/2015/10/23/dev/blade/</id>
    <published>2015-10-23T06:19:56.000Z</published>
    <updated>2015-10-23T06:08:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Blade是什么">Blade是什么</h2><p>软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。</p>
<p>很多人还在手工编写 Makefile，又没有去写正确的依赖，导致每次不得不先 make clean 才放心，Make的意义大打折扣。这在几个文件的小项目下是没什么问题的，对于大的项目就很不方便了。</p>
<p>Autotools 号称auto，但是还是需要人工写很多东西，运行一系列命令，用起来还是比较复杂，开发人员的学习和使用的门槛很高。</p>
<p>Blade 就是针对这些问题，为腾讯公司基础架构部的[<a href="http://storage.it168.com/a2011/1203/1283/000001283196.shtml" target="_blank" rel="external">http://storage.it168.com/a2011/1203/1283/000001283196.shtml</a> “台风”云计算平台]项目而开发的新一代构建工具，希望能成为开发者手中的“瑞士军刀”。我们现在把它开源出来，希望能让更多的人得到方便。</p>
<h2 id="Blade_解决的问题">Blade 解决的问题</h2><ul>
<li>源文件更新导致需要重新构建。这个 gnu make 都能解决得很好。</li>
<li>头文件更新，所以以来这个头文件的源文件都需要重新构建。这个 gnu make 不直接支持，需要搭配 gcc 来生成和更新依赖。</li>
<li>库文件更新，所依赖的库文件更新后，程序应该重新连接，GNU Make 可以做到。</li>
<li>即使我只构建自己的目标，如果库的源代码变了，库应该重新生成，GNU Make 用递归 Make 无法做到。</li>
<li>库文件之间的依赖自动传递，一个库依赖另一个库，库的最终用户不需要关心。</li>
<li>构建过程中的警告和错误应该醒目地显示出来。</li>
<li>能自动支持台风系统大量使用的 proto buffer，以及方便扩充以支持外来可能引入的新工具。</li>
<li>应该能集成自动测试，代码检查等开发常用的功能。</li>
</ul>
<h2 id="Blade运行条件">Blade运行条件</h2><p>Blade 运行时需要以下条件：</p>
<ul>
<li>SCons v2.0 or later   (required)</li>
<li>Python v2.6 or later  (required)</li>
<li>ccache v3.1 or later  (optional)</li>
</ul>
<p>Blade 编译项目时可能需要到：</p>
<ul>
<li>swig   v2.0 or later  (required for swig_library)</li>
<li>flex v2.5 or later    (required for lex_yacc)</li>
<li>bison v2.1 or later   (required for lex_yacc)</li>
</ul>
<h2 id="源代码树的组织">源代码树的组织</h2><p>Blade要求项目源代码有一个明确的根目录，C++ 中的 #include 的路径也需要从这个目录开始写起，这样有几点好处：</p>
<ul>
<li>有效地避免头文件重名造成的问题。</li>
<li>有效地避免库文件的重名。</li>
<li>更容易找到需要的文件。</li>
<li>提高构建速度。</li>
</ul>
<p>Blade并不从某个配置文件或者环境变量读取这个信息，因为开发人员往往需要同时有多个目录树并存。Blade获取源代码根的方法是，无论当前从哪一级子目录运行，都从当前目录开始向上查找BLADE_ROOT文件，有这个文件的目录即为源代码树的根。</p>
<p>目前源代码目录需要自己拉取，将来我们会集成到 Blade 中。BLADE_ROOT 文件也需要用户自己创建。方法：<br> $ touch BLADE_ROOT</p>
<p>一个源代码树的根目录看起来的样子如下：<br> BLADE_ROOT<br> common<br> thirdparty<br> xfs<br> xcube<br> torca<br> your_project<br> …</p>
<h2 id="BUILD文件">BUILD文件</h2><p>Blade 通过一系列的名字为 “BUILD” 的文件（文件名全大写），这些文件需要开发者去编写。每个 BUILD文件通过一组目标描述函数描述了一个目标的源文件，所依赖的其他目标，以及其他一些属性。</p>
<h3 id="BUILD文件的示例">BUILD文件的示例</h3><p>构建脚本很简单：</p>
<p>范例：common/base/string/BUILD<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">'string'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'algorithm.cpp'</span>,</span><br><span class="line">        <span class="string">'string_number.cpp'</span>,</span><br><span class="line">        <span class="string">'string_piece.cpp'</span>,</span><br><span class="line">        <span class="string">'format.cpp'</span>,</span><br><span class="line">        <span class="string">'concat.cpp'</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [<span class="string">'//common/base:int'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>也是说明式的，只需要列出目标名，源文件名和依赖名（可以没有）即可。</p>
<h2 id="风格建议">风格建议</h2><ul>
<li>四空格缩进，不要用tab字符</li>
<li>总是用单引号</li>
<li>目标名用小写</li>
<li>src 里的文件名按字母顺序排列</li>
<li>deps 里先写本目录内的依赖（:target），后写其他目录内的（//dir:name），分别按字母顺序排列。</li>
<li>不同目标之间空一行，前面可以加注释</li>
<li>注释的 # 后面空一格，比如 # This is a comment</li>
</ul>
<h3 id="描述目标">描述目标</h3><p>Blade用一组target函数来定义目标，这些target的通用属性有：</p>
<ul>
<li>name: 字符串，和路径一起成为target的唯一标识，也决定了构建的输出命名</li>
<li>srcs: 列表或字符串，构建该对象需要的源文件，一般在当前目录，或相对于当前目录的子目录中</li>
<li>deps: 列表或字符串，该对象所依赖的其它targets</li>
</ul>
<p>deps的允许的格式：</p>
<ul>
<li>“//path/to/dir/:name” 其他目录下的target，path为从BLADE_ROOT出发的路径，name为被依赖的目标名。看见就知道在哪里。</li>
<li>“:name” 当前目录下的target， path可以省略。</li>
<li>“#pthread” 系统库。直接写#跟名字即可。</li>
</ul>
<p>cc_<code>*</code> 目标<br>包括 cc_test, cc_binary, cc_library，CC 目标均支持的参数为：</p>
<ul>
<li>srcs 源文件列表</li>
<li>deps 依赖列表</li>
<li>incs 头文件路径列表</li>
<li>defs 宏定义列表</li>
<li>warning 警告设置</li>
<li>optimize 优化设置</li>
</ul>
<ul>
<li>注：thirdparty是我们代码库里的一个特殊目录，里面的代码都是一些第三方库，按照台风系统的代码规范，只允许对这里的代码用incs, defs和warnings，自己开发的代码要按照规范组织。Blade会对这个目录之外的代码使用这些参数发出警告。</li>
</ul>
<p>|| <em>字段</em> || <em>解释</em> || <em>举例</em> || <em>备注</em> ||<br>|| warning || 是否屏蔽warning  || warning=’no’ || 默认不屏蔽 warning=’yes’ , 默认不用写，已开启 ||<br>|| defs || 用户定义的宏加入编译中 || defs=[‘_MT’] || 如果用户定义C++关键字，报warning ||<br>|| incs || 用户定义的include || incs=[‘poppy/myinc’] || 用户通常不要使用 ||<br>|| optimize || 用户定义的optimize flags || optimize=[‘O3’] || 适用于 cc_library cc_binary cc_test proto_library swig_library  cc_plugin resource_library ||</p>
<h4 id="cc_library">cc_library</h4><p>用于描述C++库目标。<br>cc_library同时用于构建静态和动态库，默认只构建静态库，只有被dynamic_link=1的cc_binary依赖时或者命令行指定<br>–generate-dynamic 才生成动态链接库。</p>
<p>举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc_library(</span><br><span class="line">    name=<span class="string">'lowercase'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/lower/plowercase.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>],</span><br><span class="line">    link_all_symbols=<span class="keyword">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>link_all_symbols=True<br>库在被静态链接时，确保库里所有的符号都被链接，以保证依赖全局对象构造函数，比如自动注册器的代码能够正常工作。<br>需要全部链接的部分最好单独拆分出来做成全部链接的库，而不是整个库全都全部链接，否则会无端增大可执行文件的大小。 需要注意的是，link_all_symbols是库自身的属性，不是使用库时的属性。Blade是为大型项目设计的，基于以下因素，我们提倡任何模块都应该有自己的 cc_library，用户程序都应该在deps里写全直接依赖，不提倡创建像boost那样的全头文件的库。<ul>
<li>编译速度</li>
<li>将来未知的改变，比如某库一开始只需要头文件就能使用，不依赖标准库之外的任何库，但是后来依赖了MD5，所有使用这个库的代码都要加上新产生的依赖，这与我们设计Blade的初衷是违背的。</li>
</ul>
</li>
</ul>
<p>要强制用户这样使用，可以在编写代码时，总是编写 .h 对应的 .cpp 文件，并把一部分必然要用到的符号（函数，静态变量）的实现写在里面，即使对于模板库，可以引入一个非模板的基类，或者把非模板部分的实现放到 .cpp 里。</p>
<ul>
<li><p>always_optimize<br>True: 不论debug版本还是release版本总是被优化。<br>False: debug版本不作优化。<br>默认为False。目前只对cc_library有效。</p>
</li>
<li><p>prebuilt=True<br>主要应用在thirdparty中从rpm包解来的库，使用这个参数表示不从源码构建。对应的二进制文件必须存在 lib{32,64}_{release,debug} 这样的子目录中。不区分debug/release时可以只有两个实际的目录。</p>
</li>
</ul>
<p>####cc_binary<br>定义C++可执行文件目标<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name=<span class="string">'prstr'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/mystr_main/mystring.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>,<span class="string">':lowercase'</span>,<span class="string">':uppercase'</span>,<span class="string">'#dl'</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>dynamic_link=True<br>目前我们的binary默认为全静态编译以适应云计算平台使用。<br>如果有应用需要动态编译方式，可以使用此参数指定，此时被此target依赖的所有库都会自动生成对应的动态库供链接。<br>需要注意的是，dynamic_link只适用于可执行文件，不适用于库。</p>
</li>
<li><p>export_dynamic=True<br>常规情况下，so中只引用所依赖的so中的符号，但是对于应用特殊的场合，需要在so中引用宿主可执行文件中的符号，就需要这个选项。<br>这个选项告诉连接器在可执行文件的动态符号表中加入所有的符号，而不只是用到的其他动态库中的符号。这样就使得在dlopen方式加载的so中可以调用可执行文件中的这些符号。<br>详情请参考 man ld(1) 中查找 –export-dynamic 的说明。</p>
</li>
</ul>
<p>####cc_test<br>相当于cc_binary，再加上自动链接gtest和gtest_main<br>还支持testdata参数， 列表或字符串，文件会被链接到输出所在目录name.runfiles子目录下，比如：testdata/a.txt =&gt;name.runfiles/testdata/a.txt<br>用blade test子命令，会在成功构建后到name.runfiles目录下自动运行，并输出总结信息。</p>
<ul>
<li><p>testdata=[]<br>在name.runfiles里建立symbolic link指向工程目录的文件，目前支持<br>以下几种形式</p>
<ul>
<li>‘file’<br>在测试程序中使用这个名字本身的形式来访问</li>
<li>‘//your_proj/path/file’<br>在测试程序中用”your_proj/path/file”来访问。</li>
<li>(‘//your_proj/path/file’, “new_name”)<br>在测试程序中用”new_name”来访问</li>
</ul>
</li>
</ul>
<p>可以根据需要自行选择，这些路径都也可以是目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'textfile_test'</span>,</span><br><span class="line">    srcs = <span class="string">'textfile_test.cpp'</span>,</span><br><span class="line">    deps = <span class="string">':io'</span>,</span><br><span class="line">    testdata = [</span><br><span class="line">        <span class="string">'test_dos.txt'</span>,</span><br><span class="line">        <span class="string">'//your_proj/path/file'</span>,</span><br><span class="line">        (<span class="string">'//your_proj/path/file'</span>, <span class="string">'new_name'</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="proto_library">proto_library</h4><p>用于定义protobuf目标<br>deps 为import所涉及的其他proto_library<br>自动依赖protobuf，使用者不需要再显式指定。<br>构建时自动调用protoc生成cc和h，并且编译成对应的cc_library<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proto_library(</span><br><span class="line">    name = <span class="string">'rpc_meta_info_proto'</span>,</span><br><span class="line">    srcs = <span class="string">'rpc_meta_info.proto'</span>,</span><br><span class="line">    deps = <span class="string">':rpc_option_proto'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Blade支持proto_library，使得在项目中使用protobuf十分方便。</p>
<p>要引用某 proto 文件生成的头文件，需要从 BLADE_ROOT 的目录开始，只是把 proto 扩展名改为 pb.h 扩展名。<br>比如 //common/base/string_test.proto 生成的头文件，路径为 “common/base/string_test.pb.h”。</p>
<h4 id="thrift_library">thrift_library</h4><p>用于定义thrift库目标<br>deps 为import所涉及的其他thrift_library<br>自动依赖thrift，使用者不需要再显式指定。<br>构建时自动调用thrift命令生成cpp和h，并且编译成对应的cc_library</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thrift_library(</span><br><span class="line">    name = <span class="string">'shared_thrift'</span>,</span><br><span class="line">    srcs = <span class="string">'shared.thrift'</span>,</span><br><span class="line">)</span><br><span class="line">thrift_library(</span><br><span class="line">    name = <span class="string">'tutorial_thrift'</span>,</span><br><span class="line">    srcs = <span class="string">'tutorial.thrift'</span>,</span><br><span class="line">    deps = <span class="string">':shared_thrift'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>C++中使用生成的头文件时，规则类似proto，需要带上相对BLADE_ROOT的目录前缀。</p>
<ul>
<li>thrift 0.9版（之前版本未测）有个[<a href="https://issues.apache.org/jira/browse/THRIFT-1859" target="_blank" rel="external">https://issues.apache.org/jira/browse/THRIFT-1859</a> bug]，需要修正才能使用，此bug已经在开发版本中[<a href="https://builds.apache.org/job/Thrift/633/changes#detail13" target="_blank" rel="external">https://builds.apache.org/job/Thrift/633/changes#detail13</a> 修正]</li>
</ul>
<h4 id="lex_yacc_library">lex_yacc_library</h4><p>srcs 必须为二元列表，后缀分别为ll和yy<br>构建时自动调用flex和bison, 并且编译成对应的cc_library</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lex_yacc_library(</span><br><span class="line">     name = <span class="string">'parser'</span>,</span><br><span class="line">     srcs = [</span><br><span class="line">         <span class="string">'line_parser.ll'</span>,</span><br><span class="line">         <span class="string">'line_parser.yy'</span></span><br><span class="line">     ],</span><br><span class="line">     deps = [</span><br><span class="line">         <span class="string">":xcubetools"</span>,</span><br><span class="line">     ],</span><br><span class="line">     recursive = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>recursive=True<br>生成可重入的C scanner.</li>
</ul>
<h4 id="gen_rule">gen_rule</h4><p>用于定制自己的目标<br>outs = []，表示输出的文件列表，需要填写这个域gen_rule才会被执行<br>cmd, 字符串，表示被调用的命令行<br>cmd中可含有如下变量，运行时会被替换成srcs和outs中的对应值<br>$SRCS<br>$OUTS<br>$FIRST_SRC<br>$FIRST_OUT<br>$BUILD<em>DIR – 可被替换为 build[64,32]</em>[release,debug] 输出目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen_rule(</span><br><span class="line">    name=<span class="string">'test_gen_target'</span>,</span><br><span class="line">    cmd=<span class="string">'echo what_a_nice_day;touch test2.c'</span>,</span><br><span class="line">    deps=[<span class="string">':test_gen'</span>],                         <span class="comment"># 可以有deps , 也可以被别的target依赖</span></span><br><span class="line">    outs=[<span class="string">'test2.c'</span>]</span><br><span class="line">)</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>很多用户使用gen_rule动态生成代码文件然后和某个cc_library或者cc_binary一起编译，<br>需要注意应该尽量在输出目录生成代码文件,如build64_debug下，并且文件的路径名要写对，<br>如 outs = [‘websearch2/project_example/module_1/file_2.cc’], 这样使用<br>gen_rule生成的文件和库一起编译时就不会发生找不到动态生成的代码文件问题了。</p>
<p>####swig_library</p>
<p>根据.i文件生成相应的python, java 和php cxx模块代码，并且生成对应语言的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">swig_library(</span><br><span class="line">    name = <span class="string">'poppy_client'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'poppy_client.i'</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">':poppy_swig_wrap'</span></span><br><span class="line">    ],</span><br><span class="line">    warning=<span class="string">'yes'</span>,</span><br><span class="line">    java_package=<span class="string">'com.soso.poppy.swig'</span>,   <span class="comment"># 生成的java文件的所在package名称</span></span><br><span class="line">    java_lib_packed=<span class="number">1</span>, <span class="comment"># 表示把生成的libpoppy_client_java.so打包到依赖者的jar包里，如java_jar依赖这个swig_library</span></span><br><span class="line">    optimize=[<span class="string">'O3'</span>]    <span class="comment"># 编译优化选项</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>warning<br>这里的warning仅仅指swig编译参数cpperraswarn是否被指定了，swig_library默认使用非标准编译告警级别（没有那么严格）。</li>
</ul>
<h4 id="cc_plugin">cc_plugin</h4><p>支持生成target所依赖的库都是静态库.a的so库，即plugin。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_plugin(</span><br><span class="line">    name=<span class="string">'mystring'</span>,</span><br><span class="line">    srcs=[<span class="string">'./src/mystr/mystring.cpp'</span>],</span><br><span class="line">    deps=[<span class="string">'#pthread'</span>,<span class="string">':lowercase'</span>,<span class="string">':uppercase'</span>,<span class="string">'#dl'</span>],</span><br><span class="line">    warning=<span class="string">'no'</span>,</span><br><span class="line">    defs=[<span class="string">'_MT'</span>],</span><br><span class="line">    optimize=[<span class="string">'O3'</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>cc_plugin 是为 JNI，python 扩展等需要动态库的场合设计的，不应该用于其他目的。</p>
<h4 id="resource_library">resource_library</h4><p>编译静态资源。</p>
<p>大家都遇到过部署一个可执行程序，还要附带一堆辅助文件才能运行起来的情况吧？<br>blade通过resource_library，支持把程序运行所需要的数据文件也打包到可执行文件里，<br>比如poppy下的BUILD文件里用的静态资源：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resource_library(</span><br><span class="line">    name = <span class="string">'static_resource'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'static/favicon.ico'</span>,</span><br><span class="line">        <span class="string">'static/forms.html'</span>,</span><br><span class="line">        <span class="string">'static/forms.js'</span>,</span><br><span class="line">        <span class="string">'static/jquery-1.4.2.min.js'</span>,</span><br><span class="line">        <span class="string">'static/jquery.json-2.2.min.js'</span>,</span><br><span class="line">        <span class="string">'static/methods.html'</span>,</span><br><span class="line">        <span class="string">'static/poppy.html'</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>生成  和 libstatic_resource.a 或者 libstatic_resource.so。<br>就像一样protobuf那样，编译后后生成一个库libstatic_resource.a，和一个相应的头文件static_resource.h，带路径包含进来即可使用。</p>
<p>在程序中需要包含static_resource.h（带上相对于BLADE_ROOT的路径）和”common/base/static_resource.hpp”，<br>用 STATIC_RESOURCE 宏来引用数据：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringPiece data = STATIC_RESOURCE(poppy_static_favicon_ico);</span><br></pre></td></tr></table></figure></p>
<p>STATIC_RESOURCE 的参数是从BLADE<em>ROOT目录开始的数据文件的文件名，把所有非字母数字和下划线的字符都替换为</em>。</p>
<p>得到的 data 在程序运行期间一直存在，只可读取，不可写入。</p>
<p>用 static resource 在某些情况下也有一点不方便：就是不能在运行期间更新，因此是否使用，需要根据具体场景自己权衡。</p>
<h4 id="java_jar">java_jar</h4><p>编译java源代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java_jar(</span><br><span class="line">    name = <span class="string">'poppy_java_client'</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">'src/com/soso/poppy'</span>                 <span class="comment"># 这里只需要指定java文件所在目录，不要写上具体java文件列表</span></span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">'//poppy:rpc_meta_info_proto'</span>,       <span class="comment"># 可以依赖proto_library生成的java文件一起编译打包</span></span><br><span class="line">        <span class="string">'//poppy:rpc_option_proto'</span>,</span><br><span class="line">        <span class="string">'//poppy:rpc_message_proto'</span>,</span><br><span class="line">        <span class="string">'//poppy:poppy_client'</span>,              <span class="comment"># 可以依赖swig_library生成的java文件一起编译打包</span></span><br><span class="line">        <span class="string">'./lib:protobuf-java'</span>,               <span class="comment"># 可以依赖别的jar包</span></span><br><span class="line">        <span class="string">'./lib:junit'</span>,</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>prebuilt=True<br>主要应用在已经编译打包好的java jar 包。</li>
</ul>
<h2 id="Blade的输出">Blade的输出</h2><p>构建过程是彩色高亮的<br>出错信息是彩色的，方便定位错误。</p>
<p>默认生成 native arch 的可执行文件，指定生成 32/64 位结果也很简单，加上 -m32/64即可。<br>默认生成 release 版本的结果，如果生成 debug 版的，加上 -p debug 即可。<br>默认构建当前目录，如果当前目录依赖的外面的模块需要重新构建，也会被连带构建起来（Make很难做到）。如果要从当前目录构建所有子目录的目标，也很简单：blade … 即可。</p>
<p>不同构建选项的结果放在不同的目录下，生成的文件一律按层次也放在这个目录里，不会污染源代码目录。</p>
<p>要清除构建结果（一般不需要），blade clean 即可。</p>
<h2 id="Blade_Cache">Blade Cache</h2><p>blade 支持 cache，可以大幅度加快构建速度。<br>blade 支持两种cache</p>
<ul>
<li>ccache , cache配置使用ccache的配置, 如通过配置 CCACHE_DIR 环境变量指定ccache目录。</li>
<li>ccache 没有安装，则使用scons cache, 配置细节如下</li>
</ul>
<p>scons cache需要一个目录，依次按以下顺序检测：</p>
<ul>
<li>命令行参数–cache-dir</li>
<li>环境变量BLADE_CACHE_DIR</li>
<li>如果均未配置，则不启用cache。</li>
<li>空的BLADE_CACHE_DIR变量或者不带参数值的–cache-dir=, 则会禁止cache。</li>
</ul>
<p>–cache-size 如不指定，则默认为2G，如指定，则使用用户指定的以Gigabyte为单位的大小的cache。<br>如 –cache-dir=’~/user_cache’ –cache-size=16 (16 G)大小cache。<br>用户可以根据需要配置大小，超出大小blade会执行清理工作，限制cache大小在用户指定的cache大小，<br>请谨慎设置这个大小，因为涉及到构建速度和机器磁盘空间的占用。</p>
<h2 id="测试支持">测试支持</h2><p>Blade test支持增量测试 ，可以加快tests的执行。<br>已经Pass 的tests 在下一次构建和测试时不需要再跑，除非：</p>
<ul>
<li>tests 的任何依赖变化导致其重新生成。</li>
<li>tests 依赖的测试数据改变，这种依赖为显式依赖，用户需要使用BUILD文件指定，如testdata。</li>
<li>tests 所在环境变量发生改变。</li>
<li>test arguments 改变。</li>
<li>Fail 的test cases ，每次都重跑。</li>
</ul>
<p>如果需要使用全量测试，使用–full-test option, 如 blade test common/… –full-test ， 全部测试都需要跑。<br>另外，cc_test 支持了 always_run 属性，用于在增量测试时，不管上次的执行结果，每次总是要跑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'zookeeper_test'</span>,</span><br><span class="line">    srcs = <span class="string">'zookeeper_test.cc'</span>,</span><br><span class="line">    always_run = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>Blade test支持并行测试，并行测试把这一次构建后需要跑的test cases并发地run。<br>blade test [targets] –test-jobs N<br>-t, –test-jobs N 设置并发测试的并发数，Blade会让N个测试进程并行执行</p>
<p>对于某些因为可能相互干扰而不能并行跑的测试，可以加上 exclusive 属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_test(</span><br><span class="line">    name = <span class="string">'zookeeper_test'</span>,</span><br><span class="line">    srcs = <span class="string">'zookeeper_test.cc'</span>,</span><br><span class="line">    exclusive = <span class="keyword">True</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="命令行参考">命令行参考</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blade `[`action`]` `[`options`]` `[`targets`]`</span><br></pre></td></tr></table></figure>
<p>action是一个动作，目前有</p>
<ul>
<li>build 表示构建项目</li>
<li>test  表示构建并且跑单元测试</li>
<li>clean 表示清除目标的构建结果</li>
<li>query 查询目标的依赖项与被依赖项</li>
<li>run   构建并run一个单一目标</li>
</ul>
<p>targets是一个列表，支持的格式：</p>
<ul>
<li>path:name 表示path中的某个target</li>
<li>path表示path中所有targets</li>
<li>path/… 表示path中所有targets，并递归包括所有子目录</li>
<li>:name表示当前目录下的某个target<br>默认表示当前目录</li>
</ul>
<p>参数列表：</p>
<ul>
<li>-m32,-m64            指定构建目标位数，默认为自动检测</li>
<li>-p PROFILE           指定debug/release，默认release</li>
<li>-k, –keep-going     构建过程中遇到错误继续执行（如果是致命错误不能继续）</li>
<li>-j N,–jobs=N        N路并行编译，多CPU机器上适用</li>
<li>-t N,–test-jobs=N   N路并行测试，多CPU机器上适用</li>
<li>–cache-dir=DIR      指定一个cache目录</li>
<li>–cache-size=SZ      指定cache大小，以G为单位</li>
<li>–verbose            完整输出所运行的每条命令行</li>
<li>–h, –help           显示帮助</li>
<li>–color=yes/no/auto  是否开启彩色</li>
<li>–generate-dynamic   强制生成动态库</li>
<li>–generate-java      为proto_library 和 swig_library 生成java文件</li>
<li>–generate-php       为proto_library 和 swig_library 生成php文件</li>
<li>–gprof              支持 GNU gprof</li>
<li>–gcov               支持 GNU gcov 做覆盖率测试</li>
</ul>
<h2 id="配置">配置</h2><p>Blade 支持三个配置文件</p>
<ul>
<li>blade.zip 同一个目录下的 blade.conf，这是全局配置。</li>
<li>~/.bladerc 用户 HOME 目录下的 .bladerc 文件，这是用户级的配置。</li>
<li>BLADE_ROOT 其实也是个配置文件，写在这里的是项目级配置。</li>
</ul>
<p>后面描述的所有多个参数的配置的每个配置参数都有默认值，并不需要全部写出，也没有顺序要求。</p>
<h3 id="cc_config">cc_config</h3><p>所有c/c++目标的公共配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc_config(</span><br><span class="line">    extra_incs = [<span class="string">'thirdparty'</span>],  <span class="comment"># 额外的 -I，比如 thirdparty</span></span><br><span class="line">    warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C/C++公用警告</span></span><br><span class="line">    c_warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C专用警告</span></span><br><span class="line">    cxx_warnings = [<span class="string">'-Wall'</span>, <span class="string">'-Wextra'</span>...], <span class="comment"># C++专用警告</span></span><br><span class="line">    optimize = <span class="string">'-O2'</span>, <span class="comment"># 优化级别</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有选项均为可选，如果不存在，则保持先前值。发布带的blade.conf中的警告选项均经过精心挑选，建议保持。</p>
<h3 id="cc_test_config">cc_test_config</h3><p>构建和运行测试所需的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cc_test_config(</span><br><span class="line">    dynamic_link=<span class="keyword">True</span>,   <span class="comment"># 测试程序是否默认动态链接，可以减少磁盘开销，默认为 False</span></span><br><span class="line">    heap_check=<span class="string">'strict'</span>, <span class="comment"># 开启 gperftools 的 HEAPCHECK，具体取值请参考 gperftools 的文档</span></span><br><span class="line">    gperftools_libs=<span class="string">'//thirdparty/perftools:tcmalloc'</span>,  <span class="comment"># tcmclloc 库，blade deps 格式</span></span><br><span class="line">    gperftools_debug_libs=<span class="string">'//thirdparty/perftools:tcmalloc_debug'</span>, <span class="comment"># tcmalloc_debug 库，blade deps 格式</span></span><br><span class="line">    gtest_libs=<span class="string">'//thirdparty/gtest:gtest'</span>,  <span class="comment"># gtest 的库，blade deps 格式</span></span><br><span class="line">    gtest_main_libs=<span class="string">'//thirdparty/gtest:gtest_main'</span> <span class="comment"># gtest_main 的库路径，blade deps 格式</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有的 config 的列表类型的选项均支持追加模式，用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc_config(</span><br><span class="line">    append = config_items(</span><br><span class="line">        warnings = [...]</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>gtest 1.6开始，去掉了 make install，但是可以绕过[<a href="http://blog.csdn.net/chengwenyao18/article/details/7181514" target="_blank" rel="external">http://blog.csdn.net/chengwenyao18/article/details/7181514</a> gtest1.6.0安装方法]。</li>
<li>gtest 库还依赖 pthread，因此gtest_libs需要写成 [‘#gtest’, ‘#pthread’]</li>
<li>或者把源码纳入你的源码树，比如thirdparty下，就可以写成gtest_libs=’//thirdparty/gtest:gtest’。</li>
</ul>
<h3 id="proto_library_config">proto_library_config</h3><p>编译protobuf需要的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proto_library_config(</span><br><span class="line">    protoc=<span class="string">'protoc'</span>,  <span class="comment"># protoc编译器的路径</span></span><br><span class="line">    protobuf_libs=<span class="string">'//thirdparty/protobuf:protobuf'</span>, <span class="comment"># protobuf库的路径，Blade deps 格式</span></span><br><span class="line">    protobuf_path=<span class="string">'thirdparty'</span>, <span class="comment"># import 时的 proto 搜索路径，相对于 BLADE_ROOT</span></span><br><span class="line">    protobuf_include_path = <span class="string">'thirdparty'</span>,  <span class="comment"># 编译 pb.cc 时额外的 -I 路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="thrift_library_config">thrift_library_config</h3><p>编译thrift需要的配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thrift_library_config(</span><br><span class="line">    thrift=<span class="string">'thrift'</span>,  <span class="comment"># protoc编译器的路径</span></span><br><span class="line">    thrift_libs=<span class="string">'//thirdparty/thrift:thrift'</span>, <span class="comment"># thrift库的路径，Blade deps 格式</span></span><br><span class="line">    thrift_path=<span class="string">'thirdparty'</span>, <span class="comment"># thrift中include时的thrift文件的搜索路径，相对于 BLADE_ROOT</span></span><br><span class="line">    thrift_incs = <span class="string">'thirdparty'</span>,  <span class="comment"># 编译 thrift生成的.cpp 时额外的 -I 路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>所有这些配置项都有默认值，如果不需要覆盖就无需列入相应的参数。默认值都是假设安装到系统目录下，如果你的项目中把这些库放进进了自己的代码中（比如我们内部），请修改相应的配置。</p>
<h2 id="环境变量">环境变量</h2><p>Blade还支持以下环境变量：</p>
<ul>
<li>TOOLCHAIN_DIR，默认为空</li>
<li>CPP，默认为cpp</li>
<li>CXX，默认为c++</li>
<li>CC，默认为gcc</li>
<li>LD，默认为c++</li>
</ul>
<p>TOOLCHAIN_DIR和CPP等组合起来，构成调用工具的完整路径，例如：</p>
<p>调用/usr/bin下的gcc（开发机上的原版gcc）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TOOLCHAIN_DIR=/usr/bin blade</span><br></pre></td></tr></table></figure></p>
<p>使用clang<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPP=<span class="string">'clang -E'</span> CC=clang CXX=clang++ ld=clang++ blade</span><br></pre></td></tr></table></figure></p>
<p>如同所有的环境变量设置规则，放在命令行前的环境变量，只对这一次调用起作用，如果要后续起作用，用 export，要持久生效，放入 ~/.profile 中。</p>
<p>环境变量的支持将来考虑淘汰，改为配置编译器版本的方式，因此建议暂时不要使用。</p>
<h2 id="辅助命令">辅助命令</h2><h3 id="install">install</h3><p>blade命令的符号链接会被安装下面的命令到~/bin 下。</p>
<h3 id="lsrc">lsrc</h3><p>列出当前目录下指定的源文件，以blade的srcs列表格式输出。</p>
<h3 id="genlibbuild">genlibbuild</h3><p>自动生成以目录名为库名的cc_library，以测试文件的名为名的cc_test，proto的BUILD文件，并假设这些测试都依赖这个库</p>
<h3 id="vim集成">vim集成</h3><p>我们编写了vim的blade语法文件，高亮显示blade关键字，install后就会自动生效。</p>
<p>我们编写了 Blade 命令，使得可以在 vim 中直接执行 blade，并快速跳转到出错行（得益于 vim 的 <a href="ttp://easwy.com/blog/archives/advanced-vim-skills-quickfix-mode/" target="_blank" rel="external">hquickfix</a> 特性）。</p>
<p>使用时直接在 vim 的 : 模式输入（可带参数）</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:Blade</span><br></pre></td></tr></table></figure>
<p>即可构建。</p>
<p>这个命令的源代码在 tools/.vimrc 中。</p>
<h3 id="alt">alt</h3><p>在源代码目录和构建目标目录之间跳转</p>
<h2 id="安装">安装</h2><p>执行install脚本即可安装到~/bin下，目前因还在开发阶段，变化还比较快，以软链方式安装，install后不能删除checkout出来的原始目录。<br>目前blade生成scons脚本，因此还需要安装scons 2.0以上版本。<br>Blade 需要支持 Python 2.4-2.7.x，不支持 python3。</p>
<p>install使得可以在任何目录下直接执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ blade</span><br></pre></td></tr></table></figure>
<p>命令。<br>如果不行，确保~/bin在你的PATH环境变量里，否则修改 ~/.profile，加入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=~/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后重新登录即可。</p>
<p>From: <a href="https://github.com/chen3feng/typhoon-blade/blob/master/doc/user_manual_zh_CN.md" target="_blank" rel="external">https://github.com/chen3feng/typhoon-blade/blob/master/doc/user_manual_zh_CN.md</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Blade是什么">Blade是什么</h2><p>软件项目用各种工具来构建代码，最常用的恐怕是GNU Make。但是 GNU Make 虽然本身功能比较强，但是要直接使用的话，也是比较难的。</p>
<p>很多人还在手工编写 Makefile，又没有去写正确的依]]>
    </summary>
    
      <category term="blade" scheme="http://www.notehub.cn/tags/blade/"/>
    
      <category term="dev" scheme="http://www.notehub.cn/categories/dev/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++ 编程环境]]></title>
    <link href="http://www.notehub.cn/2015/10/21/dev/CPP/cpp_dev/"/>
    <id>http://www.notehub.cn/2015/10/21/dev/CPP/cpp_dev/</id>
    <published>2015-10-21T12:19:56.000Z</published>
    <updated>2015-10-26T07:09:15.000Z</updated>
    <content type="html"><![CDATA[<h3 id="C++_code_with_Google_style">C++ code with Google style</h3><p><a href="http://google.github.io/styleguide/cppguide.html" target="_blank" rel="external">http://google.github.io/styleguide/cppguide.html</a></p>
<h3 id="Use_cpplint_to_check_your_style">Use cpplint to check your style</h3><h3 id="Protocol_Buffers">Protocol Buffers</h3><p><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">https://developers.google.com/protocol-buffers/</a><br>(proto2): <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto</a><br>C++ related: <a href="https://developers.google.com/protocol-buffers/docs/cpptutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/cpptutorial</a>,<br>Style guide: <a href="https://developers.google.com/protocol-buffers/docs/style" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/style</a></p>
<h3 id="Compile_code:_Blade">Compile code: Blade</h3><p><a href="https://github.com/chen3feng/typhoon-blade" target="_blank" rel="external">https://github.com/chen3feng/typhoon-blade</a></p>
<h3 id="Unit_test_your_code:_gtest">Unit test your code: gtest</h3><p><a href="https://github.com/google/googletest/blob/master/googletest/docs/Documentation.md" target="_blank" rel="external">https://github.com/google/googletest/blob/master/googletest/docs/Documentation.md</a><br>Run unit tests with BLADE<br>Every public method should be covered</p>
<h3 id="Post_your_code_review:_ReviewBoard">Post your code review: ReviewBoard</h3><h3 id="gflags">gflags</h3><p>gflags支持方便的解析和获取命令行参数<br><a href="https://github.com/gflags/gflags" target="_blank" rel="external">https://github.com/gflags/gflags</a></p>
<h3 id="glog">glog</h3><p><a href="https://github.com/google/glog" target="_blank" rel="external">https://github.com/google/glog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="C++_code_with_Google_style">C++ code with Google style</h3><p><a href="http://google.github.io/styleguide/cppguide.html" target="_bl]]>
    </summary>
    
      <category term="c++" scheme="http://www.notehub.cn/categories/c/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Maven 依赖包打包]]></title>
    <link href="http://www.notehub.cn/2015/10/12/dev/maven_assembly/"/>
    <id>http://www.notehub.cn/2015/10/12/dev/maven_assembly/</id>
    <published>2015-10-12T12:19:56.000Z</published>
    <updated>2015-10-12T12:25:43.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.travelsky.tdp.pkgstock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>stock-assembly-descriptor<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 绑定到maven的package命令 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="title">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="title">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ignoreMissingDescriptor</span>&gt;</span>true<span class="tag">&lt;/<span class="title">ignoreMissingDescriptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipAll<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipFilterConf<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipJsCssOnly<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">descriptorRef</span>&gt;</span>zipPicOnly<span class="tag">&lt;/<span class="title">descriptorRef</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">descriptorRefs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="]]>
    </summary>
    
      <category term="java" scheme="http://www.notehub.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Math StatExample]]></title>
    <link href="http://www.notehub.cn/2015/10/12/dev/java_math_stat/"/>
    <id>http://www.notehub.cn/2015/10/12/dev/java_math_stat/</id>
    <published>2015-10-12T04:57:56.000Z</published>
    <updated>2015-10-12T11:27:09.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.StatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.GeometricMean;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Kurtosis;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Mean;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Skewness;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.StandardDeviation;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.moment.Variance;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Max;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Min;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.rank.Percentile;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.summary.Product;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math.stat.descriptive.summary.Sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] values = <span class="keyword">new</span> <span class="keyword">double</span>[] &#123; <span class="number">2.3</span>, <span class="number">5.4</span>, <span class="number">6.2</span>, <span class="number">7.3</span>, <span class="number">23.3</span> &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println( <span class="string">"min: "</span> + StatUtils.min( values ) );</span><br><span class="line">        System.out.println( <span class="string">"max: "</span> + StatUtils.max( values ) );</span><br><span class="line">        System.out.println( <span class="string">"mean: "</span> + StatUtils.mean( values ) );</span><br><span class="line">        System.out.println( <span class="string">"product: "</span> + StatUtils.product( values ) );</span><br><span class="line">        System.out.println( <span class="string">"sum: "</span> + StatUtils.sum( values ) );</span><br><span class="line">        System.out.println( <span class="string">"variance: "</span> + StatUtils.variance( values ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Measures from previous example</span></span><br><span class="line">        Min min = <span class="keyword">new</span> Min();</span><br><span class="line">        System.out.println( <span class="string">"min: "</span> + min.evaluate( values ) );</span><br><span class="line">        Max max = <span class="keyword">new</span> Max();</span><br><span class="line">        System.out.println( <span class="string">"max: "</span> + max.evaluate( values ) );</span><br><span class="line">        Mean mean = <span class="keyword">new</span> Mean();</span><br><span class="line">        System.out.println( <span class="string">"mean: "</span> + mean.evaluate( values ) );</span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        System.out.println( <span class="string">"product: "</span> + product.evaluate( values ) );</span><br><span class="line">        Sum sum = <span class="keyword">new</span> Sum();</span><br><span class="line">        System.out.println( <span class="string">"sum: "</span> + sum.evaluate( values ) );</span><br><span class="line">        Variance variance = <span class="keyword">new</span> Variance();</span><br><span class="line">        System.out.println( <span class="string">"variance: "</span> + variance.evaluate( values ) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// New measures</span></span><br><span class="line">        Percentile percentile = <span class="keyword">new</span> Percentile();</span><br><span class="line">        System.out.println( <span class="string">"80 percentile value: "</span> + percentile.evaluate( values, <span class="number">80.0</span> ) );</span><br><span class="line">        GeometricMean geoMean = <span class="keyword">new</span> GeometricMean();</span><br><span class="line">        System.out.println( <span class="string">"geometric mean: "</span> + geoMean.evaluate( values ) );</span><br><span class="line">        StandardDeviation stdDev = <span class="keyword">new</span> StandardDeviation();</span><br><span class="line">        System.out.println( <span class="string">"standard dev: "</span> + stdDev.evaluate( values ) );</span><br><span class="line">        Skewness skewness = <span class="keyword">new</span> Skewness();</span><br><span class="line">        System.out.println( <span class="string">"skewness: "</span> + skewness.evaluate( values ) );</span><br><span class="line">        Kurtosis kurtosis = <span class="keyword">new</span> Kurtosis();</span><br><span class="line">        System.out.println( <span class="string">"kurtosis: "</span> + kurtosis.evaluate( values ) );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class=]]>
    </summary>
    
      <category term="java" scheme="http://www.notehub.cn/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Cookie]]></title>
    <link href="http://www.notehub.cn/2015/10/10/internet/ad/cookie/"/>
    <id>http://www.notehub.cn/2015/10/10/internet/ad/cookie/</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-10T06:35:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="关于Cookie">关于Cookie</h2><hr>
<p><img src="/images/other/cookie.jpg" alt=""></p>
<h3 id="Cookie的传递流程">Cookie的传递流程</h3><p>Cookie利用网页代码中癿HTTP头信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。例如：当你在浏览器地址栏中键入了Amazon的URL，浏览器会向Amazon发送一个读取网页请求，并将结果在显示器上显示。在发送前，该网页在你的电脑上寻找Amazon网站设置的Cookie文件，如果找到，浏览器会把Cookie文件中的数据连同前面输入的URL一同发送到Amazon服务器。服务器收到Cookie数据，就会在他的数据库中检索你的ID，你的购物记彔、个人喜好等信息，并记录下新的内容，增加到数据库和Cookie文件中去。如果没有检测到Cookie或者你的Cookie信息不数据库中的信息不符合，则说明你是第一次浏览该网站，服务器的CGI程序将为你创建新的ID信息，幵保存到数据库中。</p>
<h3 id="关于Cookie的一些知识点">关于Cookie的一些知识点</h3><ol>
<li>Cookie是基二浏览器的，因此当电脑上安装多个浏览器时，服务器会生成多个Cookie。虽然是同一个人，但服务器是识删为多个用户。 </li>
<li>Cookie是基二浏览器的，因此当同一台电脑有多个人使用时，服务器也叧会生成一个Cookie。虽然是多个人，但服务器会讣为是一个用户。补充：在多个人均登彔账户时，服务器可以以账户为匙分，为每个账户生成单独癿cookie，比如多人用同一台电脑登彔新浪微博。（感谢数据挖掘_PHP癿指正） </li>
<li>Cookie是无法跨设备设置的。比如我们在单位和家里分别使用两台电脑，即使我们使用同一种同一版本的浏览器，我们迓是生成了两个Cookie，服务器会认为是两个用户。（PS：现在有些浏览器可以同步数据，比如Chrome、Friefox，可以避免这种问题） </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="关于Cookie">关于Cookie</h2><hr>
<p><img src="/images/other/cookie.jpg" alt=""></p>
<h3 id="Cookie的传递流程">Cookie的传递流程</h3><p>Cookie利用网页代码中]]>
    </summary>
    
      <category term="广告" scheme="http://www.notehub.cn/tags/%E5%B9%BF%E5%91%8A/"/>
    
      <category term="internet" scheme="http://www.notehub.cn/categories/internet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在线广告作弊手段一览]]></title>
    <link href="http://www.notehub.cn/2015/10/10/internet/ad/ad_cheating/"/>
    <id>http://www.notehub.cn/2015/10/10/internet/ad/ad_cheating/</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-10T06:21:42.000Z</updated>
    <content type="html"><![CDATA[<p>这里提到的在线广告作弊是指媒体为了刷广告流量而进行的作弊。他们的作弊手段很多， 这里介绍常见的几种。</p>
<p>iframe是广告作弊最常用的技巧，就是在自己的网页上嵌入iframe, 大小为0x0或1×1，也就是用户不可见。通过iframe打开其他页面，在用户看不见的情况下刷流量。别看iframe简单，里面花样很多。</p>
<h3 id="页面内嵌入本站页面的iframe">页面内嵌入本站页面的iframe</h3><p>iframe打开和当前页一样的页面地址，或本站的其他页面。 这样用户的一个浏览行为，很轻松就从1个pv翻倍变成2个pv。如果嵌入iframe多点， 就能翻3倍，4倍…。但使用这个方法很容易被发现，广告投放方，通过分析UV，独立IP等很容易就发现异常。 这是很老的方法，不过还是有些网站乐此不疲。</p>
<h3 id="两个站点间互相嵌入对方站点页面的iframe">两个站点间互相嵌入对方站点页面的iframe</h3><p>这是比较巧妙的作弊技巧，UV，独立IP等分析方法是不能发现异常的。</p>
<h3 id="双层iframe">双层iframe</h3><p>作弊的iframe为了不让人看见，大小只有0x0或1×1，但有些在线广告在显示时会判断浏览窗口大小，如果太小可能就不能显示。这时有些网站就采用了双层iframe技术来刷广告流量。 第一层1×1大小的iframe中又嵌入一个iframe，这个第二层iframe是正常浏览窗口大小，广告代码很难发现异常。</p>
<p>这种作弊方式使用巧妙的，会让主页面和两个iframe使用三个不同的域名，这样因为跨域的问题， 里面的js不可能得到最外层真正的页面地址， 想抓证据都抓不到。</p>
<h3 id="IP屏蔽">IP屏蔽</h3><p>有些站点在进行作弊时，会屏蔽北京，上海等大城市的访问，你从这些地区访问时，看不到他们的作弊代码，一切正常。等换用其他地方的代理访问时，你在他们页面里就能看到作弊用iframe代码。 这是因为很多IT，在线广告公司都在这些大城市，这种屏蔽让他们的作弊手段很难被同业发现。</p>
<h3 id="购买垃圾流量">购买垃圾流量</h3><p>现在来自iframe，木马的垃圾流量都是明码标价在卖的，可以用这些流量来刷页面，刷广告。这种也比较难以发现。网站去刷流量目的往往比较复杂，一是刷广告流量，赚广告商和广告主的钱，二是为了alexa之类的排名，也有是为了给投资人看所谓的“业绩”。 </p>
<p>上面谈的基本都是CPM广告方式的作弊，下面说说其他的。 </p>
<h3 id="CPC作弊">CPC作弊</h3><p>CPC作弊其实是很简单的，只要用iframe打开点击链接即可。</p>
<h3 id="CPA作弊">CPA作弊</h3><p>有些网站广告按CPA结算，比如注册人数等。 这种情况下，有的公司会做专门的自动注册机，保证你的注册人数疯狂上涨。</p>
<h3 id="CPS作弊">CPS作弊</h3><p>很多人感觉CPS方式是不可能作弊的，其实这也是可以的。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里提到的在线广告作弊是指媒体为了刷广告流量而进行的作弊。他们的作弊手段很多， 这里介绍常见的几种。</p>
<p>iframe是广告作弊最常用的技巧，就是在自己的网页上嵌入iframe, 大小为0x0或1×1，也就是用户不可见。通过iframe打开其他页面，在用户看不见的]]>
    </summary>
    
      <category term="广告" scheme="http://www.notehub.cn/tags/%E5%B9%BF%E5%91%8A/"/>
    
      <category term="internet" scheme="http://www.notehub.cn/categories/internet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[合福高铁-国庆游]]></title>
    <link href="http://www.notehub.cn/2015/10/07/travel/hefu_travel/"/>
    <id>http://www.notehub.cn/2015/10/07/travel/hefu_travel/</id>
    <published>2015-10-06T16:00:00.000Z</published>
    <updated>2015-10-10T06:11:10.000Z</updated>
    <content type="html"><![CDATA[<p>国庆本来自己没什么计划，后来同学一起计划沿着合福高铁沿线的景点游一圈，合福高铁将黄山、三清山、武夷山、福州、厦门等联系在了一起，横跨三个省份，当真是中国最美的高铁线路。由于人在杭州，因此打算从杭州出发，六天的行程计划去三清山、武夷山、福州和厦门。正所谓计划赶不上变化，再加上国庆人比较多导致早已经买好的票都改签了，预约的酒店很多也没有住成。</p>
<h3 id="首站：杭州-武夷山东">首站：杭州-武夷山东</h3><hr>
<p>晚上6:30发车，9:00就到武夷山东站了，武夷山东站是刚刚开通的车站，周围的交通配套设施都很不完善，另外武夷山东站虽然名字中带着『武夷山』，但是离武夷山景区的距离实在是太长了，坐大巴车要两个小时。</p>
<p>到了景区后住了一个青年旅店，六人间，遇到了两个福州来的漂亮妹子，住的地方很潮湿，可能是因为刚刚来台风的原因，一晚上没有怎么睡好，青年旅店的环境还是挺好的，老板非常文艺，微信发的状态都是繁体字的。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4006.jpg" alt=""><br><img src="/images/hefu_train/IMG_4010.jpg" alt=""></p>
<p>第二天吃了点早饭，为了逃票，直接找了个当地人把我们带到景区去爬大王峰了，大王峰不算是最知名的武夷山景点，不过丹霞地貌的还是挺美的。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4021.jpg" alt=""><br>我觉得逃票这个决定可能是这次旅行最坏得决定了，大王峰倒是没什么特色，但是下午打算去其他景点的时候就发现再买票有点不划算了，本来定的是10月2号离开武夷山的，结果最后只能提前走了。再附几张武夷山的图。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4048.jpg" alt=""><br><img src="/images/hefu_train/IMG_4115.jpg" alt=""></p>
<h3 id="第二站：三清山">第二站：三清山</h3><hr>
<p>『三清山又名少华山、丫山，位于中国江西省上饶市玉山县与德兴市交界处。因玉京、玉虚、玉华三峰宛如道教玉清、上清、太清三位尊神列坐山巅而得名。其中玉京峰为最高，海拔1819.9米，是江西第五高峰和怀玉山脉的最高峰，也是信江的源头。三清山是道教名山，世界自然遗产地、世界地质公园、国家自然遗产、国家地质公园。』</p>
<p>三清山比较热门的路线是南线索道和东线索道，要想徒步上山的话只能从南部走。我们是从东部的金沙索道上山的，国庆假期索道还要叫号按序上山，上去之后已经是海拔1000米以上了，之后所有的景点都在1000米之上。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4192.jpg" alt=""><br><img src="/images/hefu_train/IMG_4213.jpg" alt=""><br><img src="/images/hefu_train/IMG_4257.jpg" alt=""></p>
<center>云雾缭绕的三清山</center><br><img src="/images/hefu_train/IMG_4265.jpg" alt=""><br><img src="/images/hefu_train/IMG_4269.jpg" alt=""><br><img src="/images/hefu_train/IMG_4276.jpg" alt=""><br><center>猴王观宝</center><br><img src="/images/hefu_train/IMG_4287.jpg" alt=""><br><center>如诗如画</center><br><img src="/images/hefu_train/IMG_4296.jpg" alt=""><br><img src="/images/hefu_train/IMG_4299.jpg" alt=""><br><center>三清山主峰</center>

<h3 id="第三站：福州">第三站：福州</h3><hr>
<p>福州整体没有很深得印象，就去了三坊七巷，还买了原价120一人的票，逛的过程中发现票价非常不值啊，收费的小景点都是一些古宅什么的，作为一个北方人，看过了也就那样了，都是类似的。另外三坊七巷和厦门的曾厝垵和鼓浪屿比也没有什么特色，被完爆的节奏。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4346.jpg" alt=""><br><img src="/images/hefu_train/IMG_4355.jpg" alt=""><br><img src="/images/hefu_train/IMG_4523.jpg" alt=""></p>
<center>非常喜欢林则徐纪念馆的牌子的设计</center>

<h3 id="第四站：厦门">第四站：厦门</h3><hr>
<p>上次去厦门是元旦的时候，那个时候是十几个人一起去的，离现在还不到半年的时间。每次去厦门都是不同的感受，总的来说厦门是一个让人放松的城市，非常的文艺。</p>
<hr>
<p><img src="/images/hefu_train/IMG_4364.jpg" alt=""></p>
<center>『烤酸奶』其实是冷冻的，第一次吃，味道还不错</center><br><img src="/images/hefu_train/IMG_4428.jpg" alt=""><br><br><img src="/images/hefu_train/IMG_4497.jpg" alt=""><br><img src="/images/hefu_train/IMG_4518.jpg" alt=""><br><img src="/images/hefu_train/IMG_4519.jpg" alt=""><br><img src="/images/hefu_train/IMG_4520.jpg" alt=""><br><center>鼓浪屿</center><br>鼓浪屿上面的欧式风格的建筑，文艺的小店，小吃等非常多，龙头路非常热闹。<br><img src="/images/hefu_train/IMG_4541.jpg" alt=""><br><center>最后附上行程的所有火车票</center>
]]></content>
    <summary type="html">
    <![CDATA[<p>国庆本来自己没什么计划，后来同学一起计划沿着合福高铁沿线的景点游一圈，合福高铁将黄山、三清山、武夷山、福州、厦门等联系在了一起，横跨三个省份，当真是中国最美的高铁线路。由于人在杭州，因此打算从杭州出发，六天的行程计划去三清山、武夷山、福州和厦门。正所谓计划赶不上变化，再加上]]>
    </summary>
    
      <category term="合福高铁,三清山,武夷山,福州,三坊七巷,厦门,鼓浪屿" scheme="http://www.notehub.cn/tags/%E5%90%88%E7%A6%8F%E9%AB%98%E9%93%81-%E4%B8%89%E6%B8%85%E5%B1%B1-%E6%AD%A6%E5%A4%B7%E5%B1%B1-%E7%A6%8F%E5%B7%9E-%E4%B8%89%E5%9D%8A%E4%B8%83%E5%B7%B7-%E5%8E%A6%E9%97%A8-%E9%BC%93%E6%B5%AA%E5%B1%BF/"/>
    
      <category term="travel" scheme="http://www.notehub.cn/categories/travel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[特征处理]]></title>
    <link href="http://www.notehub.cn/2015/09/25/algo/ml/Feature%20Processing/"/>
    <id>http://www.notehub.cn/2015/09/25/algo/ml/Feature Processing/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2015-09-25T14:37:04.000Z</updated>
    <content type="html"><![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processing），是因为这里面要介绍的东西只是特征工程中的一小部分。这部分比较基础，比较容易说，所以由此开始。单个原始特征（或称为变量）通常属于以下几类之一：</p>
<ul>
<li>连续（continuous）特征；</li>
<li>无序类别（categorical）特征；</li>
<li>有序类别（ordinal）特征。</li>
</ul>
<p>本文中我主要介绍针对单个特征的处理方法，虽然也会附带介绍基础的特征组合方法。同时处理多个特征，以及更复杂的特征处理方法介绍，以后我再另外细说。下面我由浅入深地逐渐说明针对这三类特征的常用处理方法。</p>
<h2 id="初级篇">初级篇</h2><hr>
<h3 id="连续特征">连续特征</h3><p>除了归一化（去中心，方差归一），不用做太多特殊处理，可以直接把连续特征扔到模型里使用。</p>
<h3 id="无序特征">无序特征</h3><p>可以使用One-hot（也叫One-of-k）的方法把每个无序特征转化为一个数值向量。比如一个无序特征color有三种取值：red，green，blue。那么可以用一个长度为3的向量来表示它，向量中的各个值分别对应于red，green，blue。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color取值 向量表示</span><br><span class="line">red     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">green   (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">blue    (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>这种方法在NLP里用的很多，就是所谓的词向量模型。变换后的向量长度对于词典长度，每个词对应于向量中的一个元素。</p>
<p>机器学习书籍里在讲这个的时候介绍的处理方法可能跟我上面说的有点差别。上面说的表达方式里有一个维度是可以省略的。既然我们知道color一定是取3个值中的一个，那么我们知道向量的前两个元素值，就能推断第3个值是多少。所以，其实用下面的方式就可以表达到底是哪种颜色：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">color取值 向量表示</span><br><span class="line">red     (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">green   (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">blue    (<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这样表达的好处是少用了一个维度，降低了转化后特征之间的相关性。但在实际问题中特征基本都或多或少会有些缺失。使用第一种表达方式就可以用全0的向量来表示值缺失，而第二种表达方式是没法表达缺失的。</p>
<h3 id="有序特征">有序特征</h3><p>有些特征虽然也像无序特征那样只取限定的几个值，但是这些值之间有顺序的含义。例如一个人的状态status有三种取值：bad, normal, good，显然bad &lt; normal &lt; good。</p>
<p>当然，对有序特征最简单的处理方式是忽略其中的顺序关系，把它看成无序的，这样我们就可以使用处理无序特征的方式来处理它。在实际问题中，这种处理方式其实用的很多。</p>
<p>当然有些问题里有序可能会很重要，这时候就不应该把其中的顺序关系丢掉。一般的表达方式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status取值    向量表示</span><br><span class="line">bad     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">normal  (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">good    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面这种表达方式很巧妙地利用递进表达了值之间的顺序关系。</p>
<h2 id="中级篇">中级篇</h2><hr>
<p>最容易让人掉以轻心的，往往就是大家觉得最简单的事。在特征处理中，最容易让刚入门同学忽略的，是对连续特征的处理方式。</p>
<p>以线性分类器Linear Regression (LinearReg)为例，它是通过特征的线性加权来预测因变量y：<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">y</span>=<span class="string">wTx</span></span><br></pre></td></tr></table></figure></p>
<p>但大部分实际情况下，y与x都不会是这么简单的线性关系，甚至连单调关系都不会有。举个只有一个特征的例子，如果y与x的实际关系如下图：</p>
<p><img src="/images/algo/nonlinear_function1.png" alt=""></p>
<p>那么直接把x扔进LinearReg模型是怎么也得不到好结果的。很多人会想着既然线性分类器搞不定，那就直接找个非线性的好了，比如高斯核的SVM。我们确实可以通过这种简单换算法的方式解决这个简单的问题。但对于很多实际问题（如广告点击率预测），往往特征非常多，这时候时间约束通常不允许我们使用很复杂的非线性分类器。这也是为什么算法发展这么多年，广告点击率预测最常用的方法还是Logistic Regression (LogisticReg)。</p>
<p>对于上面这个问题，有没有什么办法使得LinearReg也能处理得不错？当然是有，就是对原始特征x做转化，把原来的非线性关系转化为线性关系。</p>
<h3 id="方法一：离散化">方法一：离散化</h3><p>最常用的转化方式是对x做离散化(discretization)，也就是把原来的值分段，转化成一个取值为0或1的向量。原始值落在某个段里，向量中此段对应的元素就为1，否则为0。</p>
<p>离散化的目标是y与转化后向量里的每个元素都保持比较好的线性关系。<br>比如取离散点{0.5,1.5,2.5}，通过判断x属于(−∞,0.5)，[0.5,1.5)，[1.5,2.5)，[2.5,+∞)中哪段来把它离散化为4维的向量。下面是一些例子的离散结果：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原始值x    离散化后的值</span><br><span class="line"><span class="number">0.1</span>     (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">1.3</span>     (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="number">3.2</span>     (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">5.8</span>     (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>离散化方法的关键是怎么确定分段中的离散点。下面是常用的选取离散点的方法：</p>
<p>a. 等距离离散：顾名思义，就是离散点选取等距点。我们上面对x取离散点{0.5,1.5,2.5}就是一种等距离散，见下图。图中垂直的灰线代表离散点。</p>
<p><img src="/images/algo/nonlinear_function2.png" alt=""></p>
<p>b. 等样本点离散：选取的离散点保证落在每段里的样本点数量大致相同，见下图。</p>
<p><img src="/images/algo/nonlinear_function3.png" alt=""></p>
<p>c. 画图观察趋势：以x为横坐标，y为纵坐标，画图，看曲线的趋势和拐点。通过观察下面的图我们发现可以利用3条直线（红色直线）来逐段近似原来的曲线。把离散点设为两条直线相交的各个点，我们就可以把x离散化为长度为3的向量。</p>
<p><img src="/images/algo/nonlinear_function4.png" alt=""></p>
<p>上面介绍的这种离散化为0/1向量的方法有个问题，它在离散时不会考虑到具体的x到离散边界的距离。比如等距离散中取离散点为{0.5,1.5,2.5}，那么1.499，1.501和2.49分别会离散为(0, 1, 0, 0)，(0, 0, 1, 0)和(0, 0, 1, 0)。1.499和1.501很接近，可是就因为这种强制分段的离散导致它们离散的结果差距很大。</p>
<p>针对上面这种硬离散的一种改进就是使用软离散，也就是在离散时考虑到x与附近离散点的距离，离散出来的向量元素值可以是0/1之外的其他值。有兴趣的同学可以去ESL1这本书中找点感觉。</p>
<h3 id="方法二：函数变换">方法二：函数变换</h3><p>函数变换直接把原来的特征通过非线性函数做变换，然后把原来的特征，以及变换后的特征一起加入模型进行训练。常用的变换函数见下表，不过其实你可以尝试任何函数。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用非线性函数f<span class="params">(x)</span> x的取值范围</span><br><span class="line">xα; α∈<span class="params">(−∞,+∞)</span>   <span class="params">(−∞,+∞)</span></span><br><span class="line"><span class="built_in">log</span><span class="params">(x)</span>          <span class="params">(<span class="number">0</span>,+∞)</span></span><br><span class="line"><span class="built_in">log</span><span class="params">(x1−x)</span>       <span class="params">(<span class="number">0</span>,<span class="number">1</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>这个方法操作起来很简单，但记得对新加入的特征做归一化。</p>
<p>对于我们前面的问题，只要把x2，x3也作为特征加入即可，因为实际上y就是x的一个三次多项式。</p>
<h2 id="高级篇">高级篇</h2><hr>
<h3 id="笛卡尔乘积">笛卡尔乘积</h3><p>我们可以使用笛卡尔乘积的方式来组合2个或更多个特征。比如有两个类别特征color和light，它们分别可以取值为red，green，blue和on, off。这两个特征各自可以离散化为3维和2维的向量。对它们做笛卡尔乘积转化，就可以组合出长度为6的特征，它们分别对应着原始值对(red, on)，(red, off)，(green, on)，(green, off)，(blue, on)，(blue, off)。下面的矩阵表达方式更清楚地说明了这种组合。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">X</span>       <span class="built_in">on</span>  <span class="built_in">off</span></span><br><span class="line">red      </span><br><span class="line">green        </span><br><span class="line">blue</span><br></pre></td></tr></table></figure></p>
<p>对于3个特征的笛卡尔乘积组合，可以表达为立方的形式。更多特征的组合依次类推。 这个方法也可以直接用于连续特征与类别特征之间的组合，只要把连续特征看成是1维的类别特征就好了，这时候组合后特征对应的值就不是0/1了，而是连续特征的取值。</p>
<h3 id="离散化续篇">离散化续篇</h3><p>在上节中我已经介绍了一些常用的离散化单个连续特征的方法，其中一个是画图观察趋势。画图观察趋势的好处是直观、可解释性强，坏处是很麻烦。当要离散化的特征很多时，这种方法可操作性较差。</p>
<p>机器学习中有个很好解释，速度也不错的模型——决策树模型。大白话说决策树模型就是一大堆的if else。它天生就可以对连续特征分段，所以把它用于离散化连续特征合情合理。我称这种方法为决策树离散化方法。例如Gmail在对信件做重要性排序时就使用了决策树离散化方法2。</p>
<p>决策树离散化方法通常也是每次离散化一个连续特征，做法如下：</p>
<p>单独用此特征和目标值y训练一个决策树模型，然后把训练获得的模型内的特征分割点作为离散化的离散点。<br>这种方法当然也可以同时离散化多个连续特征，但是操作起来就更复杂了，实际用的不多。</p>
<h3 id="核方法">核方法</h3><p>核方法经常作为线性模型的一种推广出现。以线性回归模型为例，它对应的核方法如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fθ(x)=∑θ<span class="function"><span class="title">iK</span><span class="params">(x,xi)</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中{xi}=1为训练样本点，K(xi,xj)为核函数，比如常用的高斯核函数为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">K</span><span class="params">(xi,xj)</span></span>=<span class="function"><span class="title">exp</span><span class="params">(−exp(∥xi−xj∥, <span class="number">2</span>)</span></span>/<span class="number">2</span>*<span class="function"><span class="title">exp</span><span class="params">(h,<span class="number">2</span>)</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>如果我们把上面模型里的{K(x,xi)}=1看成特征，而θ看成模型参数的话，上面的模型仍旧是个线性模型。所以可以认为核方法只是特征函数变换的一种方式。</p>
<p>当然，如果把核函数K(xi,xj)看成一种相似度的话，那上面的模型就是kNN模型了，或者叫做加权平均模型也可以。因为核方法在预测时也要用到训练样本点，耗内存且计算量大，所以在数据量较大的实际问题中用的并不多。到此，我已经介绍了不少针对单个特征的处理方法。这些处理方法很难说哪个好哪个不好。有些问题这个好，有些问题那个好，也没什么绝招能直接判断出哪种方法能适合哪些问题。唯一的招就是：</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>特征工程（Feature Engineering）经常被说为机器学习中的black art，这里面包含了很多不可言说的方面。怎么处理好特征，最重要的当然还是对要解决问题的了解。但是，它其实也有很多科学的地方。这篇文章我之所以命名为特征处理（Feature Processin]]>
    </summary>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Feature hashing]]></title>
    <link href="http://www.notehub.cn/2015/09/25/algo/ml/feature_hashing/"/>
    <id>http://www.notehub.cn/2015/09/25/algo/ml/feature_hashing/</id>
    <published>2015-09-24T16:00:00.000Z</published>
    <updated>2015-09-25T14:43:22.000Z</updated>
    <content type="html"><![CDATA[<p>In machine learning, feature hashing, also known as the hashing trick(by analogy to the kernel trick), is a fast and space-efficient way of vectorizing features, i.e. turning arbitrary features into indices in a vector or matrix. It works by applying a hash function to the features and using their hash values as indices directly, rather than looking the indices up in an associative array.</p>
<h3 id="Motivating_example">Motivating example</h3><p>In a typical document classification task, the input to the machine learning algorithm (both during learning and classification) is free text. From this, a bag of words (BOW) representation is constructed: the individual tokens are extracted and counted, and each distinct token in the training set defines a feature (independent variable) of each of the documents in both the training and test sets.</p>
<p>Machine learning algorithms, however, are typically defined in terms of numerical vectors. Therefore, the bags of words for a set of documents is regarded as a term-document matrix where each row is a single document, and each column is a single feature/word; the entry i, j in such a matrix captures the frequency (or weight) of the j’th term of the vocabulary in document i. (An alternative convention swaps the rows and columns of the matrix, but this difference is immaterial.) Typically, these vectors are extremely sparse.</p>
<p>The common approach is to construct, at learning time or prior to that, a dictionary representation of the vocabulary of the training set, and use that to map words to indices. Hash tables and tries are common candidates for dictionary implementation. E.g., the three documents</p>
<p>John likes to watch movies.<br>Mary likes movies too.<br>John also likes football.<br>can be converted, using the dictionary<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Term    Index</span><br><span class="line">John    <span class="number">1</span></span><br><span class="line">likes   <span class="number">2</span></span><br><span class="line">to      <span class="number">3</span></span><br><span class="line">watch   <span class="number">4</span></span><br><span class="line">movies  <span class="number">5</span></span><br><span class="line">Mary    <span class="number">6</span></span><br><span class="line">too     <span class="number">7</span></span><br><span class="line">also    <span class="number">8</span></span><br><span class="line">football9</span><br></pre></td></tr></table></figure></p>
<p>to the term-document matrix</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">0</span> &amp; <span class="number">1</span> &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>(Punctuation was removed, as is usual in document classification and clustering.)</p>
<p>The problem with this process is that such dictionaries take up a large amount of storage space and grow in size as the training set grows. On the contrary, if the vocabulary is kept fixed and not increased with a growing training set, an adversary may try to invent new words or misspellings that are not in the stored vocabulary so as to circumvent a machine learned filter. This difficulty is why feature hashing has been tried for spam filtering at Yahoo! Research.</p>
<p>Note that the hashing trick isn’t limited to text classification and similar tasks at the document level, but can be applied to any problem that involves large (perhaps unbounded) numbers of features.</p>
<h3 id="Feature_vectorization_using_the_hashing_trick">Feature vectorization using the hashing trick</h3><p>Instead of maintaining a dictionary, a feature vectorizer that uses the hashing trick can build a vector of a pre-defined length by applying a hash function h to the features (e.g., words) in the items under consideration, then using the hash values directly as feature indices and updating the resulting vector at those indices:</p>
<p> function hashing_vectorizer(features : array of string, N : integer):<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">x :</span>= <span class="keyword">new</span> vector[N]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> <span class="string">features:</span></span><br><span class="line">    <span class="string">h :</span>= hash(f)</span><br><span class="line">    x[h mod N] += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>It has been suggested that a second, single-bit output hash function ξ be used to determine the sign of the update value, to counter the effect of hash collisions. If such a hash function is used, the algorithm becomes</p>
<p> function hashing_vectorizer(features : array of string, N : integer):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="keyword">new</span> <span class="built_in">vector</span>[N]</span><br><span class="line"><span class="keyword">for</span> f in features:</span><br><span class="line">    h := hash(f)</span><br><span class="line">    idx := h mod N</span><br><span class="line">    <span class="keyword">if</span> ξ(f) == <span class="number">1</span>:</span><br><span class="line">        x[idx] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x[idx] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>The above pseudocode actually converts each sample into a vector. An optimized version would instead only generate a stream of (h,ξ) pairs and let the learning and prediction algorithms consume such streams; a linear model can then be implemented as a single hash table representing the coefficient vector.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>In machine learning, feature hashing, also known as the hashing trick(by analogy to the kernel trick), is a fast and space-efficient way ]]>
    </summary>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习资料大汇总]]></title>
    <link href="http://www.notehub.cn/2015/09/23/algo/ml/"/>
    <id>http://www.notehub.cn/2015/09/23/algo/ml/</id>
    <published>2015-09-22T16:00:00.000Z</published>
    <updated>2015-09-23T05:09:18.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/other/ml.jpg" alt=""></p>
<p>注：本页面主要针对想快速上手机器学习而又不想深入研究的同学，对于专门的researcher，建议直接啃PRML，ESL，MLAPP以及你相应方向的书（比如Numerical Optimization，Graphic Model等），另外就是Follow牛会牛paper，如果谁有兴趣也可以一起来整理个专业的汇总页。本页面将持续更新，敬请关注，如有推荐的文章请留言，谢谢！</p>
<h3 id="开源工具">开源工具</h3><hr>
<p><a href="http://www.52ml.net/12043.html" target="_blank" rel="external">机器学习的开源工具</a><br><a href="http://www.52ml.net/13547.html" target="_blank" rel="external">Python机器学习库</a><br><a href="http://www.52ml.net/13002.html" target="_blank" rel="external">C++矩阵运算库推荐</a></p>
<h3 id="公开课">公开课</h3><hr>
<ul>
<li>Machine Learning | Coursera Andrew NG在coursera上的课，难度比公开课略低，适合入门</li>
<li>斯坦福大学公开课 ：机器学习课程 Andrew NG在学校里面的课程，网易公开课有中英文字幕，可以配合笔记来看</li>
<li>CMU机器学习系主任Tom Mitchell院士机器学习课程视频及课件（英文）</li>
<li>机器学习|加州理工，老师是Yaser Abu-Mostafa，会从最基本的理论开始，为你构建机器学习的基础。</li>
<li>机器学习基石 如果想听中文课程，台湾大学的这门就很合适，友情提示，台大的课程基本上都可以加快语速来听，原因你懂的</li>
<li>神经网络|多伦多大学 鼎鼎大名的Geoffrey Hinton ，这门课着实不容错过</li>
<li>凸优化课程|斯坦福 授课老师是凸优化经典教材的作者Stephen Boyd！有难度有挑战！</li>
<li>概率图模型  coursera的另外一个创始人，Daphne Koller的课程，值得一提的是，Koller因提出了Probabilistic Relational Models拿到了2001年的IJCAI Computers and Thought Award</li>
<li>统计学习|斯坦福 授课老师是ESL作者 ，还有同学把视频放在了百度网盘上～ 这个更快一些</li>
</ul>
<h3 id="1-_机器学习入门篇">1. 机器学习入门篇</h3><h4 id="1-1_机器学习介绍">1.1 机器学习介绍</h4><ul>
<li>机器学习-维基百科  Machine Learning-Wikipedia</li>
<li>机器学习简史</li>
<li>规则与机器学习 不建议为了机器学习而机器学习，对于初学者应该是先规则再机器学习，规则直观，可以深入理解领域知识和特征，要记住一个机器学习的专家必须首先是该领域知识的专家。</li>
<li>贝叶斯思想 MLAPP 第5章 Bayesian statistics 第6章 Frequentist statistics 机器学习第6章 贝叶斯学习</li>
<li>监督学习 ESL 第2章 Overview of Supervised Learning</li>
</ul>
<h4 id="1-2_书籍">1.2 书籍</h4><ul>
<li>《统计学习方法》 第1章 统计学习方法概论</li>
<li>《机器学习》（Mitchell） 第1章 引言</li>
<li>PRML 第1章 Introduction</li>
<li>MLAPP 第1章 Introduction 第2章 Probability</li>
<li>ESL 第1章 Introduction</li>
<li>Some Notes on Applied Mathematics for Machine (选修)</li>
<li>Machine Learning Textbook minireviews</li>
<li>List of Cool Machine Learning Books</li>
</ul>
<h4 id="1-3_数学基础">1.3 数学基础</h4><ul>
<li>线性代数：公开课： 线性代数；推荐文章 ： 线性代数的本质，</li>
<li>概率论：公开课： 概率课|台大 叶老师为人风趣幽默，课程也比较简单，容易听进去</li>
<li>书籍：MLAPP第二章</li>
<li>微积分：公开课：单变量微积分|MIT 多变量微积分|MIT</li>
</ul>
<p>——————————————-</p>
<h4 id="1-4_LDA">1.4 LDA</h4><ul>
<li>LDA最佳学习资料汇总</li>
</ul>
<h4 id="1-4_Spectral_Clustering">1.4 Spectral Clustering</h4><ul>
<li>Spectral Clustering最佳学习资料汇总</li>
</ul>
<h4 id="1-5_图像处理">1.5 图像处理</h4><ul>
<li>图像处理和计算机视觉中的经典论文</li>
</ul>
<h4 id="2_线性回归模型">2 线性回归模型</h4><ul>
<li>PRML 第3章 Linear Models for Regression</li>
<li>MLAPP 第7章 Linear Regression 第13章 Sparse Linear Models</li>
<li>ESL 第3章 Linear Method for Regression</li>
</ul>
<h4 id="3_线性分类模型">3 线性分类模型</h4><ul>
<li>PRML 第4章 Linear Models for Classification</li>
<li>MLAPP 第8章 Logistic Regression 第9章 Generalized Linear Models and the exponential family</li>
<li>ESL 第4章 Linear Method for Classification</li>
<li>统计机器学习 第6章 逻辑斯谛回归与最大熵模型</li>
</ul>
<h4 id="4_神经网络">4 神经网络</h4><ul>
<li>PRML 第5章 Neural Networks</li>
<li>ESL 第11章 Neural Networks</li>
<li>统计学习方法 第2章 感知机</li>
<li>机器学习 第4章 人工神经网络</li>
</ul>
<h4 id="5_支持向量机">5 支持向量机</h4><ul>
<li>统计学习方法 第7章 支持向量机 (强烈推荐)</li>
<li>PRML 第6章 Kernel Methods 第7章 Sparse Kernel Machine</li>
<li>ESL 第12章 Support Vector Machines and Flexible Discriminants</li>
<li>MLAPP 第14章 Kernels</li>
</ul>
<h4 id="6_图模型">6 图模型</h4><ul>
<li>PRML 第8章 Graphical Models</li>
<li>MLAPP 第10章 Directed graphical models（Bayes nets） 第19章 Undirected Graphical Models（Marcov random fields）第20章 Exact inference for graphical models 第26章 Graphical model structure learning</li>
<li>统计学习方法 第10章 隐马尔可夫模型 第11章 条件随机场</li>
<li>机器学习 6.11 贝叶斯信念网</li>
<li>ESL 第17章 Undirected Graphical Models</li>
<li>Koller 的书</li>
<li>Jordan 的书</li>
</ul>
<h4 id="7_混合模型和EM">7 混合模型和EM</h4><ul>
<li>PRML 第9章 Mixture Models and EM</li>
<li>MLAPP 第11章 Mixture models and the EM algorithm</li>
<li>ESL 8.5 The EM Algorithm</li>
<li>统计学习方法 第9章 EM算法及其推广</li>
</ul>
<h4 id="8_近似推理">8 近似推理</h4><ul>
<li>PRML 第10章 Approximate Inference</li>
<li>MLAPP 第21章 Variational Inference 第22章 More Variational Inference</li>
</ul>
<h4 id="9_采样方法">9 采样方法</h4><ul>
<li>PRML 第11章 Sampling Methods</li>
<li>MLAPP 第23章 Monte Carlo inference 第24章 Markov Chain Monte Carlo (MCMC) inference</li>
<li>ESL 8.6 MCMC for Sampling from Posterior</li>
</ul>
<h4 id="10_PCA">10 PCA</h4><ul>
<li>PRML 第12章 Continuous Latent Variables</li>
<li>MLAPP 第12章 Latent Linear Models</li>
<li>ESL 14.5 Principal Componens， Curves and Surfaces</li>
</ul>
<h4 id="11_HMM">11 HMM</h4><ul>
<li>PRML 13.1 13.2 Hidden Marcov Models</li>
<li>MLAPP 第17章 Marcov and Hidden Marcov Models</li>
</ul>
<h4 id="12_组合模型">12 组合模型</h4><ul>
<li>(投票，boosting，bagging，树模型，model averaging)</li>
<li>PRML 第14章 Combining Models</li>
<li>统计学习方法 第5章 决策树 第8章 提升方法</li>
<li>MLAPP 第16章 Adaptive basis function models</li>
<li>ESL 第15章 Random Forests 第16章 Ensemble Learning 8.7 Bagging 第9章 Additive Models, Trees, and Related Methods 第10章 Boosting and Additive Trees</li>
<li>机器学习 第3章 决策树学习</li>
</ul>
<h4 id="14_聚类">14 聚类</h4><ul>
<li>ESL 14.3 Cluster Analysis</li>
<li>MLAPP 25章 Clustering</li>
<li>PRML 9.1 K-means Clustering</li>
</ul>
<h4 id="15_近邻">15 近邻</h4><ul>
<li>ELS 第13章 Protype Methods and Nearest-Neighbors</li>
</ul>
<h4 id="16_Deep_Learning">16 Deep Learning</h4><ul>
<li><a href="http://deeplearning.net/" target="_blank" rel="external">http://deeplearning.net/</a></li>
<li>Deep Learning Tutorial</li>
<li>MLAPP 第28章 Deep Learning</li>
</ul>
<h4 id="2-2_Deep_Learning教程">2.2 Deep Learning教程</h4><ul>
<li>UFLDL-斯坦福大学Andrew Ng教授“Deep Learning”教程</li>
</ul>
<h3 id="3-_自然语言处理入门篇">3. 自然语言处理入门篇</h3><h4 id="3-1_斯坦福大学自然语言处理公开课">3.1 斯坦福大学自然语言处理公开课</h4><ul>
<li>NLP | 斯坦福  授课教师是 Dan Jurafsky 以及 Christopher Manning，英文不是很有信心的可以参考《斯坦福大学自然语言处理公开课中文解读》</li>
<li>NLP | 哥伦比亚 授课老师是Michael Collins大神</li>
</ul>
<h4 id="3-2_统计机器翻译">3.2 统计机器翻译</h4><ul>
<li>Statistical Machine Translation</li>
<li>统计机器翻译开源软件汇总</li>
</ul>
<p>转自：<a href="http://www.52ml.net/star?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">http://www.52ml.net/star?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/other/ml.jpg" alt=""></p>
<p>注：本页面主要针对想快速上手机器学习而又不想深入研究的同学，对于专门的researcher，建议直接啃PRML，ESL，MLAPP以及你相应方向的书（比如Numerical Opt]]>
    </summary>
    
      <category term="PPTP, vpn" scheme="http://www.notehub.cn/tags/PPTP-vpn/"/>
    
      <category term="machine learning" scheme="http://www.notehub.cn/categories/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[How to customize Writable class in Hadoop]]></title>
    <link href="http://www.notehub.cn/2015/09/21/dev/How%20to%20customize%20Writable%20class%20in%20Hadoop/"/>
    <id>http://www.notehub.cn/2015/09/21/dev/How to customize Writable class in Hadoop/</id>
    <published>2015-09-21T04:49:45.000Z</published>
    <updated>2015-09-21T06:13:25.000Z</updated>
    <content type="html"><![CDATA[<p>I’m trying to implement Writable class, but i have no idea on how to implement a writable class if in my class there is nested object, such as list, etc.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageClass</span> <span class="keyword">implements</span> <span class="title">Writable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String xStr;</span><br><span class="line"><span class="keyword">public</span> String yStr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Field&gt; sStor</span><br><span class="line"></span><br><span class="line"><span class="comment">//omitted ctors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    out.writeChars(xStr);</span><br><span class="line">    out.WriteChars(yStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//WHAT SHOULD I DO FOR List&lt;Field&gt;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    xStr = in.readLine();</span><br><span class="line">    yStr = in.readLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//WHAT SHOULD I DO FOR List&lt;Field&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubStorage</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String x;</span><br><span class="line">    <span class="keyword">public</span> String y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Following is the Field class:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Field</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Field</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> DataType dataType;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="keyword">private</span> FieldType fieldType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Field</span><span class="params">(String name, DataType dataType, FieldType fieldType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, dataType, <span class="keyword">null</span>, fieldType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Field</span><span class="params">(String name, DataType type, Object value, FieldType fieldType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dataType = type;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.fieldType = fieldType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FieldType &#123;</span><br><span class="line">    PRI, LOOKUP, SCD, VERSION, OTHER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DataType &#123;</span><br><span class="line"></span><br><span class="line">    UNDEFINED(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSizeInBytes</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> STRING.getSizeInBytes(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    STRING(<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSizeInBytes</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSizeInBytes(value) + (value.toString().length() * <span class="number">2</span>); <span class="comment">// length + chars</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    INT(<span class="number">4</span>),</span><br><span class="line">    LONG(<span class="number">8</span>),</span><br><span class="line">    DOUBLE(<span class="number">8</span>),</span><br><span class="line">    DATETIME(<span class="number">8</span>),</span><br><span class="line">    BOOLEAN(<span class="number">1</span>),</span><br><span class="line">    BYTE(<span class="number">1</span>),</span><br><span class="line">    FLOAT(<span class="number">4</span>),</span><br><span class="line">    SHORT(<span class="number">2</span>),</span><br><span class="line">    CHAR(<span class="number">2</span>),</span><br><span class="line">    DATE(<span class="number">8</span>),</span><br><span class="line">    TIME(<span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    BLOB(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSizeInBytes</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">byte</span>[])value).length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sizeInBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DataType</span><span class="params">(<span class="keyword">int</span> sizeInBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeInBytes = sizeInBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSizeInBytes</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizeInBytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Serializing collections is quite simple.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = in.readInt();</span><br><span class="line">    list= <span class="keyword">new</span> ArrayList&lt;Field&gt;(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        Field f = <span class="keyword">new</span> Field();</span><br><span class="line">        f.readFields(in);</span><br><span class="line">        list.add(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.writeInt(list.size());</span><br><span class="line">    <span class="keyword">for</span> (Field l : list) &#123;</span><br><span class="line">        l.write(out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>I’m trying to implement Writable class, but i have no idea on how to implement a writable class if in my class there is nested object, su]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MurmurHash]]></title>
    <link href="http://www.notehub.cn/2015/09/03/algo/murmurhash-md/"/>
    <id>http://www.notehub.cn/2015/09/03/algo/murmurhash-md/</id>
    <published>2015-09-03T06:55:54.000Z</published>
    <updated>2015-09-03T06:58:03.000Z</updated>
    <content type="html"><![CDATA[<p>　　MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。由Austin Appleby在2008年发明，并出现了多个变种，都已经发布到了公有领域(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分布特征表现更良好。</p>
<h3 id="变种">变种</h3><p>　　当前的版本是MurmurHash3， 能够产生出32-bit或128-bit哈希值。较早的MurmurHash2能产生32-bit或64-bit哈希值。对于大端存储和强制对齐的硬件环境有一个较慢的MurmurHash2可以用。MurmurHash2A 变种增加了Merkle–Damgård 构造，所以能够以增量方式调用。 有两个变种产生64-bit哈希值：MurmurHash64A，为64位处理器做了优化；MurmurHash64B，为32位处理器做了优化。MurmurHash2-160用于产生160-bit 哈希值，而MurmurHash1已经不再使用。</p>
<h3 id="实现">实现</h3><p>　　最初的实现是C++的，但是被移植到了其他的流行语言上，包括 Python, C,C#, Perl, Ruby, PHP,Haskell,、Scala、Java和JavaScript等。这个算法已经被若干开源计划所采纳，最重要的有libstdc++ (4.6版)、Perl、nginx (不早于1.0.1版)、Rubinius、 libmemcached (Memcached的C语言客户端驱动)、maatkit、Hadoop、Kyoto Cabinet以及RaptorDB。</p>
<p>A sample C implementation follows:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> murmur3_32(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">uint32_t</span> len, <span class="keyword">uint32_t</span> seed) &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> c1 = <span class="number">0xcc9e2d51</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> c2 = <span class="number">0x1b873593</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> r1 = <span class="number">15</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> r2 = <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint32_t</span> n = <span class="number">0xe6546b64</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">uint32_t</span> hash = seed;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> nblocks = len / <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint32_t</span> *blocks = (<span class="keyword">const</span> <span class="keyword">uint32_t</span> *) key;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> k = blocks[i];</span><br><span class="line">		k *= c1;</span><br><span class="line">		k = (k &lt;&lt; r1) | (k &gt;&gt; (<span class="number">32</span> - r1));</span><br><span class="line">		k *= c2;</span><br><span class="line"> </span><br><span class="line">		hash ^= k;</span><br><span class="line">		hash = ((hash &lt;&lt; r2) | (hash &gt;&gt; (<span class="number">32</span> - r2))) * m + n;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span> *tail = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *) (key + nblocks * <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">uint32_t</span> k1 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">switch</span> (len &amp; <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		k1 ^= tail[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		k1 ^= tail[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		k1 ^= tail[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">		k1 *= c1;</span><br><span class="line">		k1 = (k1 &lt;&lt; r1) | (k1 &gt;&gt; (<span class="number">32</span> - r1));</span><br><span class="line">		k1 *= c2;</span><br><span class="line">		hash ^= k1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	hash ^= len;</span><br><span class="line">	hash ^= (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	hash *= <span class="number">0x85ebca6b</span>;</span><br><span class="line">	hash ^= (hash &gt;&gt; <span class="number">13</span>);</span><br><span class="line">	hash *= <span class="number">0xc2b2ae35</span>;</span><br><span class="line">	hash ^= (hash &gt;&gt; <span class="number">16</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="相关资源：">相关资源：</h3><ol>
<li><a href="http://blog.csdn.net/yfkiss/article/details/7337382" target="_blank" rel="external">http://blog.csdn.net/yfkiss/article/details/7337382</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C</a></li>
<li><a href="https://en.wikipedia.org/wiki/MurmurHash" target="_blank" rel="external">https://en.wikipedia.org/wiki/MurmurHash</a></li>
<li><a href="https://github.com/lijingpeng/java_util/tree/master/src/util/hash" target="_blank" rel="external">https://github.com/lijingpeng/java_util/tree/master/src/util/hash</a></li>
<li><a href="https://github.com/huichen/murmur/blob/master/murmur.go" target="_blank" rel="external">https://github.com/huichen/murmur/blob/master/murmur.go</a></li>
<li><a href="https://pypi.python.org/pypi/mmh3/2.0" target="_blank" rel="external">https://pypi.python.org/pypi/mmh3/2.0</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　MurmurHash 是一种非加密型哈希函数，适用于一般的哈希检索操作。由Austin Appleby在2008年发明，并出现了多个变种，都已经发布到了公有领域(public domain)。与其它流行的哈希函数相比，对于规律性较强的key，MurmurHash的随机分]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java beta distribution]]></title>
    <link href="http://www.notehub.cn/2015/09/03/algo/java-beta-md/"/>
    <id>http://www.notehub.cn/2015/09/03/algo/java-beta-md/</id>
    <published>2015-09-03T06:51:59.000Z</published>
    <updated>2015-09-03T06:54:33.000Z</updated>
    <content type="html"><![CDATA[<p>维基百科介绍：<a href="https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83</a><br><a href="https://en.wikipedia.org/wiki/Beta_distribution" target="_blank" rel="external">https://en.wikipedia.org/wiki/Beta_distribution</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.math3.distribution.BetaDistribution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">double</span> b;</span><br><span class="line">        BetaDistribution beta = <span class="keyword">new</span> BetaDistribution(<span class="number">40.0</span>, <span class="number">40.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            x = Math.random();</span><br><span class="line">            b = beta.inverseCumulativeProbability(x);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BetaDistributionE</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBetaDistribution</span><span class="params">(<span class="keyword">double</span> alpha, <span class="keyword">double</span> beta)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = alpha + beta;</span><br><span class="line">	<span class="keyword">double</span> b;</span><br><span class="line">	<span class="keyword">if</span>(Math.min(alpha, beta) &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">		b = Math.max(<span class="number">1</span>/alpha, <span class="number">1</span>/beta);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">	b = Math.sqrt((a - <span class="number">2</span>) / (<span class="number">2</span>*alpha*beta - a));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> c = alpha + <span class="number">1</span>/b;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">double</span> W = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">boolean</span> reject = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (reject = <span class="keyword">true</span>; reject; ) &#123;</span><br><span class="line"> 		<span class="keyword">double</span> U1 = Math.random();</span><br><span class="line"> 		<span class="keyword">double</span> U2 = Math.random();</span><br><span class="line"> 		<span class="keyword">double</span> V = b * Math.log(U1/(<span class="number">1</span>-U1));</span><br><span class="line"> 		W = alpha * Math.exp(V);</span><br><span class="line"> 		reject = (a*Math.log(a/(beta+W)) + c*V - Math.log(<span class="number">4</span>)) &lt; Math.log(U1*U1*U2);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> (W / (beta + W));</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关资源：</p>
<ol>
<li><a href="http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/distribution/BetaDistribution.html" target="_blank" rel="external">http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math3/distribution/BetaDistribution.html</a></li>
<li><a href="http://stackoverflow.com/questions/13634170/java-using-beta-distribution-to-generate-a-random-number-from-0-to-1" target="_blank" rel="external">http://stackoverflow.com/questions/13634170/java-using-beta-distribution-to-generate-a-random-number-from-0-to-1</a></li>
<li>go语言实现：<a href="https://github.com/purzelrakete/bandit/blob/4fca67f963006845de83860fcd849625251fce57/math/rand.go#L21" target="_blank" rel="external">https://github.com/purzelrakete/bandit/blob/4fca67f963006845de83860fcd849625251fce57/math/rand.go#L21</a></li>
<li>非均衡抽样，在一个概率区间内抽样：Paper：Generating Beta Variates with Nonintegral Shape Parameters</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>维基百科介绍：<a href="https://zh.wikipedia.org/wiki/%CE%92%E5%88%86%E5%B8%83" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%CE%]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[二项分布和Beta分布]]></title>
    <link href="http://www.notehub.cn/2015/09/03/algo/beta-a-md/"/>
    <id>http://www.notehub.cn/2015/09/03/algo/beta-a-md/</id>
    <published>2015-09-03T06:33:26.000Z</published>
    <updated>2015-09-03T06:49:32.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br></pre></td></tr></table></figure>
<h2 id="二项分布">二项分布</h2><hr>
<p>　　在概率论和统计学中，二项分布是n个独立的[是/非]试验中成功的次数的离散概率分布，其中每次试验的成功概率为$p$。举两个例子就很容易理解二项分布的含义了：</p>
<ul>
<li>抛一次硬币出现正面的概率是0.5($p$)，抛10(n)次硬币，出现k次正面的概率。</li>
<li>掷一次骰子出现六点的概率是1/6，投掷6次骰子出现k次六点的概率。</li>
</ul>
<p>　　在上面的两个例子中，每次抛硬币或者掷骰子都和上次的结果无关，所以每次实验都是独立的。二项分布是一个离散分布，k的取值范围为从0到n，只有n+1种可能的结果。scipy.stats.binom为二项分布，下面用它计算抛十次硬币，出现k次正面的概率分布。</p>
<h4 id="In_[16]:">In [16]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">k = np.arange(n+<span class="number">1</span>)</span><br><span class="line">pcoin = stats.binom.pmf(k, n, <span class="number">0.5</span>)</span><br><span class="line">pcoin</span><br></pre></td></tr></table></figure>
<h4 id="Out[16]:">Out[16]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([ <span class="number">0.00097656</span>,  <span class="number">0.00976563</span>,  <span class="number">0.04394531</span>,  <span class="number">0.1171875</span> ,  <span class="number">0.20507813</span>,</span><br><span class="line">        <span class="number">0.24609375</span>,  <span class="number">0.20507813</span>,  <span class="number">0.1171875</span> ,  <span class="number">0.04394531</span>,  <span class="number">0.00976563</span>,</span><br><span class="line">        <span class="number">0.00097656</span>])</span><br></pre></td></tr></table></figure>
<h4 id="In_[17]:">In [17]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pl.stem(k, pcoin, basefmt=<span class="string">"k-"</span>)</span><br><span class="line">pl.margins(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/algo/ssss.png" alt=""><br>下面是投掷6次骰子，出现6点的概率分布。</p>
<h4 id="In_[18]:">In [18]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">6</span></span><br><span class="line">k = np.arange(n+<span class="number">1</span>)</span><br><span class="line">pdice = stats.binom.pmf(k, n, <span class="number">1.0</span>/<span class="number">6</span>)</span><br><span class="line">pdice</span><br></pre></td></tr></table></figure>
<h4 id="Out[18]:">Out[18]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([  <span class="number">3.34897977e-01</span>,   <span class="number">4.01877572e-01</span>,   <span class="number">2.00938786e-01</span>,</span><br><span class="line">         <span class="number">5.35836763e-02</span>,   <span class="number">8.03755144e-03</span>,   <span class="number">6.43004115e-04</span>,</span><br><span class="line">         <span class="number">2.14334705e-05</span>])</span><br></pre></td></tr></table></figure>
<h4 id="In_[19]:">In [19]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pl.stem(k, pdice, basefmt=<span class="string">"k-"</span>)</span><br><span class="line">pl.margins(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/algo/ssss1.png" alt=""></p>
<h2 id="Beta分布">Beta分布</h2><hr>
<p>　　对于硬币或者骰子这样的简单实验，我们事先能很准确地掌握系统成功的概率。然而通常情况下，系统成功的概率是未知的。为了测试系统的成功概率$p$，我们做n次试验，统计成功的次数k，于是很直观地就可以计算出$p = k/n$。然而由于系统成功的概率是未知的，这个公式计算出的$p$只是系统成功概率的最佳估计。也就是说实际上$p$也可能为其它的值，只是为其它的值的概率较小。</p>
<p>　　例如有某种特殊的硬币，我们事先完全无法确定它出现正面的概率。然后抛10次硬币，出现5次正面，于是我们认为硬币出现正面的概率最可能是0.5。但是即使硬币出现正面的概率为0.4，也会出现抛10次出现5次正面的情况。因此我们并不能完全确定硬币出现正面的概率就是0.5，所以$p$也是一个随机变量，它符合Beta分布。</p>
<p>　　Beta分布是一个连续分布，由于它描述概率$p$的分布，因此其取值范围为0到1。 Beta分布有$\alpha$和$\beta$两个参数，其中$\alpha$为成功次数加1，$\beta$为失败次数加1。连续分布用概率密度函数描述，下面绘制实验10次，成功4次和5次时，系统成功概率$p$的分布情况。可以看出$k=5$时，曲线的峰值在$p=0.5$处，而$k=4$时，曲线的峰值在$p=0.4$处。</p>
<h4 id="In_[20]:">In [20]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">p = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">pbeta = stats.beta.pdf(p, k+<span class="number">1</span>, n-k+<span class="number">1</span>)</span><br><span class="line">plot(p, pbeta, label=<span class="string">"k=5"</span>, lw=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">pbeta = stats.beta.pdf(p, k+<span class="number">1</span>, n-k+<span class="number">1</span>)</span><br><span class="line">plot(p, pbeta, label=<span class="string">"k=4"</span>, lw=<span class="number">2</span>)</span><br><span class="line">xlabel(<span class="string">"$p$"</span>)</span><br><span class="line">legend(loc=<span class="string">"best"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/algo/ssss3.png" alt=""><br>　　下面绘制$n=10, k=4$和$n=20, k=8$的概率分布。可以看出峰值都在$p=0.4$处，但是$n=20$的山峰更陡峭。也就是说随着实验次数的增加，$p$取其它值的可能就越小，对$p$的估计就更有信心，因此山峰也就更陡峭了。</p>
<h4 id="In_[30]:">In [30]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line">k = <span class="number">4</span></span><br><span class="line">p = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">pbeta = stats.beta.pdf(p, k+<span class="number">1</span>, n-k+<span class="number">1</span>)</span><br><span class="line">plot(p, pbeta, label=<span class="string">"n=10"</span>, lw=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span></span><br><span class="line">k = <span class="number">8</span></span><br><span class="line">pbeta = stats.beta.pdf(p, k+<span class="number">1</span>, n-k+<span class="number">1</span>)</span><br><span class="line">plot(p, pbeta, label=<span class="string">"n=20"</span>, lw=<span class="number">2</span>)</span><br><span class="line">xlabel(<span class="string">"$p$"</span>)</span><br><span class="line">legend(loc=<span class="string">"best"</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/images/algo/ssss4.png" alt=""></p>
<h2 id="用pymc模拟">用pymc模拟</h2><hr>
<p>　　假设我们的知识库中没有Beta分布，如何通过模拟实验找出$p$的概率分布呢？pymc是一个用于统计估计的库，它可以通过 先验概率和 观测值 模拟出 后验概率 的分布。下面先解释一下这两个概率：</p>
<ul>
<li>先验概率：在贝叶斯统计中，某一不确定量p的先验概率分布是在考虑”观测数据”前，能表达p不确定性的概率分布。</li>
<li>后验概率：在考虑相关证据或数据后所得到的不确定量p的概率分布。</li>
</ul>
<p>　　拿前面抛硬币的实验来说，如果在做实验之前能确信硬币出现正面的概率大概在0.5附近的话，那么它的先验概率就是一个以0.5为中心的山峰波形。而如果是某种特殊的硬币，我们对其出现正面的概率完全不了解，那么它的先验概率就是一个从0到1的平均分布。为了估计这个特殊硬币出现正面的概率，我们做了20次实验，其中出现了8次正面。通过这个实验，硬币出现正面的可能性的后验概率就如上图中的绿色曲线所示。</p>
<p>　　pymc库可以通过先验概率和观测值模拟出后验概率的分布，这对于一些复杂的系统的估计是很有用的。下面我们看看如何用pymc来对这个特殊硬币出现正面的可能性进行估计：首先pcoin是这个特殊硬币出现正面的概率，由于我们没有任何先验知识，因此它的先验概率是一个从0到1的平均分布(Uniform)。假设我们做了20次实验，其中8次为正面。根据前面的介绍可知，出现正面的次数符合二项分布(Binomial)，并且这个二项分布的概率$p$为pcoin。这个通过value参数指定了实验的结果。因此experiment虽然是一个二项分布，但是它已经不能取其它值了。</p>
<h4 id="In_[32]:">In [32]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymc</span><br><span class="line">pcoin = pymc.Uniform(<span class="string">"pcoin"</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">experiment = pymc.Binomial(<span class="string">"experiment"</span>, <span class="number">20</span>, pcoin, value=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>　　接下来通过MCMC对象模拟pcoin的后验概率。MCMC是Markov chain Monte Carlo(马尔科夫蒙特卡洛)的缩写，它是一种用马尔可夫链从随机分布取样的算法。通过调用MCMC对象的sample()，可以对pcoin的后验概率分布进行取样。这里30000为取样次数，5000表示不保存头5000次取样值。这时因为MCMC算法通常有一个收敛过程，我们希望只保留收敛之后的取样值。</p>
<h4 id="In_[33]:">In [33]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mc = pymc.MCMC([pcoin])</span><br><span class="line">mc.sample(<span class="number">30000</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>[<strong><strong><strong><em>**</em></strong></strong></strong>100%<strong><strong><strong><strong>**</strong></strong></strong></strong>]  30000 of 30000 complete<br>　　通过MCMC对象trace()可以获得某个不确定量的取样值。下面的程序获得pcoin的25000次取样值，并用hist()显示其分布情况。由结果可知pcoin的分布与前面介绍的Beta分布一致。</p>
<h4 id="In_[31]:">In [31]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pcoin_trace = mc.trace(<span class="string">"pcoin"</span>)[:]</span><br><span class="line">hist(pcoin_trace, normed=<span class="keyword">True</span>, bins=<span class="number">30</span>);</span><br><span class="line">plot(p, pbeta, <span class="string">"r"</span>, label=<span class="string">"n=20"</span>, lw=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Out[31]:">Out[31]:</h4><p><img src="/images/algo/ssss5.png" alt=""></p>
<h4 id="In_[34]:">In [34]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcoin_trace.shape</span><br></pre></td></tr></table></figure>
<h4 id="Out[34]:">Out[34]:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">25000</span>,)</span><br></pre></td></tr></table></figure>
<p>链接：<a href="http://hyry.dip.jp/tech/slice/slice.html/42" target="_blank" rel="external">http://hyry.dip.jp/tech/slice/slice.html/42</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span clas]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解Beta分布和Dirichlet分布]]></title>
    <link href="http://www.notehub.cn/2015/09/03/algo/beta-md/"/>
    <id>http://www.notehub.cn/2015/09/03/algo/beta-md/</id>
    <published>2015-09-03T06:18:04.000Z</published>
    <updated>2015-09-03T06:31:39.000Z</updated>
    <content type="html"><![CDATA[<p><br><br>在Machine Learning中，有一个很常见的概率分布叫做Beta Distribution：<br><img src="/images/algo/j8b261e3942f702b2a36d5221f9a006bf.png" alt=""><br>同时，Dirichelet Distribution：</p>
<p><img src="/images/algo/j24fc194e3126c49d315032f55d0a52e2.png" alt=""></p>
<h3 id="解释">解释</h3><hr>
<p>　　如果给你一个硬币，投这个硬币有\theta的概率抛出Head，有(1-\theta)的概率抛出Tail。如果在未来抛了五次这个硬币，有三次是Head，有两次是Tail，这个\theta最有可能是多少呢？如果你必须给出一个确定的值，并且你完全根据目前观测的结果来估计\theta，那么\theta = 3/5。</p>
<p><img src="/images/algo/a.png" alt=""></p>
<p>　　如果未来抛出五次硬币，全部都是Head。那么按照1中的逻辑，你将估计\theta为1。也就是说，你估计这枚硬币不管怎么投，都朝上！可是，你想这或许是巧合：世界上没有这么屌的硬币，硬币还是有一定可能抛出Tail的。就算观测到再多次的Head，抛出Tail的概率还是不可能为0。这时候，Bayesian公式横空出世（如下图所示）。我们在估计\theta时，心中先有一个估计，即先验概率。这个估计，表现在Probability中，就是一个概率分布。通俗得来讲，我们不再认为\theta是个固定的值了。</p>
<p><img src="/images/algo/j8b6e228eaeb570260d0f8c12a18add50.png" alt=""></p>
<p>　　在上面的Bayesian公式中，p(\theta)就是个概率分布。这个概率分布可以是任何概率分布，比如高斯分布，比如我们想要说的Beta Distribution。下图是Beta(5,2)的概率分布图。如果我们将这个概率分布作为p(\theta)，那么我们在还未抛硬币前，便认为\theta很可能接近于0.8，而不大可能是个很小的值或是一个很大的值。即，我们在抛硬币前，便估计这枚硬币更可能有0.8的概率抛出正面。</p>
<p><img src="/images/algo/j9f3ba3610336773ac92573a548621b3e.png" alt=""></p>
<p>　　虽然p(\theta)可以是任何种类的概率分布，但是如果使用Beta Distribution，会让之后的计算更加方便。我们接着继续看便知道这是为什么了。况且，通过调节Beta Distribution中的a和b，你可以让这个概率分布变成各种你想要的形状！Beta Distribution已经很足够表达你事先对\theta的估计了。现在我们已经估计好了p(\theta)为一个Beta Distribution，那么p(X|\theta)是多少呢？其实就是个二项分布。继续以1中抛5次硬币抛出3次Head为例，X=抛5次硬币抛出3个Head的事件。</p>
<p><img src="/images/algo/ja3a99d005b464c5164166547afc9e13b.png" alt=""><br>　　Bayesian公式下的p(X)是个Normalizer，或者叫做marginal probability。在\theta离散的情况下，p(X)就是\theta为不同值的时候，p(X|\theta)的求和。比如，如果我们事先估计硬币抛出正面的概率只可能是0.5或者0.8，那么p(X) = p(X|\theta=0.5)+p(X|\theta=0.8)，计算时分别将\theta=0.5和\theta=0.8代入到7中的公式中。而如果我们用Beta Distribution，\theta的概率分布在[0,1]之间是连续的，所以要用积分。</p>
<p><img src="/images/algo/j48e8020e87f818d9414e03ffb9fcf248.png" alt=""></p>
<p>　　p(\theta)是个Beta Distribution，那么在观测到X=抛5次硬币中有3个head的事件后，p(\theta|X)依旧是个Beta Distribution！只是这个概率分布的形状因为观测的事件而发生了变化。<br><img src="/images/algo/j0eca37b51f989944703ffbabadb40086.png" alt=""></p>
<p>　　因为观测前后，对\theta估计的概率分布均为Beta Distribution，这就是为什么使用Beta Distribution方便我们计算的原因了。当我们得知p(\theta|X)=Beta(\theta|a+3, b+2)后，我们就只要根据Beta Distribution的特性，得出\theta最有可能等于多少了。（即\theta等于多少时，观测后得到的Beta distribution有最大的概率密度）。例如下图，仔细观察新得到的Beta Distribution，和（5）中的概率分布对比，发现峰值从0.8左右的位置移向了0.7左右的位置。这是因为新观测到的数据中，5次有3次是head（60%），这让我们觉得，\theta没有0.8那么高。但由于我们之前觉得\theta有0.8那么高，我们觉得抛出head的概率肯定又要比60%高一些！这就是Bayesian方法和普通的统计方法不同的地方。我们结合自己的先验概率和观测结果来给出预测。</p>
<p><img src="/images/algo/j01a0b8b112291e2355890ac32572b01b.png" alt=""></p>
<p>　　如果我们投的不是硬币，而是一个多面体（比如筛子），那么我们就要使用Dirichlet Distribution了。使用Dirichlet Distributio的目的，也是为了让观测后得到的posterior probability依旧是Dirichlet Distribution。比如，我们抛掷一个三面体。抛出这三个面的概率分别为\theta_1, \theta_2和\theta_3。不论\theta_1, \theta_2和\theta_3如何分布，它们相加必须等于1。那它们的概率分布，是在一个立体的空间里的一个面。这个面由\theta_1+\theta_2+\theta_3=1表示。这个面上的任意一点，表示某种\theta_1, \theta_2和\theta_3组合的概率密度。下三图分别由不同的\alpha vector初始化得到不同的Dirichlet Distribution，红颜色代表概率密度较大，蓝颜色的区域概率密度较小。</p>
<p><img src="/images/algo/j3f8307ef170c6664eea5996932322a29.png" alt=""><br>　　Dirichlet Distribution和Beta Distribution都叫做Conjugate Prior。根据你的likelihood function，你可以选择对应的conjugate prior作为你对p(\theta)事先的估计。<br><img src="/images/algo/j3481aac389b57152d20380150d0abd4a.png" alt=""><br>转自：<a href="http://maider.blog.sohu.com/306392863.html" target="_blank" rel="external">http://maider.blog.sohu.com/306392863.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><br><br>在Machine Learning中，有一个很常见的概率分布叫做Beta Distribution：<br><img src="/images/algo/j8b261e3942f702b2a36d5221f9a006bf.png" alt=""><br>同时]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[忠诚度越高买东西越贵]]></title>
    <link href="http://www.notehub.cn/2015/09/03/other/nitian-md/"/>
    <id>http://www.notehub.cn/2015/09/03/other/nitian-md/</id>
    <published>2015-09-03T06:01:28.000Z</published>
    <updated>2015-09-03T06:07:50.000Z</updated>
    <content type="html"><![CDATA[<p>　　引言：马云曾说，阿里巴巴本质上就是一家数据公司，做淘宝的目的也不是为了卖货，而是获得所有零售的数据和制造业的数据；做物流也不仅仅为了送包裹，而是要把这些数据合在一起。而亚马逊公司作为美国最大的一家网络电子商务公司，是网络上最早开始经营电子商务的公司之一，20年的持续发展关键也离不开对数据的分析。如今，我们正从IT时代走向DT时代，即从information technology转向data technology。</p>
<p>　　先问大家一个问题，AB两个顾客同时想买某个品牌的东西，其中A顾客对这个品牌非常喜欢，B是新顾客。如果你是这个品牌的经营者的话，你会卖给谁更贵（假设不是标准定价）？</p>
<p>　　答案是A，我们很多人的观点是我们一定要对老顾客好一些，给他们最优的待遇。这其实是从消费者的角度出发思考，其实从经营的角度来说，忠诚度越高我们反而应该卖得更贵，因为企业经营是追求利润最大化（互联网思维的企业除外哈），另外忠诚度高的顾客不用太担心流失。</p>
<p>　　欺负老顾客，这是一个人艰不拆的真理，会让很多人眼泪忍不住的流下来。其实现在不就是这样的吗？首次打车的顾客免单，第一次购买电影票补贴，第一次消费打折等等。只是这些我们能接受，我们认为合理，接下来讲一个真实的差异化定价的案例。</p>
<h3 id="亚马逊差异化定价测试">亚马逊差异化定价测试</h3><p>　　为提高在主营产品上的赢利，亚马逊在2000年9月中旬开始了著名的差别定价实验。他们选择了68种DVD碟片进行动态定价试验。试验当中，亚马逊根据潜在客户的人口统计资料、在亚马逊的购物历史、上网行为以及上网使用的软件系统确定对这68种碟片的报价水平。</p>
<p>　　例如，名为《泰特斯》（Titus）的碟片对新顾客的报价为22.74美元，而对那些对该碟片表现出兴趣的老顾客的报价则为26.24美元。通过这一定价策略，部分顾客付出了比其他顾客更高的价格，亚马逊因此提高了销售的毛利率。（网络购物可以做到千人千面，每个人看到的页面不一样，价格也可以不一样）</p>
<p>　　但是好景不长，这一差别定价策略实施不到一个月，就有细心的消费者发现了这一秘密，通过在名为DVDTalk 的音乐爱好者社区的交流，成百上千的DVD消费者知道了此事，那些付出高价的顾客当然怨声载道，纷纷在网上以激烈的言辞对亚马逊的做法进行口诛笔伐，有人甚至公开表示以后绝不会在亚马逊购买任何东西。更不巧的是，由于亚马逊前不久才公布了它对消费者在网站上的购物习惯和行为进行了跟踪和记录，因此，这次事件曝光后，消费者和媒体开始怀疑亚马逊是否利用其收集的消费者资料作为其价格调整的依据，这样的猜测让亚马逊的价格事件与敏感的网络隐私问题联系在了一起。最后的结局是亚马逊道歉，然后将差价退给了那些买贵了的顾客。这件事虽然以失败告终，但是这种差异化定价的思路却是可以借鉴的。</p>
<p>　　放眼望去，我们身边到处都是差异化定价的案例：菜市场的小贩看人下菜单，不同顾客买到的机票价格都不同，会员和非会员的价格也不一样，买的多和买得少价格也不一样。唯一不一样的是，这些差异化定价是按照我们常人的逻辑在运行，如买的多就应该便宜。亚马逊的案例恰恰和常规相反，但确实是经营的需要。那么如何做到根据需求差异定价呢？这种需求差异主要体现在时间、地点、消费对象之间三个方面。“时间就是金钱”在这点上彻底体现出来了，新手机上市，如果你是品牌忠实的追随者，那你必须付高价才能得到它，反之，你可以慢慢等待，等到价格降到你的目标价位的时候出手，有些地方高峰电价和平峰电价不一样，机票的价格和距起飞时间成反比，旅游景区的淡旺季门票差异等，这都是需求中利用时间差异的定价方法。</p>
<p>　　新开一个超市如果附近没有竞争对手和有竞争对手时的定价策略是不一样的，一瓶同样品牌的啤酒在超市和酒吧的价格大相径庭，演唱会前排的价格高于后排的价格，海景房的价格比山景房的价格贵等等，这都是需求中地点差异的定价方法。消费对象的定价差异更多体现在会员顾客和非会员顾客的价格差异上，以及女性相对于男性对价格敏感的差异上。未来随着科技的进步会逐渐发展到个体的定价差异上，例如零售商根据你购买或维修冰箱的数据，发现你的冰箱到了更换的时候，就可以给你寄一张200元的冰箱代金券，这样你的价格就和其他人不一样了。需要注意的是差异定价不能引起顾客的反感，需要透彻分析其中的风险。针对亚马逊这个案例，错就错在互联网购物价格太透明了，一旦穿帮就是丑闻。那怎么让顾客不反感，同时企业又能贯彻忠诚度高的顾客价格越贵的原则呢？答案见下图。</p>
<p><img src="/images/bb/792c43ea9c648c61a22c1a50a6439b15.jpg" alt=""><br>看明白了吗？</p>
<p>没看明白的话我就给大家点破吧！</p>
<p>将抽奖结果关联用户数据！</p>
<p>　　怎么理解这句话？就是当买家在网站买东西的时候，旁边放一个抽奖链接，买家可以根据抽奖结果来付款，抽奖结果又减30，减50，一分不减等选项。当买家在按下抽奖按钮的同时，后台大数据就开始工作了，根据你以往的购买数据很快可以算出你对这个商品的忠诚度，喜好度，需要的紧迫性等。当发现你从来没有买过类似的商品的话，就会让你中“大奖”。当发现你是优质买家，那不好意思了，一分不减。这样是不是每个人都高高兴兴的了？你还以为抽奖结果是随机的呢。其实买的永远没有卖的精！你可以看看现在淘宝、京东等消费性电商培都用了这一招！</p>
<h3 id="比较有价值的评论：">比较有价值的评论：</h3><ol>
<li><p>就是利用信息不对称赚钱，不过互联网就是要消除信息不对称，所以这条路其实在互联网上是走不通的</p>
</li>
<li><p>互联网时代，价格是透明的，跨店比价购买的成本近乎为零，同一件商品如果亚马逊卖50，京东卖49，天猫卖45，你猜消 费者会怎么选择？</p>
</li>
<li><p>杀熟很危险，如果用户知道了，可能会对品牌造成致命的影响，而你得到的不过蝇头小利。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　引言：马云曾说，阿里巴巴本质上就是一家数据公司，做淘宝的目的也不是为了卖货，而是获得所有零售的数据和制造业的数据；做物流也不仅仅为了送包裹，而是要把这些数据合在一起。而亚马逊公司作为美国最大的一家网络电子商务公司，是网络上最早开始经营电子商务的公司之一，20年的持续发展]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bayesian Bandits原理及在互联网广告行业的应用]]></title>
    <link href="http://www.notehub.cn/2015/09/03/algo/baysian-bandit-application-md/"/>
    <id>http://www.notehub.cn/2015/09/03/algo/baysian-bandit-application-md/</id>
    <published>2015-09-03T05:48:13.000Z</published>
    <updated>2015-09-03T05:59:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_The_Multi-Armed_Bandit_Problem">1. The Multi-Armed Bandit Problem</h2><p>Suppose you are faced with N slot machines (colourfully called multi-armed bandits). Each bandit has an unknown probability of distributing a prize (assume for now the prizes are the same for each bandit, only the probabilities differ). Some bandits are very generous, others not so much. Of course, you don’t know what these probabilities are. By only choosing one bandit per round, our task is devise a strategy to maximize our winnings.</p>
<p>Of course, if we knew the bandit with the largest probability, then always picking this bandit would yield the maximum winnings. So our task can be phrased as “Find the best bandit, and as quickly as possible”.</p>
<p>The task is complicated by the stochastic nature of the bandits. A suboptimal bandit can return many winnings, purely by chance, which would make us believe that it is a very profitable bandit. Similarly, the best bandit can return many duds. Should we keep trying losers then, or give up?</p>
<p>A more troublesome problem is, if we have a found a bandit that returns pretty good results, do we keep drawing from it to maintain our pretty good score, or do we try other bandits in hopes of finding an even-better bandit? This is the exploration vs. exploitation dilemma.</p>
<h2 id="2-_Applications">2. Applications</h2><p>The Multi-Armed Bandit problem at first seems very artificial, something only a mathematician would love, but that is only before we address some applications:</p>
<p>Internet display advertising: companies have a suite of potential ads they can display to visitors, but the company is not sure which ad strategy to follow to maximize sales. This is similar to A/B testing, but has the added advantage of naturally minimizing strategies that do not work (and generalizes to A/B/C/D… strategies)</p>
<ol>
<li>Ecology: animals have a finite amount of energy to expend, and following certain behaviours has uncertain rewards. How does the animal maximize its fitness?</li>
<li>Finance: which stock option gives the highest return, under time-varying return profiles.</li>
<li>Clinical trials: a researcher would like to find the best treatment, out of many possible treatments, while minimizing losses.</li>
</ol>
<p>Many of these questions above are fundamental to the application’s field. It turns out the optimal solution is incredibly difficult, and it took decades for an overall solution to develop. There are also many approximately-optimal solutions which are quite good. The one I wish to discuss is one of the few solutions that can scale incredibly well. The solution is known asBayesian Bandits.</p>
<h2 id="3-_A_Proposed_Solution">3. A Proposed Solution</h2><p>Any proposed strategy is called an online algorithm (not in the internet sense, but in the continuously-being-updated sense), and more specifically a reinforcement learning algorithm. The algorithm starts in an ignorant state, where it knows nothing, and begins to acquire data by testing the system. As it acquires data and results, it learns what the best and worst behaviours are (in this case, it learns which bandit is the best). With this in mind, perhaps we can add an additional application of the Multi-Armed Bandit problem:</p>
<p>Psychology: how does punishment and reward effect our behaviour? How do humans’ learn?<br>The Bayesian solution begins by assuming priors on the probability of winning for each bandit. In our vignette we assumed complete ignorance of the these probabilities. So a very natural prior is the flat prior over 0 to 1. The algorithm proceeds as follows:</p>
<p>For each round,</p>
<ol>
<li>Sample a random variable Xb from the prior of bandit b, for all b.</li>
<li>Select the bandit with largest sample, i.e. select bandit B=argmaxXb.</li>
<li>Observe the result of pulling bandit B, and update your prior on bandit B.</li>
<li>Return to 1.</li>
</ol>
<p>That’s it. Computationally, the algorithm involves sampling from N distributions. Since the initial priors are Beta(α=1,β=1) (a uniform distribution), and the observed result X (a win or loss, encoded 1 and 0 respectfully) is Binomial, the posterior is a Beta(α=1+X,β=1+1−X)(see here for why to is true). </p>
<p>To answer a question from before, this algorithm suggests that we should not discard losers, but we should pick them at a decreasing rate as we gather confidence that there exist better bandits. This follows because there is always a non-zero chance that a loser will achieve the status of B, but the probability of this event decreases as we play more rounds (see figure below). Below is an implementation of the Bayesian Bandits strategy (which can be skipped for the less Pythonic-ly interested).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymc <span class="keyword">import</span> rbeta</span><br><span class="line"> </span><br><span class="line">rand = np.random.rand</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bandits</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    This class represents N bandits machines.</span><br><span class="line"> </span><br><span class="line">    parameters:</span><br><span class="line">        p_array: a (n,) Numpy array of probabilities &gt;0, &lt;1.</span><br><span class="line"> </span><br><span class="line">    methods:</span><br><span class="line">        pull( i ): return the results, 0 or 1, of pulling </span><br><span class="line">                   the ith bandit.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p_array)</span>:</span></span><br><span class="line">        self.p = p_array</span><br><span class="line">        self.optimal = np.argmax(p_array)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span><span class="params">( self, i )</span>:</span></span><br><span class="line">        <span class="comment">#i is which arm to pull</span></span><br><span class="line">        <span class="keyword">return</span> rand() &lt; self.p[i]</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.p)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BayesianStrategy</span><span class="params">( object )</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    Implements a online, learning strategy to solve</span><br><span class="line">    the Multi-Armed Bandit problem.</span><br><span class="line"> </span><br><span class="line">    parameters:</span><br><span class="line">        bandits: a Bandit class with .pull method</span><br><span class="line"> </span><br><span class="line">    methods:</span><br><span class="line">        sample_bandits(n): sample and train on n pulls.</span><br><span class="line"> </span><br><span class="line">    attributes:</span><br><span class="line">        N: the cumulative number of samples</span><br><span class="line">        choices: the historical choices as a (N,) array</span><br><span class="line">        bb_score: the historical score as a (N,) array</span><br><span class="line"> </span><br><span class="line">    """</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, bandits)</span>:</span></span><br><span class="line"> </span><br><span class="line">        self.bandits = bandits</span><br><span class="line">        n_bandits = len( self.bandits )</span><br><span class="line">        self.wins = np.zeros( n_bandits )</span><br><span class="line">        self.trials = np.zeros(n_bandits )</span><br><span class="line">        self.N = <span class="number">0</span></span><br><span class="line">        self.choices = []</span><br><span class="line">        self.bb_score = []</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample_bandits</span><span class="params">( self, n=<span class="number">1</span> )</span>:</span></span><br><span class="line"> </span><br><span class="line">        bb_score = np.zeros( n )</span><br><span class="line">        choices = np.zeros( n )</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment">#sample from the bandits's priors, and select the largest sample</span></span><br><span class="line">            choice = np.argmax( rbeta( <span class="number">1</span> + self.wins, <span class="number">1</span> + self.trials - self.wins) )</span><br><span class="line"> </span><br><span class="line">            <span class="comment">#sample the chosen bandit</span></span><br><span class="line">            result = self.bandits.pull( choice )</span><br><span class="line"> </span><br><span class="line">            <span class="comment">#update priors and score</span></span><br><span class="line">            self.wins[ choice ] += result</span><br><span class="line">            self.trials[ choice ] += <span class="number">1</span></span><br><span class="line">            bb_score[ k ] = result </span><br><span class="line">            self.N += <span class="number">1</span></span><br><span class="line">            choices[ k ] = choice</span><br><span class="line"> </span><br><span class="line">        self.bb_score = np.r_[ self.bb_score, bb_score ]</span><br><span class="line">        self.choices = np.r_[ self.choices, choices ]</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>Below we present a visualization of the algorithm sequentially learning the solution. In the figure below, the dashed lines represent the true hidden probabilities, which are (0.85, 0.60, 0.75)(this can be extended to many more dimensions, but the figure suffers, so I kept it at 3).</p>
<p><img src="/images/bb/updating2.png" alt=""></p>
<p>Note that we don’t real care how accurate we become about inference of the hidden probabilities — for this problem we are more interested in choosing the best bandit (or more accurately, becoming more confident in choosing the best bandit). For this reason, the distribution of the red bandit is very wide (representing ignorance about what that hidden probability might be) but we are reasonably confident that it is not the best, so the algorithm chooses to ignore it.</p>
<h3 id="几篇介绍Bayesian_Bandits的原理的文章：">几篇介绍Bayesian Bandits的原理的文章：</h3><ol>
<li><a href="https://www.chrisstucchio.com/blog/2013/bayesian_analysis_conversion_rates.html" target="_blank" rel="external">https://www.chrisstucchio.com/blog/2013/bayesian_analysis_conversion_rates.html</a></li>
<li>在线演示博弈过程： <a href="https://e76d6ebf22ef8d7e079810f3d1f82ba1e5f145d5.googledrive.com/host/0B2GQktu-wcTiWDB2R2t2a2tMUG8/" target="_blank" rel="external">https://e76d6ebf22ef8d7e079810f3d1f82ba1e5f145d5.googledrive.com/host/0B2GQktu-wcTiWDB2R2t2a2tMUG8/</a></li>
<li><a href="https://www.chrisstucchio.com/blog/2013/bayesian_bandit.html" target="_blank" rel="external">https://www.chrisstucchio.com/blog/2013/bayesian_bandit.html</a></li>
<li><a href="http://camdp.com/blogs/multi-armed-bandits" target="_blank" rel="external">http://camdp.com/blogs/multi-armed-bandits</a></li>
<li>贝叶斯书籍：<a href="https://github.com/lijingpeng/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers" target="_blank" rel="external">https://github.com/lijingpeng/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_The_Multi-Armed_Bandit_Problem">1. The Multi-Armed Bandit Problem</h2><p>Suppose you are faced with N slot machines (colourfully ]]>
    </summary>
    
  </entry>
  
</feed>
